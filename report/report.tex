\documentclass[a4paper,twoside]{article}
\usepackage[a4paper]{geometry}

% \usepackage[a4paper,showframe]{geometry} % add showframe for debug
% \usepackage{titleps}

\usepackage[pagestyles]{titlesec}
\usepackage[all]{nowidow} % avoid orphan lines

% Extra colours; need to be first
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}

% Basic packages
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

% Landscape mode
\usepackage{pdflscape}

% Additional font
\usepackage{FiraMono}

% Bibtex+cite
\usepackage{cite}
\usepackage{url}
\usepackage[nottoc,numbib]{tocbibind}

% URL
\usepackage[
  colorlinks=true,
  urlcolor=blue,
  citecolor=black,
  linkcolor=.
]{hyperref}

% Lists
\usepackage{scrextend}
\addtokomafont{labelinglabel}{\sffamily}
\usepackage[inline]{enumitem} % for enumerate* environment.

% Maths & symbols
\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{pifont}
\usepackage{framed}
\usepackage{stmaryrd}
\newcommand{\lb}[2]{\llbracket\, #1\,;\, #2\, \rrbracket}

% Mono font
\usepackage[scaled]{beramono}

% Spacing
\usepackage{xspace}

% Graphics
\usepackage{graphicx}

% Table
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{multirow}

% Floating placement
\usepackage{placeins}
% use \FloatBarrier before a \section to ensure all floating are displayed
% before the new section

% Caption styling
\usepackage[justification=centering]{caption}

% Additional colours
\definecolor{c1}{HTML}{006C71}
\definecolor{c2}{HTML}{005155}
\definecolor{c3}{HTML}{FF8928}
\definecolor{c4}{HTML}{E86900}
\colorlet{ImportantCode}{ForestGreen}
\colorlet{ImportantCode2}{RubineRed}
\colorlet{ImportantCode3}{RedOrange}

% TIKZ & related packages/settings
\usepackage{tikz}
\usepackage{pgfplots}
\usetikzlibrary{shapes,fit,backgrounds,arrows,positioning,chains,patterns}
% \pgfplotsset{compat = 1.14}

% for caching tikz pictures
% \usetikzlibrary{external}
% \tikzexternalize[prefix=tikz-figures/]
% \pgfrealjobname{tikz}

% Layout
\usepackage{chngpage}
\usepackage{rotating}

% Listings
\usepackage{listings,multicol}
\usepackage{lstscala}


\lstdefinelanguage{PureScala}{ % Using `Scala` result in a infinite recursion
  style=scala-color,
  morekeywords={[2]Unit,Boolean,Byte,Int,BigInt,String,Char,Option,List,true,false},
  %keywordstyle={[2]\color{blue!30!darkgray}\bfseries}
}

\newcommand{\Inline}[1]{\lstinline[basicstyle=\small\ttfamily,columns=fixed]|#1|}
\newcommand{\InlineS}[1]{\lstinline[language=PureScala,basicstyle=\small\ttfamily,columns=fixed]|#1|}
% %\newcommand{\inlineScala}[1]{\lstinline[language=MyScala,breaklines=true,breakatwhitespace=true]|#1|}

% Use code in description item, Based on http://tex.stackexchange.com/a/181325/77356
\newcommand*{\lstitem}[1]{
  \setbox0\hbox{\textbf{\Inline{#1}}}
  \item[\usebox0]
}

% %\lstset{aboveskip=5pt,belowskip=10pt}
% \lstset{captionpos=b,abovecaptionskip=1em}

% For long listings
\lstdefinestyle{LongCode}{
  %aboveskip=1ex,
  basicstyle=\small\ttfamily,
  % basicstyle=\scriptsize\ttfamily,
  % basicstyle=\tiny\ttfamily,
  %belowskip=1ex,
  breaklines=true,
  postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow}},
  breakautoindent=false,
  %breakatwhitespace=false,
  %columns=fullflexible,
  multicols=2,
  framerule=0pt,
  framexrightmargin=0em,
  framexleftmargin=0em,
  % numbers=left,
  % numberstyle=\footnotesize\sffamily,
  tabsize=2
}


% Env for short code: no label, no caption and "inlined" with a box
\lstnewenvironment{ShortCode}[1]
    {
      \lstset{
        language=#1,
        basicstyle=\small\ttfamily,
        frame=trBL % box the frame & double line on bottom and left side
      }
    }
    {
    }

% Env for longer code: label, caption and "floating" with a box
\lstnewenvironment{Code}[3]
    {
      \lstset{
        language=#1,
        basicstyle=\small\ttfamily,
        label={#2},
        caption=#3,
        captionpos=b, % bottom
        float=!h,     % "here"
        frame=trBL,   % box the frame & double line on bottom and left side
        % frameround=tttt
      }
    }
    {
      % DEBUG:
      % 1: #1 \\
      % 2: #2 \\
      % 3: #3
    }



% Tables
% \newcommand{\heading}[1]{\multicolumn{1}{c}{\textbf{#1}}}
% \newcommand{\vheading}[1]{\rotatebox[origin=c]{90}{~\textbf{#1}~}}


% To centre table too wide
% credit: http://tex.stackexchange.com/a/27099/77356
\makeatletter
\newcommand*{\centerfloat}{%
  \parindent \z@
  \leftskip \z@ \@plus 1fil \@minus \textwidth
  \rightskip\leftskip
  \parfillskip \z@skip}
\makeatother

% General styling
%\let\oldsection\section
%\renewcommand\section{\cleardoublepage\oldsection}

% For some reason page margin are swapped when having a title page with a
% different geometry. We fix that manually by 1) swapping the margin and
% 2) swapping the page number position (page style)
% credit: http://tex.stackexchange.com/a/36016/77356
\makeatletter
\newcommand*{\flipmargins}{%
  \clearpage
  \setlength{\@tempdima}{\oddsidemargin}%
  \setlength{\oddsidemargin}{\evensidemargin}%
  \setlength{\evensidemargin}{\@tempdima}%
  \if@reversemargin
    \normalmarginpar
  \else
    \reversemarginpar
  \fi
}
\makeatother

\newpagestyle{mystyle_no_header}{
  \setfoot[\thepage][][]{}{}{\thepage}
}

\newpagestyle{mystyle}{
  % \sethead[][][\firsttitlemarks\ifthesubsection{\thesubsection~\subsectiontitle}{\thesection~\sectiontitle}]{\firsttitlemarks\ifthesubsection{\thesubsection~\subsectiontitle}{\thesection~\sectiontitle}}{}{}
  \sethead[\thesection~\sectiontitle][][]{}{}{\thesection~\sectiontitle}
  % \setfoot[][][\thepage]{\thepage}{}{}
  \setfoot[\thepage][][]{}{}{\thepage}
}

% Additional macros
\newcommand{\TODO}[1]{\textcolor{YellowOrange}{(TODO: #1)}} % for inline TODO
% \newcommand{\TODO}[1]{\underline{(#1)}} % for inline TODO, PRINTING
\newcommand{\URL}[2]{#2:\xspace\href{#1}{#1}}
\newcommand{\RefSec}[1]{Section~\ref{#1}}
\newcommand{\RefTable}[1]{Table~\ref{#1}}
\newcommand{\RefApp}[1]{Appendix~\ref{#1}}
\newcommand{\RefFig}[1]{Figure~\ref{#1}}
\newcommand{\RefCode}[1]{Listing~\ref{#1}}
\newcommand{\BigO}[1]{\mathcal{O}(#1)}
\newcommand{\ActorRef}{\InlineS{ActorRef}\ }
\newcommand{\stt}[1]{\texttt{\small{#1}}}


%%%

\title{Verification of complex systems in Stainless}

\date{
  {\small Version 0.1}\\
  December 2017
}

\author{Romain Ruetschi}

\begin{document}

\newgeometry{centering}
\pagenumbering{gobble}
\maketitle

\vfill

\begin{abstract}

\TODO{Abstract}

\end{abstract}

\vfill

\begin{center}
    Master Thesis Project under the supervision of \\
    Prof. Viktor Kuncak \& Dr. Jad Hamza \\
    Lab for Automated Reasoning and Analysis LARA - EPFL
\end{center}

\begin{center}
    \includegraphics[width = 40mm]{res/epfl-logo}
\end{center}

\clearpage\null\newpage

\restoregeometry              %% restore the layout
\flipmargins
\pagestyle{mystyle_no_header}
\pagenumbering{arabic}

\tableofcontents
% \lstlistoflistings

\clearpage
\pagestyle{mystyle}

% ===========================================================================================
% ===========================================================================================

\section{Introduction}

\TODO{Introduction}

%\subsection*{Related Works}
%
%\TODO{Related Works}
%
%\section{Motivation}
%\label{motivation}
%
%
%\TODO{Motivation}
%

\clearpage

\section{Program Verification with Stainless}
\label{verif}

\TODO{Describe Stainless/Inox pipeline}


\clearpage
\section{Symbolic Evaluation of Inox Programs}
\label{symbolic}

\subsection{Motivation}

While one would expect the following program to successfully verify in a fair amount of time, Stainless is actually unable to automatically prove the verification condition corresponding to \stt{test}'s postcondition.

\begin{ShortCode}{PureScala}
def foldLeft[A](list: List[A], z: B)(f: (B, A) => B): B = list match {
  case Nil() => z
  case Cons(x, xs) => foldLeft(xs, f(z, x))(f)
}

def insert[A, B](values: List[(A, B)], map: Map[A, B]) = {
  foldLeft(xs, map) {
    case (acc, (k, v)) => acc.updated(k, v)
  }
}

def test(map: Map[String, Int]): Boolean = {
  val xs = List("a" -> 1, "b" -> 2, "c" -> 3, "d" -> 4)
  val res = insert(xs, map)
  res("b") == 2
}.holds
\end{ShortCode}

On the other hand, if one were to manually unfold \stt{insert}, then unfold \stt{foldLeft} as much as possible in the program above, one would end up with the following definition for the \stt{test} function, the postcondition of which would then promptly verify.

\begin{ShortCode}{PureScala}
def test(map: Map[String, Int]): Boolean = {
  val res = map.updated("a", 1).updated("b", 2).updated("c", 3).updated("d", 4)
  res("b") == 2
}.holds
\end{ShortCode}

Indeed, while the \stt{map} variable is kept abstract, the list of values \stt{xs} we want to insert is not, and it is thus possible to simplify the initial program, yielding to a much simpler verification condition.\\

It is of course unreasonable to ask users to manually perform such a transformation, especially with large programs, hence why we decided to investigate a way to do so automatically, as part of the verification pipeline.

\TODO{...}

Let's first take a look at how the \textit{PureScala} program above looks when expressed in Inox' input language:

\begin{ShortCode}{PureScala}
def foldLeft[A](list: List[A], z: B)(f: (B, A) => B): B =
  if (list.isInstanceOf[Nil[A]]) {
    z
  } else {
    val x  = list.asInstanceOf[Cons[A]].head
    val xs = list.asInstanceOf[Cons[A]].tail
    foldLeft(xs, f(z, x))(f)
  }
}

def insert[A, B](values: List[(A, B)], map: Map[A, B]) = {
  foldLeft(xs, map, (acc: Map[A, B], kv: (A, B)) => acc.updated(kv._1, kv._2))
}

def test(map: Map[String, Int]): Boolean = {
  val xs = List("a" -> 1, "b" -> 2, "c" -> 3, "d" -> 4)
  val res = insert(xs, map)
  res("b") == 2
}.holds
\end{ShortCode}

\subsection{Semantics}

The symbolic evaluator keeps track of the current \textit{path condition}, denoted by $\Delta$.   \RefFig{fig:symbolicsem} lists the evaluation rules for the symbolic evaluator. Since most of those are fairly straightforward, we will only focus on rules
(\ref{fig:symbolicsem:fi1}), (\ref{fig:symbolicsem:fi2}) and (\ref{fig:symbolicsem:fi3}), which pertain to functions invocations.

\begin{figure}[htb]
\begin{framed}
 
\begin{equation}
\dfrac{
  e \in \Delta
}{
  \lb{e}{\Delta} \longrightarrow \stt{true}
}
\end{equation}

\begin{equation}
\dfrac{
  \neg e \in \Delta
}{
  \lb{e}{\Delta} \longrightarrow \stt{false}
}
\end{equation}

\begin{equation}
\dfrac{
  \empty
}{
  \lb{\lambda x_1, \ldots, x_n.\, e}{\Delta} \longrightarrow \lambda \lb{x_1}{\Delta}, \ldots, \lb{x_n}{\Delta}.\, \lb{e}{\Delta}
}
\end{equation}

\begin{equation}
\dfrac{
  \empty
}{
  \lb{\stt{$l$ ==> $r$}}{\Delta} \longrightarrow \lb{\neg l \stt{ || } r}{\Delta}
}
\end{equation}

% TODO: Or/And

\begin{equation}
\dfrac{
  \lb{c}{\Delta} \longrightarrow \stt{true}
}{
  \lb{\stt{if ($c$) $t$ else $e$}}{\Delta} \longrightarrow \lb{t}{\Delta \cup c}
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{c}{\Delta} \longrightarrow \stt{false}
}{
  \lb{\stt{if ($c$) $t$ else $e$}}{\Delta} \longrightarrow \lb{e}{\Delta \cup c}
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{c}{\Delta} \longrightarrow c' \qquad
  \lb{t}{\Delta \cup c'} \longrightarrow t' \qquad
  \lb{e}{\Delta \cup \neg c'} \longrightarrow e' \qquad
  t' = e'
}{
  \lb{\stt{if ($c$) $t$ else $e$}}{\Delta} \longrightarrow t'
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{c}{\Delta} \longrightarrow c' \qquad
  \lb{t}{\Delta \cup c'} \longrightarrow t' \qquad
  \lb{e}{\Delta \cup \neg c'} \longrightarrow e' \qquad
  t' \not= e'
}{
  \lb{\stt{if ($c$) $t$ else $e$}}{\Delta} \longrightarrow \stt{if ($c'$) $t'$ else $e'$}
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{p}{\Delta} \longrightarrow \stt{true}
}{
  \lb{\stt{assume($p$, $e$)}}{\Delta} \longrightarrow \lb{e}{\Delta}
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{p}{\Delta} \longrightarrow \stt{false}
}{
  \lb{\stt{assume($p$, $e$)}}{\Delta} \longrightarrow
  \stt{assume(false, $\lb{e}{\Delta}$}
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{p}{\Delta} \longrightarrow p'
}{
  \lb{\stt{assume($p$, $e$)}}{\Delta} \longrightarrow
  \stt{assume($p'$, $\lb{e}{\Delta \cup p'}$)}
}
\end{equation}

\begin{equation}
\dfrac{
  \stt{T$_2$:\,ADTType} \qquad
  \neg \stt{isSort(T$_2$)}
}{
  \lb{\stt{C(T$_1$, $a_1, \ldots, a_n$).isInstanceOf[T$_2$]}}{\Delta}
  \longrightarrow \stt{T$_1$.id == T$_2$.id}
}
\end{equation}

\begin{equation}
\dfrac{
  \stt{T:\,ADTType} \qquad
  \stt{isSort(T)}
}{
  \lb{\stt{$e$.isInstanceOf[T]}}{\Delta} \longrightarrow \stt{true}
}
\end{equation}

\begin{equation}
\dfrac{
  \stt{T:\,ADTType} \qquad
  \lb{e}{\Delta} \longrightarrow e' \qquad
  \stt{isInstanceOf(e', T, $\Delta$) == Some($b$)}
}{
  \lb{\stt{$e$.isInstanceOf[T]}}{\Delta} \longrightarrow b
}
\end{equation}

\begin{equation}
\dfrac{
  \stt{T:\,ADTType} \qquad
  \lb{e}{\Delta} \longrightarrow e' \qquad
  \stt{isInstanceOf($e'$, T, $\Delta$) == None}
}{
  \lb{\stt{$e$.isInstanceOf[T]}}{\Delta} \longrightarrow \stt{$e'$.isInstanceOf[T]}
}
\end{equation}

\begin{equation}
\dfrac{
  \stt{T:\,ADTType}
}{
  \lb{\stt{$e$.asInstanceOf[T]}}{\Delta} \longrightarrow \stt{$\lb{e}{\Delta}$.asInstanceOf[T]}
}
\end{equation}

\end{framed}
\vspace{-10pt}
\caption{Operational semantics of the symbolic evaluator \label{fig:symbolicsem}}
\end{figure}

%------------------------------------------------------------------------

\begin{figure}[htb]\ContinuedFloat
\centering
%\begin{adjustwidth}{-1mm}{-1cm}
\begin{framed}

\begin{equation}
\dfrac{
  \text{\TODO{This is overly simplistic}}
}{
  \lb{\stt{let x:\,T = $v$ in $e$}}{\Delta} \longrightarrow
  \lb{e[\stt{x}/\stt{$v$}]}{\Delta}
}
\end{equation}

%\begin{equation}
%\dfrac{
%  e = \stt{let x:\,T = if ($c_1$) $t_1$ else $e_1$ in if ($c_2$) $t_2$ else $e_2$}
%  \qquad c_ 1 = c_2
%}{
%  \lb{e}{\Delta} \longrightarrow
%  \lb{\stt{if ($c_1$) let x:\,T = $t_1$ in $t_2$ else let x:\,T = $e_1$ in $e_2$}}{\Delta}
%}
%\end{equation}

% TODO: Equals

\begin{equation}
\dfrac{
  \empty
}{
  \lb{\neg\, e}{\Delta} \longrightarrow \neg\,\lb{e}{\Delta}
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{f}{\Delta} \longrightarrow \lambda \stt{x$_1$:\,T$_1$,\ldots,x$_n$:\,T$_n$.\,$b$}
  \qquad
  \lb{e_i}{\Delta} \longrightarrow \lb{e_i'}{\Delta},\, i \in \{1 \ldots n\}
}{
  \lb{f(e_1,\ldots,e_n)}{\Delta} \longrightarrow
  \lb{b[\stt{x}_1/e_1',\ldots,\stt{x}_n/e_n']}{\Delta}
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{f}{\Delta} \longrightarrow f' \qquad
  \lb{e_i}{\Delta} \longrightarrow \lb{e_i'}{\Delta},\, i \in \{1 \ldots n\}
}{
  \lb{f(e_1,\ldots,e_n)}{\Delta} \longrightarrow
  f'(e_1', \ldots, e_n')
}
\end{equation}

% TODO: Application(Assume)?

\begin{equation}
\dfrac{
 \neg\,\stt{isRecursive(id)} \quad
 \stt{id.params} = \langle \stt{x}_1, \ldots, \stt{x}_n \rangle \quad
 \lb{e_i}{\Delta} \longrightarrow \lb{e_i'}{\Delta},\, i \in \{1 \ldots n\}
}{
  \lb{\stt{id}(e_1,\ldots,e_n)}{\Delta} \longrightarrow
  \lb{\stt{id.body}[\stt{x}_1/e_1',\ldots,\stt{x}_n/e_n']}{\Delta}
}
\label{fig:symbolicsem:fi1}
\end{equation}

\begin{equation}
\dfrac{
 \stt{id.body} \Downarrow \Delta \uplus \{\,\stt{x}_i \mapsto e_i'\,|\, 1 \leq i \leq n\,\}
 \quad
 \stt{id.params} = \langle \stt{x}_1, \ldots, \stt{x}_n \rangle
 \quad
 \lb{e_i}{\Delta} \longrightarrow \lb{e_i'}{\Delta},\  i \in \{1 \ldots n\}
}{
  \lb{\stt{id}(e_1,\ldots,e_n)}{\Delta} \longrightarrow
  \lb{\stt{id.body}[\stt{x}_1/e_1',\ldots,\stt{x}_n/e_n']}{\Delta}
}
\label{fig:symbolicsem:fi2}
\end{equation}

\begin{equation}
\dfrac{
 \lb{e_i}{\Delta} \longrightarrow \lb{e_i'}{\Delta},\, i \in \{1 \ldots n\}
}{
  \lb{\stt{id}(e_1,\ldots,e_n)}{\Delta} \longrightarrow
  \stt{id}(e_1',\ldots,e_n')
}
\label{fig:symbolicsem:fi3}
\end{equation}

\end{framed}
\vspace{-10pt}
\caption{Operational semantics of the symbolic evaluator \label{fig:symbolicsem}}
\end{figure}

\subsection{Case Studies}

\TODO{Case Studies}

\subsection{Conclusion}

\TODO{Conclusion}

%------------------------------------------------------------------------

\clearpage
\section{Verifiying Actor Systems}
\label{actors}

\subsection{Motivation}

\TODO{Motivation}

\subsection{The Actor Model}

\TODO{Actor Model}

\subsection{Our Framework}

\subsubsection*{Message}

In our framework, messages are modelled as constructors of the \InlineS{Msg} abstract class.

\begin{ShortCode}{PureScala}
abstract class Msg
case class Hello(name: String) extends Msg
\end{ShortCode}

\vspace{-15pt}
\subsubsection*{Actor Reference}

Each actor is associated with a unique and persistent reference, modelled as an instance of the \ActorRef abstract class.

\begin{ShortCode}{PureScala}
abstract class ActorRef
case class Primary() extends ActorRef
\end{ShortCode}

\vspace{-15pt}
\subsubsection*{In-flight Messages}

In-flight messages are represented as a product of the \ActorRef of the destination actor, and the message itself.

\begin{ShortCode}{PureScala}
case class Packet(dest: ActorRef, payload: Msg)
\end{ShortCode}

\vspace{-15pt}
\subsubsection*{Actor Context}

When a message is delivered to an actor, the latter is provided with a context,
which holds a reference to itself, and a mutable list of \InlineS{Packet}s to send.

\begin{ShortCode}{PureScala}
case class ActorContext(
  self: ActorRef,
  var toSend: List[Packet]
)
\end{ShortCode}

\vspace{-15pt}
\subsubsection*{Behavior}

A behavior specifies both the current state of an actor, and how this one should 
process the next incoming message. In our framework, these are modelled as a subclass 
of the abstract class \InlineS{Behavior}, which defines a single abstract method 
\InlineS{processMsg}, to be overriden for each defined behavior.

Using the provided \InlineS{ActorContext}, the implementation of the \InlineS{processMsg}
method can both access its own reference, and register messages to be sent after the
execution of the method is complete. It is also required to return a new \InlineS{Behavior}

\begin{ShortCode}{PureScala}
abstract class Behavior {
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior
}
\end{ShortCode}

%\subsubsection*{Transition}
%
%Whenever a message is processed, we record the transition between the previous 
%state of the system and the one after the message has been been processed. We keep 
%track of this information as an instance of the \InlineS{Transition} class, which 
%holds: the \InlineS{Msg} that has been delivered, its sender and receiver, the new 
%behavior of the destination actor, and the list of \InlineS{Packet}s the destination 
%actor wants to send.
%
%\begin{ShortCode}{PureScala}
%case class Transition(
%  from: ActorRef,
%  to: ActorRef,
%  msg: Msg,
%  newBehavior: Behavior,
%  toSend: List[Packet]
%)
%\end{ShortCode}

\vspace{-15pt}
\subsubsection*{Actor System}

The state of the Actor system at a given point in time is modelled as a case class, 
holding the behavior associated with each actor reference, and the list of in-flight messages between any two actors.

% as well as a trace of the execution up to that point, modelled as a list of \InlineS{Transition}s.

\begin{ShortCode}{PureScala}
case class ActorSystem(
  behaviors: CMap[ActorRef, Behavior],
  inboxes: CMap[(ActorRef, ActorRef), List[Msg]]
)
\end{ShortCode}
% trace: List[Transition]

The \InlineS{ActorSystem} class is equipped with a \InlineS{step} method, which takes 
a pair of \ActorRef as arguments, and is in charge of delivering the oldest message 
found in the corresponding inbox, and which returns the new state of the system after 
the aforementioned message has been processed.

\begin{ShortCode}{PureScala}
def step(from: ActorRef, to: ActorRef): ActorSystem
\end{ShortCode}

\subsection{Operational Semantics}
\label{semantics}

We formulate the small-step operational semantics of our Actor model in 
\RefFig{fig:opsem}, where $s: \stt{ActorSystem}$ is an Actor system,
$m: \stt{Msg}$ is a message,
$n, n_{to}, n_{from}: \stt{ActorRef}$ are references,
$b, b': \stt{Behavior}$ are behaviors,
$ps: \stt{List[Packet]}$ a list of packets to send,
% $t: \stt{Transition}$ is a transition,
$c: \stt{ActorContext}$ is a context,
and $\emptyset_n: \stt{ActorContext}$ is the empty context for an actor whose
self-reference is $n$, defined as $\emptyset_n := \stt{ActorContext}(n, \stt{Nil})$.

\begin{figure}[!h]
\begin{framed}
 
\begin{equation}
\dfrac{
  \not\exists m \in \stt{$s$.inboxes}(n_{from}, n_{to})
}{
  \langle \stt{$s$.step}(n_{from}, n_{to}) \rangle \longrightarrow \stt{s}
}
\tag{STEP-NOMSG}
\end{equation}

\vspace{10pt}
\begin{equation}
\dfrac{
  \exists m \in \stt{$s$.inboxes}(n_{from}, n_{to}) \qquad
  \langle \stt{$s$.deliverMsg}(n_{to}, n_{from}, m) \rangle \Rightarrow (b, ps, t)
}{
  \langle \stt{$s$.step}(n_{from}, n_{to}) \rangle \longrightarrow s \uplus (n_{to} \mapsto b, \ldots, t)
}
\tag{STEP}
\end{equation}

\vspace{10pt}
\begin{equation}
\dfrac{
  \langle \stt{$s$.behaviors($n_{to}$).processMsg}(m, \emptyset_{n_{to}}) \rangle \longrightarrow (b, c) 
}{
   \langle \stt{$s$.deliverMsg}(n_{to}, n_{from}, m) \rangle \longrightarrow (b, \stt{$c$.toSend}, t)
}
\tag{DELIVER-MSG}
\end{equation}

\vspace{10pt}
\begin{equation}
\dfrac{
  \stt{$b$.processMsg}(m, \emptyset_{n_{to}}) = [i_1, \ldots, i_n, b'] \qquad
  \emptyset_{n_{to}} \vdash \langle [i_1, \ldots, i_n] \rangle \Rightarrow c
}{
   \langle \stt{$b$.processMsg}(m, \emptyset_{n_{to}}) \rangle \longrightarrow (b', c)
}
\tag{PROCESS-MSG}
\end{equation}

\vspace{10pt}
\begin{equation}
\dfrac{\empty}{
   \langle \stt{Nil}, c \rangle \Rightarrow c
}
\tag{I-NIL}
\end{equation}

\vspace{10pt}
\begin{equation}
\dfrac{
  \langle i, c \rangle \Rightarrow c'
}{
  \langle \stt{$i$ :: $is$}, c \rangle \Rightarrow \langle is, c' \rangle
}
\tag{I-CONS}
\end{equation}

\vspace{10pt}
\begin{equation}
\dfrac{\empty}{
   \langle n\ \stt{!}\ m, c \rangle \Rightarrow (b',\ \stt{$c$.copy(toSend $\mapsto$ ($n, m$) :: $c$.toSend)})
}
\tag{I-SEND}
\end{equation}

\end{framed}
\vspace{-10pt}
\caption{Operational semantics\label{fig:opsem}}
\end{figure}

\subsection{Proving Invariants}
\label{invariants}

After having defined an Actor system with our framework, one might want to verify that this 
system preserves some invariant between each step of its execution. That is to say, 
for an \InlineS{ActorSystem} $s$, any two \ActorRef $n, m$,
and an invariant \InlineS{inv: ActorSystem $\ \to\ $ Boolean}, if $\texttt{inv}(s)$ holds, 
then $\texttt{inv}(s\texttt{.step}(n, m))$ should hold as well. We express this 
property more formally in \RefFig{fig:stepinvariant}. This property can be easily expressed in PureScala, as shown in \RefCode{lst:preserveInv}.

\begin{figure}[!h]
$$\forall s: \stt{ActorSystem},\, n: \stt{ActorRef},\, m: \stt{ActorRef}.\ \stt{inv($s$)} \implies \stt{inv($s$.step($n, m$))}$$
\vspace{-20pt}
\caption{Invariant preservation property\label{fig:stepinvariant}}
\end{figure}

\begin{Code}{PureScala}{lst:preserveInv}{Invariant preservation theorem in PureScala}
def inv(s: ActorSystem): Boolean = {
  /* ... */
}

def preserveInv(s: ActorSystem, n: ActorRef, m: ActorRef): Boolean = {
  require(inv(s))
  inv(s.step(n, m))
} holds
\end{Code}

When encoutering such a definition, Stainless will generate a verification condition 
equivalent to \RefFig{fig:stepinvariant}, which will then be discharged to Inox and the underlying SMT solver.

%\subsection{Reasoning About Traces}
%\label{traces}
%
%\TODO{Traces}

\subsection{Case studies}
\label{casestudies}

\subsubsection*{Replicated Counter 1}
\label{repcounterinc}

As a first and very simple case study, we will study an Actor system which models a
replicated counter, which can only be incremented by one unit. This system is 
composed of two actors, a primary counter whose reference is \stt{Primary()},
and a backup counter whose reference is \stt{Backup()}.
Each of these reference is associated with a behavior: the primary counter reference with
an instance of \stt{PrimaryB}, and the backup counter reference with an instance 
of \stt{BackupB}, both of which hold a positive integer, representing the value of the
counter. Whenever the primary actor receives a message \stt{Inc()}, it forwards that
message to the backup actor, and returns a new instance of \stt{PrimaryB} with the
counter incremented by one. When the backup actor receives an \stt{Inc()} message,
it just returns a new instance of \stt{BackupB} with the counter incremented by one. 
The corresponding PureScala implementation can be found
in \RefCode{lst:ReplicatedCounterInc}.

\begin{Code}{PureScala}{lst:ReplicatedCounterInc}{Replicated counter implementation (increment)}
case class Primary() extends ActorRef
case class Backup()  extends ActorRef

case class Inc() extends Msg

case class PrimaryB(counter: BigInt) extends Behavior {
  require(counter >= 0)

  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case Inc() =>
      Backup() ! Inc()
      PrimaryB(counter + 1)
  }
}

case class BackupB(counter: BigInt) extends Behavior {
  require(counter >= 0)

  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case Inc() => BackupB(counter + 1)
  }
}
\end{Code}

Given such a system, one might want to prove that the following invariant is 
preserved between each step of its execution:

\begin{Code}{PureScala}{lst:repcounterincinv}{Replicated counter invariant (increment)}
def invariant(s: ActorSystem): Boolean = {
  s.inboxes((Backup(), Backup())).isEmpty && {
    (s.behaviors(Primary()), s.behaviors(Backup())) match {
      case (PrimaryB(p), BackupB(b)) =>
        p.value == b.value + s.inboxes(Primary() -> Backup()).length
      case _ => false
    }
  }
}
\end{Code}

This invariant specifies that the \stt{Backup()} actor does not send itself any messages, that both actors have the proper corresponding behavior, and that, last but not least, the value of the primary counter is equal to the value of the backup counter added to the number of messages that are yet to be delivered to the backup actor.\\

We can now define the actual theorem we want Stainless to prove for us:

\begin{Code}{PureScala}{lst:repcounterincthm}{Replicated counter theorem (increment)}
def preserveInv(s: ActorSystem, n: ActorRef, m: ActorRef): Boolean = {
  require(invariant(s))
  invariant(s.step(n, m))
} holds
\end{Code}

\TODO{Rep Counter Inc Result}

\subsubsection*{Replicated Counter 2}

\RefCode{lst:ReplicatedCounterDel} shows a variant of the previous case study, where instead of having the primary actor forward the \stt{Inc()} message to the backup actor, it instead delivers it with its new value.

\begin{Code}{PureScala}{lst:ReplicatedCounterDel}{Replicated counter implementation (deliver)}
case class Primary() extends ActorRef
case class Backup()  extends ActorRef

case class Inc() extends Msg
case class Deliver(c: BigInt) extends Msg

case class PrimaryB(counter: BigInt) extends Behavior {
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case Inc() =>
      Backup() ! Deliver(counter + 1)
      PrimaryB(counter + 1)

    case _ => Behavior.same
  }
}

case class BackupB(counter: BigInt) extends Behavior {
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case Deliver(c) => BackupB(c)
    case _          => Behavior.same
  }
}
\end{Code}

The invariant now reads slightly differently, as can be seen in \RefCode{lst:ReplicatedCounterDelInv}, and can no longer be proven automatically by Stainless on its own. \RefCode{lst:ReplicatedCounterDel} shows the full proof.

\begin{Code}{PureScala}{lst:ReplicatedCounterDelInv}{Replicated counter implementation (deliver)}
def invariant(s: ActorSystem): Boolean = {
  validBehaviors(s)                           &&
  noMsgsToSelf(Primary()).isEmpty             &&
  noMsgsToSelf(Backup()).isEmpty              &&
  noMsgsToSelf(Backup() -> Primary()).isEmpty && {
    val PrimBehav(p) = s.behaviors(Primary())
    val BackBehav(b) = s.behaviors(Backup())
    val bInbox       = s.inboxes(Primary() -> Backup())

    p.value >= b.value && isSorted(bInbox) && bInbox.forall {
      case Deliver(Counter(i)) => p.value >= i
      case _                   => true
    }
  }
}
\end{Code}

\TODO{Rep Counter Del Result}

%\subsubsection*{Lock Service}
%
%\RefCode{lst:LockService} shows the implementation of a lock service using our framework. In this case study, an actor acts as a server holding a lock on some resource, while a number of other actors (the "agents") act as clients of the lock service, each potentially trying to acquire the lock on the resource. To model a variable number of actors with the same implementation, we define their reference as a case class parametrized by a \TODO{unique} identifier.
%
%\begin{Code}{PureScala}{lst:LockService}{Lock service implementation}
%TODO
%\end{Code}
%
%An obvious property we might want to prove is that, at any time, at most one of those agents thinks that it holds the lock. Additionally, we'd like to ensure that such an agent is actually the same one that the server granted the lock too. We express this property in \RefCode{lst:LockServiceInv}.
%
%\begin{Code}{PureScala}{lst:LockServiceInv}{Lock service invariant}
%def validBehaviors(s: ActorSystem): Boolean = {
%  s.behaviors(Server()).isInstanceOf[ServerB] &&
%  forall { (a: Agent) =>
%  	s.behaviors(a).isInstanceOf[AgentB]
%  }
%}
%
%def noMsgstoSelf(s: ActorSystem): Boolean = forall { (ref: ActorRef) =>
%  s.inboxes(ref -> ref).isEmpty
%}
%
%def hasLock(s: ActorSystem, a: ActorRef): Boolean = {
%  s.behaviors(a) match {
%    case AgentB(hasLock) => hasLock
%    case _ => false
%  }
%}
%
%def mutex(s: ActorSystem): Boolean = forall { (a: ActorRef, b: ActorRef) =>
%  (a != b) ==> !(hasLock(s, a) && hasLock(s, b))
%}
%
%def hasLockThenHead(s: ActorSystem): Boolean = forall { (ref: ActorRef) =>
%  hasLock(s, ref) ==> {
%    s.behaviors(Server()) match {
%      case ServerB(Cons(head, _)) => head == ref
%      case _ => false
%    }
%  }
%}
%
%def invariant(s: ActorSystem): Boolean = {
%  validBehaviors(s)  &&
%  noMsgstoSelf(s)    &&
%  mutex(s)           &&
%  hasLockThenHead(s)
%}
%\end{Code}
%
%\TODO{Lock service results}

%\subsubsection*{Leader Election}
%
%\TODO{Leader election}

%\subsubsection*{Key-value store}
%
%\TODO{KV store}

\subsection{Spawning Actors}
\label{spawn}

\TODO{Name uniqueness}

Up until now, our framework has only been able to model Actor systems with a static topology, ie. systems where no new actors besides the ones that are statically defined can be spawned. Let's now attempt to enrich our model to account for dynamic topologies.

To this end, we modify the \ActorRef definition to include both a name and an optional field holding a reference to its parent \ActorRef if any. We also add a new constructor of the \ActorRef data type, which will be assigned to actors spawned from another actor.

\begin{ShortCode}{PureScala}
abstract class ActorRef(
  name: String,
  parent: Option[ActorRef]
)

case class Child(name: String, getParent: ActorRef)
  extends ActorRef(name, Some(getParent))
\end{ShortCode}

In order for actors to spawn other actors, by specifying their name and associated 
initial behavior, we modify the \stt{ActorContext} class as follows:

\begin{ShortCode}{PureScala}
case class ActorContext(
  self: ActorRef,
  var toSend: List[Packet],
  var toSpawn: List[(ActorRef, Behavior)]
) {
  def spawn(behavior: Behavior, name: String): ActorRef = {
    val id: ActorRef = Child(name, self)
    toSpawn = toSpawn :+ (id, behavior)
    id
  }
  /* ... */
}
\end{ShortCode}

As can be seen in the listing above, the context now keeps track of the names and 
behaviors of the actors to be spawned, and provides a \stt{spawn} method which is in 
charge of constructing the \ActorRef of the spawned actor, storing it along with the 
behavior within the context, and returning the newly generated reference.

Let's now update the case study in \RefCode{lst:ReplicatedCounterInc} to accommodate 
these changes, while noting that we are not making use of this new feature yet. Only 
the two \ActorRef definitions need to be touched, becoming:

\begin{ShortCode}{PureScala}
case class Primary() extends ActorRef("primary", None())
case class Backup()  extends ActorRef("backup", None())
\end{ShortCode}

Unfortunately, when we now feed the updated benchmark to Stainless, the latter is be 
unable to prove the very same theorem it previously had no issue whatsoever with.
All is not lost though, as turning on the symbolic evaluator described in
\RefSec{symbolic} enables Stainless to verify the program in less than 10 seconds.

\RefCode{lst:spawncode} defines a simple system with a dynamic topology, where one actor, deemed \stt{Primary}, waits for a \stt{Spawn} message to spawn a child actor, and change its behavior from \stt{BeforeB} to \stt{AfterB} in order to keep track of the reference to the child. The invariant we would to verify holds here, states that, if the \stt{Primary} actor has behavior \stt{BeforeB()}, then the behavior associated with the \ActorRef of its child actor must be \stt{Stopped}. On the other hand, if the \stt{Primary} actor has behavior \stt{AfterB(child)}, then the behavior associated with \stt{child} must be \stt{ChildB}. This test case verifies promptly, provided the symbolic evaluator is enabled.

\begin{Code}{PureScala}{lst:spawncode}{}
case object Primary extends ActorRef("primary")
case object Spawn extends Msg

case class BeforeB() extends Behavior {
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case Spawn =>
      val child = ctx.spawn(ChildB(), "child")
      AfterB(child)
  }
}

case class AfterB(child: ActorRef) extends Behavior {
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case _ => Behavior.same
  }
}

case class ChildB() extends Behavior {
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case _ => Behavior.same
  }
}

def invariant(s: ActorSystem): Boolean = {
  s.behaviors(Primary) match {
    case BeforeB() =>
      s.isStopped(Child("child", Primary()))
    case AfterB(child) =>
      s.behaviors(child) == ChildB()

    case _ => false
  }
}

def theorem(s: ActorSystem, from: ActorRef, to: ActorRef): Boolean = {
  require(invariant(s))
  invariant(s.step(from, to))
} holds
\end{Code}

\subsection{Executing an Actor System with Akka}
\label{akka}

While the verification of Actor systems is in itself an interesting endeavour, it is not of much use unless one is able to run these systems, potentially in a distributed environment. In the Scala ecosystem, the most widely used real-world Actor system is Akka \TODO{REF}. \RefCode{lst:akkashim} shows a shallow shim which allows to run an Actor system developed with our framework within Akka, with only a few alterations to the original program.

\begin{Code}{PureScala}{lst:akkashim}{Akka shim for our Actor system framework}
import akka.actor

type ActorRef = actor.ActorRef

case class ActorContext(self: actor.ActorRef, ctx: actor.ActorContext)

class Wrapper(var behavior: Behavior)
  extends actor.Actor with actor.ActorLogging {

  implicit val ctx = ActorContext(self, context)

  def receive = {
    case msg: Msg =>
      log.info(s"$\$${behavior}: $\$${msg}")
      behavior = behavior.processMsg(msg)

    case _ => ()
  }
}

abstract class ActorSystem(val name: String) {
  lazy val system = actor.ActorSystem(name)

  def spawn(behavior: Behavior, name: String): actor.ActorRef = {
    system.actorOf(actor.Props(new Wrapper(behavior)), name = name)
  }

  def run(): Unit
}
\end{Code}

\TODO{Explain shim}

To this end, one must define a subclass of \stt{ActorSystem}, and provide an implementation of its \stt{run} method. Within this method, one can spawn new top-level actors, get a reference to those, and send them messages. \RefCode{lst:akkashimex} shows such an implementation for the replicated counter described in \RefSec{repcounterinc}. 

\begin{Code}{PureScala}{lst:akkashimex}{Akka shim for our Actor system framework}
@extern
object System extends ActorSystem("rep-counter-sys") {
  def run(): Unit = {
    val backup  = spawn(BackupB(0), "backup")
    val primary = spawn(PrimaryB(0, backup), "primary")

    primary ! Inc()
  }
}

@extern
def main(args: Array[String]): Unit = {
  System.run()
}
\end{Code}

%\clearpage
%\section{Strong Eventual Consistency with CRDTs}
%\label{crdt}
%
%\subsection{Motivation}
%
%Because both faults and network partitions are a common occurrence in distributed systems, these often make use of data replication in order to improve reliability \TODO{citation}, which itself can lead to  consistency issues. One increasingly popular way to mitigate this problem is to model the replicated data using \textit{Conflict-free Replicated Data Types} (CRDTs) \cite{crdt} \cite{crdtstudy}. These data types come in two flavours: \textit{Commutative Replicated Data Types} (CmRDTs, or \textit{Op-based CRDTs}) and \textit{Commutative Replicated Data Types} (CvRDTs, or \textit{State-based CDRTs}).
%
%\TODO{Explain eventual consistency + both models + choice of CvRDTs}
%
%\subsection{Proving the CRDT Laws with Stainless}
%
%\subsection{Conclusion}
%
%\TODO{Conclusion}

\clearpage
\section{Biparty Communication Protocols}
\label{biparty}

\subsection{Motivation}

\TODO{Motivation}

\subsection{Session Types}

\TODO{Introduce sessions types + discuss the most common encoding and why it does not work in PureScala}

\subsection{Session Types Encoding as ADTs}

\TODO{Discuss the \textit{lchannels} \cite{lchannels} encoding and its limitations in std Scala}

\subsection{Linear Types in PureScala}

\begin{Code}{PureScala}{lst:sessions}{Sessions library in PureScala}
package stainless

import stainless.lang._
import stainless.annotation._

package object linear {

  @ignore
  class Linear[+A](_value: A) {
    def ! = _value
  }

  @ignore
  implicit def delinearize[A](lin: Linear[A]): A = lin!

  @ignore
  implicit def linearize[A](value: A): Linear[A] = new Linear(value)

}
\end{Code}

\subsection{Sessions Library}

\begin{Code}{PureScala}{lst:sessions}{Sessions library in PureScala}
type LIn[A]  = Linear[In[A]]
type LOut[A] = Linear[Out[A]]

@linear
@library
class In[A] {

  @extern
  def receive(implicit d: Duration): Linear[A] = {
    ???
  }

  def ?[B](f: Linear[A] => B)(implicit d: Duration): B = {
    f(receive)
  }
}

@linear
@library
class Out[A] {

  @extern
  def send(msg: A): Unit = {
    ???
  }

  def !(msg: A): Unit = {
    send(msg)
  }

  @extern
  def !![B](h: LOut[B] => A): LIn[B] = {
    ???
  }

  @extern
  def create[B](): (LIn[B], LOut[B]) = {
    ???
  }
}
\end{Code}

\subsection{Case Studies}

\subsubsection*{ATM Protocol}

\begin{Code}{PureScala}{lst:atm_desc}{ATM protocol description}
//Authentication request from the user
case class Authenticate(card: String, pin: String, cont: LOut[Response])

// Authentication response from the ATM
sealed abstract class Response
case class Failure()                 extends Response
case class Success(cont: LOut[Menu]) extends Response

// Choices available to authenticated user
sealed abstract class Menu
case class CheckBalance(cont: LOut[Balance]) extends Menu
case class Quit()                            extends Menu

// User account balance
case class Balance(amount: BigInt)
\end{Code}

\begin{Code}{PureScala}{lst:atm_impl}{ATM protocol implemenation}
def atm(c: LIn[Authenticate]) = {
  c ? { auth => auth! match {
    case Authenticate(card, pin, cont) if !authenticated(card, pin) =>
      cont ! Failure()

    case Authenticate(_, pin, cont) =>
      (cont !! (Success(_: LOut[Menu]))) ? menu
  } }
}

def menu(menu: Linear[Menu]) = {
  menu! match {
    case CheckBalance(cont) =>
      cont ! Balance(42)

    case Quit() => ()
  }
}

@extern
def authenticated(card: String, pin: String): Boolean = {
  /* ... */
}
\end{Code}

\subsubsection*{TLS 1.2 Handshake}

\TODO{TLS 1.2 Handshake}

\subsection{Conclusion}

\clearpage
\section{Conclusion}
\label{conclusion}

\TODO{Conclusion}

\section{Future Work}
\label{futurework}

\TODO{Future Work}

\appendix

\clearpage

\nocite{*}
\bibliographystyle{ieeetr}
\bibliography{report}

\end{document}
