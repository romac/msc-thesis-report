\include{header}

\clearpage
\pagestyle{mystyle}

\section{Introduction}

\TODO{Introduction}

%\subsection*{Related Works}
%
%\TODO{Related Works}
%
%\section{Motivation}
%\label{motivation}
%
%
%\TODO{Motivation}
%

\clearpage

\section{Partial Evaluation of Inox Programs}
\label{partial}

\TODO{Describe Stainless and Inox pipeline}

We now describe a partial evaluation algorithm for Inox programs.

\begin{figure}[htb]
\begin{framed}
 
\begin{equation}
\dfrac{
  e \in \Delta
}{
  \lb{e}{\Delta} \longrightarrow \stt{true}
}
\end{equation}

\begin{equation}
\dfrac{
  \neg e \in \Delta
}{
  \lb{e}{\Delta} \longrightarrow \stt{false}
}
\end{equation}

\begin{equation}
\dfrac{
  \empty
}{
  \lb{\lambda x_1, \ldots, x_n.\, e}{\Delta} \longrightarrow \lambda \lb{x_1}{\Delta}, \ldots, \lb{x_n}{\Delta}.\, \lb{e}{\Delta}
}
\end{equation}

\begin{equation}
\dfrac{
  \empty
}{
  \lb{\stt{$l$ ==> $r$}}{\Delta} \longrightarrow \lb{\neg l \stt{ || } r}{\Delta}
}
\end{equation}

% TODO: Or/And

\begin{equation}
\dfrac{
  \lb{c}{\Delta} \longrightarrow \stt{true}
}{
  \lb{\stt{if ($c$) $t$ else $e$}}{\Delta} \longrightarrow \lb{t}{\Delta \cup c}
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{c}{\Delta} \longrightarrow \stt{false}
}{
  \lb{\stt{if ($c$) $t$ else $e$}}{\Delta} \longrightarrow \lb{e}{\Delta \cup c}
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{c}{\Delta} \longrightarrow c' \qquad
  \lb{t}{\Delta \cup c'} \longrightarrow t' \qquad
  \lb{e}{\Delta \cup \neg c'} \longrightarrow e' \qquad
  t' = e'
}{
  \lb{\stt{if ($c$) $t$ else $e$}}{\Delta} \longrightarrow t'
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{c}{\Delta} \longrightarrow c' \qquad
  \lb{t}{\Delta \cup c'} \longrightarrow t' \qquad
  \lb{e}{\Delta \cup \neg c'} \longrightarrow e' \qquad
  t' \not= e'
}{
  \lb{\stt{if ($c$) $t$ else $e$}}{\Delta} \longrightarrow \stt{if ($c'$) $t'$ else $e'$}
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{p}{\Delta} \longrightarrow \stt{true}
}{
  \lb{\stt{assume($p$, $e$)}}{\Delta} \longrightarrow \lb{e}{\Delta}
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{p}{\Delta} \longrightarrow \stt{false}
}{
  \lb{\stt{assume($p$, $e$)}}{\Delta} \longrightarrow
  \stt{assume(false, $\lb{e}{\Delta}$}
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{p}{\Delta} \longrightarrow p'
}{
  \lb{\stt{assume($p$, $e$)}}{\Delta} \longrightarrow
  \stt{assume($p'$, $\lb{e}{\Delta \cup p'}$)}
}
\end{equation}

\begin{equation}
\dfrac{
  \stt{T$_2$:\,ADTType} \qquad
  \neg \stt{isSort(T$_2$)}
}{
  \lb{\stt{C(T$_1$, $a_1, \ldots, a_n$).isInstanceOf[T$_2$]}}{\Delta}
  \longrightarrow \stt{T$_1$.id == T$_2$.id}
}
\end{equation}

\begin{equation}
\dfrac{
  \stt{T:\,ADTType} \qquad
  \stt{isSort(T)}
}{
  \lb{\stt{$e$.isInstanceOf[T]}}{\Delta} \longrightarrow \stt{true}
}
\end{equation}

\begin{equation}
\dfrac{
  \stt{T:\,ADTType} \qquad
  \lb{e}{\Delta} \longrightarrow e' \qquad
  \stt{isInstanceOf(e', T, $\Delta$) == Some($b$)}
}{
  \lb{\stt{$e$.isInstanceOf[T]}}{\Delta} \longrightarrow b
}
\end{equation}

\begin{equation}
\dfrac{
  \stt{T:\,ADTType} \qquad
  \lb{e}{\Delta} \longrightarrow e' \qquad
  \stt{isInstanceOf($e'$, T, $\Delta$) == None}
}{
  \lb{\stt{$e$.isInstanceOf[T]}}{\Delta} \longrightarrow \stt{$e'$.isInstanceOf[T]}
}
\end{equation}

\begin{equation}
\dfrac{
  \stt{T:\,ADTType}
}{
  \lb{\stt{$e$.asInstanceOf[T]}}{\Delta} \longrightarrow \stt{$\lb{e}{\Delta}$.asInstanceOf[T]}
}
\end{equation}

\end{framed}
\vspace{-10pt}
\caption{Operational semantics of the partial evaluator \label{fig:partialsem}}
\end{figure}

%------------------------------------------------------------------------

\begin{figure}[htb]\ContinuedFloat
\centering
%\begin{adjustwidth}{-1mm}{-1cm}
\begin{framed}

\begin{equation}
\dfrac{
  \text{\TODO{This is overly simplistic}}
}{
  \lb{\stt{let x:\,T = $v$ in $e$}}{\Delta} \longrightarrow
  \lb{e[\stt{x}/\stt{$v$}]}{\Delta}
}
\end{equation}

%\begin{equation}
%\dfrac{
%  e = \stt{let x:\,T = if ($c_1$) $t_1$ else $e_1$ in if ($c_2$) $t_2$ else $e_2$}
%  \qquad c_ 1 = c_2
%}{
%  \lb{e}{\Delta} \longrightarrow
%  \lb{\stt{if ($c_1$) let x:\,T = $t_1$ in $t_2$ else let x:\,T = $e_1$ in $e_2$}}{\Delta}
%}
%\end{equation}

% TODO: Equals

\begin{equation}
\dfrac{
  \empty
}{
  \lb{\neg\, e}{\Delta} \longrightarrow \neg\,\lb{e}{\Delta}
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{f}{\Delta} \longrightarrow \lambda \stt{x$_1$:\,T$_1$,\ldots,x$_n$:\,T$_n$.\,$b$}
  \qquad
  \lb{e_i}{\Delta} \longrightarrow \lb{e_i'}{\Delta},\, i \in \{1 \ldots n\}
}{
  \lb{f(e_1,\ldots,e_n)}{\Delta} \longrightarrow
  \lb{b[\stt{x}_1/e_1',\ldots,\stt{x}_n/e_n']}{\Delta}
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{f}{\Delta} \longrightarrow f' \qquad
  \lb{e_i}{\Delta} \longrightarrow \lb{e_i'}{\Delta},\, i \in \{1 \ldots n\}
}{
  \lb{f(e_1,\ldots,e_n)}{\Delta} \longrightarrow
  f'(e_1', \ldots, e_n')
}
\end{equation}

% TODO: Application(Assume)?

\begin{equation}
\dfrac{
 \neg\,\stt{isRecursive(id)} \quad
 \stt{id.params} = \langle \stt{x}_1, \ldots, \stt{x}_n \rangle \quad
 \lb{e_i}{\Delta} \longrightarrow \lb{e_i'}{\Delta},\, i \in \{1 \ldots n\}
}{
  \lb{\stt{id}(e_1,\ldots,e_n)}{\Delta} \longrightarrow
  \lb{\stt{id.body}[\stt{x}_1/e_1',\ldots,\stt{x}_n/e_n']}{\Delta}
}
\end{equation}

\begin{equation}
\dfrac{
 \stt{id.body} \Downarrow \Delta \uplus \{\,\stt{x}_i \mapsto e_i'\,|\, 1 \leq i \leq n\,\}
 \quad
 \stt{id.params} = \langle \stt{x}_1, \ldots, \stt{x}_n \rangle
 \quad
 \lb{e_i}{\Delta} \longrightarrow \lb{e_i'}{\Delta},\  i \in \{1 \ldots n\}
}{
  \lb{\stt{id}(e_1,\ldots,e_n)}{\Delta} \longrightarrow
  \lb{\stt{id.body}[\stt{x}_1/e_1',\ldots,\stt{x}_n/e_n']}{\Delta}
}
\end{equation}

\begin{equation}
\dfrac{
 \lb{e_i}{\Delta} \longrightarrow \lb{e_i'}{\Delta},\, i \in \{1 \ldots n\}
}{
  \lb{\stt{id}(e_1,\ldots,e_n)}{\Delta} \longrightarrow
  \stt{id}(e_1',\ldots,e_n')
}
\end{equation}

\end{framed}
\vspace{-10pt}
\caption{Operational semantics of the partial evaluator \label{fig:partialsem}}
\end{figure}

%------------------------------------------------------------------------

\clearpage
\section{Verifiying Actor Systems}
\label{actors}

\subsection{The Actor Model}

\TODO{Actor Model}

\cite{actario} \cite{verdi} \cite{akka}

\subsubsection*{Message}

In our framework, messages are modelled as instances of the \InlineS{Msg} trait.

\begin{ShortCode}{PureScala}
abstract class Msg
\end{ShortCode}

\subsubsection*{Actor Reference}

Each actor is associated with a unique and persistent reference, modelled as an instance of the \ActorRef trait.

\begin{ShortCode}{PureScala}
abstract class ActorRef
\end{ShortCode}

\subsubsection*{In-flight Messages}

In-flight messages are represented as a product of the \ActorRef of the destination actor, and the message itself.

\begin{ShortCode}{PureScala}
case class Packet(dest: ActorRef, payload: Msg)
\end{ShortCode}

\subsubsection*{Actor Context}

When a message is delivered to an actor, the latter is provided with a context,
which holds a reference to itself, and a mutable list of \InlineS{Packet}s to send.

\begin{ShortCode}{PureScala}
case class ActorContext(
  self: ActorRef,
  var toSend: List[Packet]
)
\end{ShortCode}

\subsubsection*{Behavior}

A behavior specifies both the current state of an actor, and how this one should 
process the next incoming message. In our framework, these are modelled as a subclass 
of the abstract class \InlineS{Behavior}, which defines a single abstract method 
\InlineS{processMsg}, to be overriden for each defined behavior.

Using the provided \InlineS{ActorContext}, the implementation of the \InlineS{processMsg}
method can both access its own reference, and register messages to be sent after the
execution of the method is complete. It is also required to return a new \InlineS{Behavior}

\begin{ShortCode}{PureScala}
abstract class Behavior {
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior
}
\end{ShortCode}

%\subsubsection*{Transition}
%
%Whenever a message is processed, we record the transition between the previous 
%state of the system and the one after the message has been been processed. We keep 
%track of this information as an instance of the \InlineS{Transition} class, which 
%holds: the \InlineS{Msg} that has been delivered, its sender and receiver, the new 
%behavior of the destination actor, and the list of \InlineS{Packet}s the destination 
%actor wants to send.
%
%\begin{ShortCode}{PureScala}
%case class Transition(
%  from: ActorRef,
%  to: ActorRef,
%  msg: Msg,
%  newBehavior: Behavior,
%  toSend: List[Packet]
%)
%\end{ShortCode}

\subsubsection*{Actor System}

The state of the Actor system at a given point in time is modelled as a case class, 
holding the behavior associated with each actor reference, the list of in-flight messages between any two actors,
%as well as a trace of the execution up to that point, modelled as a list of \InlineS{Transition}s.

\begin{ShortCode}{PureScala}
case class ActorSystem(
  behaviors: CMap[ActorRef, Behavior],
  inboxes: CMap[(ActorRef, ActorRef), List[Msg]],
%  trace: List[Transition]
)
\end{ShortCode}

The \InlineS{ActorSystem} class is equipped with a \InlineS{step} method, which takes 
a pair of \ActorRef as arguments, and is in charge of delivering the oldest message 
found in the corresponding inbox, and which returns the new state of the system after 
the aforementioned message has been processed.

\begin{ShortCode}{PureScala}
def step(from: ActorRef, to: ActorRef): ActorSystem
\end{ShortCode}

\subsection{Operational Semantics}
\label{semantics}

We formulate the small-step operational semantics of our Actor model in 
\RefFig{fig:opsem}, where $s: \stt{ActorSystem}$ is an Actor system,
$m: \stt{Msg}$ is a message,
$n, n_{to}, n_{from}: \stt{ActorRef}$ are references,
$b, b': \stt{Behavior}$ are behaviors,
$ps: \stt{List[Packet]}$ a list of packets to send,
$t: \stt{Transition}$ is a transition,
$c: \stt{ActorContext}$ is a context,
and $\emptyset_n: \stt{ActorContext}$ is the empty context for an actor whose
self-reference is $n$, defined as $\emptyset_n := \stt{ActorContext}(n, \stt{Nil})$.

\begin{figure}[!h]
\begin{framed}
 
\begin{equation}
\dfrac{
  \not\exists m \in \stt{$s$.inboxes}(n_{from}, n_{to})
}{
  \langle \stt{$s$.step}(n_{from}, n_{to}) \rangle \longrightarrow \stt{s}
}
\tag{STEP-NOMSG}
\end{equation}

\vspace{10pt}
\begin{equation}
\dfrac{
  \exists m \in \stt{$s$.inboxes}(n_{from}, n_{to}) \qquad
  \langle \stt{$s$.deliverMsg}(n_{to}, n_{from}, m) \rangle \Rightarrow (b, ps, t)
}{
  \langle \stt{$s$.step}(n_{from}, n_{to}) \rangle \longrightarrow s \uplus (n_{to} \mapsto b, \ldots, t)
}
\tag{STEP}
\end{equation}

\vspace{10pt}
\begin{equation}
\dfrac{
  \langle \stt{$s$.behaviors($n_{to}$).processMsg}(m, \emptyset_{n_{to}}) \rangle \longrightarrow (b, c) 
}{
   \langle \stt{$s$.deliverMsg}(n_{to}, n_{from}, m) \rangle \longrightarrow (b, \stt{$c$.toSend}, t)
}
\tag{DELIVER-MSG}
\end{equation}

\vspace{10pt}
\begin{equation}
\dfrac{
  \stt{$b$.processMsg}(m, \emptyset_{n_{to}}) = [i_1, \ldots, i_n, b'] \qquad
  \emptyset_{n_{to}} \vdash \langle [i_1, \ldots, i_n] \rangle \Rightarrow c
}{
   \langle \stt{$b$.processMsg}(m, \emptyset_{n_{to}}) \rangle \longrightarrow (b', c)
}
\tag{PROCESS-MSG}
\end{equation}

\vspace{10pt}
\begin{equation}
\dfrac{\empty}{
   \langle \stt{Nil}, c \rangle \Rightarrow c
}
\tag{I-NIL}
\end{equation}

\vspace{10pt}
\begin{equation}
\dfrac{
  \langle i, c \rangle \Rightarrow c'
}{
  \langle \stt{$i$ :: $is$}, c \rangle \Rightarrow \langle is, c' \rangle
}
\tag{I-CONS}
\end{equation}

\vspace{10pt}
\begin{equation}
\dfrac{\empty}{
   \langle n\ \stt{!}\ m, c \rangle \Rightarrow (b',\ \stt{$c$.copy(toSend $\mapsto$ ($n, m$) :: $c$.toSend)})
}
\tag{I-SEND}
\end{equation}

\end{framed}
\vspace{-10pt}
\caption{Operational semantics\label{fig:opsem}}
\end{figure}

\subsection{Proving Invariants}
\label{invariants}

After having defined an Actor system with our framework, one might want to verify that this 
system preserves some invariant between each step of its execution. That is to say, 
for an \InlineS{ActorSystem} $s$, any two \ActorRef $n, m$,
and an invariant \InlineS{inv: ActorSystem $\ \to\ $ Boolean}, if $\texttt{inv}(s)$ holds, 
then $\texttt{inv}(s\texttt{.step}(n, m))$ should hold as well. We express this 
property more formally in \RefFig{fig:stepinvariant}. This property can be easily expressed in PureScala, as shown in \RefCode{lst:preserveInv}.

\begin{figure}[!h]
$$\forall s: \texttt{ActorSystem},\, n: \texttt{ActorRef},\, m: \texttt{ActorRef}.\ \texttt{inv($s$)} \implies \texttt{inv($s$.step($n, m$))}$$
\vspace{-20pt}
\caption{Invariant preservation property\label{fig:stepinvariant}}
\end{figure}

\begin{Code}{PureScala}{lst:preserveInv}{Invariant preservation theorem in PureScala}
def inv(s: ActorSystem): Boolean = {
  /* ... */
}

def preserveInv(s: ActorSystem, n: ActorRef, m: ActorRef): Boolean = {
  require(inv(s))
  inv(s.step(n, m))
} holds
\end{Code}

When encoutering such a definition, Stainless will generate a verification condition 
equivalent to \RefFig{fig:stepinvariant}, which will then be discharged to Inox and the underlying SMT solver.

\subsection{Reasoning About Traces}
\label{traces}

\TODO{Traces}

\subsection{Case studies}
\label{casestudies}

\subsubsection*{Replicated Counter (increment)}

As a first and very simple case study, we will study an Actor system which models a
replicated counter, which can only be incremented by one unit. This system is 
composed of two actors, a primary counter whose reference is \texttt{Primary()},
and a backup counter whose reference is \texttt{Backup()}.
Each of these reference is associated with a behavior: the primary counter reference with
an instance of \texttt{PrimaryB}, and the backup counter reference with an instance 
of \texttt{BackupB}, both of which hold a positive integer, representing the value of the
counter. Whenever the primary actor receives a message \texttt{Inc()}, it forwards that
message to the backup actor, and returns a new instance of \texttt{PrimaryB} with the
counter incremented by one. When the backup actor receives an \texttt{Inc()} message,
it just returns a new instance of \texttt{BackupB} with the counter incremented by one. 
The corresponding PureScala implementation can be found
in \RefCode{lst:ReplicatedCounterInc}.

\begin{Code}{PureScala}{lst:ReplicatedCounterInc}{Replicated counter implementation (increment)}
case class Primary() extends ActorRef
case class Backup()  extends ActorRef

case class Inc() extends Msg

case class PrimaryB(counter: BigInt) extends Behavior {
  require(counter >= 0)

  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case Inc() =>
      Backup() ! Inc()
      PrimaryB(counter + 1)
  }
}

case class BackupB(counter: BigInt) extends Behavior {
  require(counter >= 0)

  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case Inc() => BackupB(counter + 1)
  }
}
\end{Code}

Given such a system, one might want to prove that the following invariant is 
preserved between each step of its execution:

\begin{Code}{PureScala}{lst:repcounterincinv}{Replicated counter invariant (increment)}
def invariant(s: ActorSystem): Boolean = {
  s.inboxes((Backup(), Backup())).isEmpty && {
    (s.behaviors(Primary()), s.behaviors(Backup())) match {
      case (PrimaryB(p), BackupB(b)) =>
        p.value == b.value + s.inboxes(Primary() -> Backup()).length
      case _ => false
    }
  }
}
\end{Code}

This invariant specifies that the \stt{Backup()} actor does not send itself any messages, that both actors have the proper corresponding behavior, and that, last but not least, the value of the primary counter is equal to the value of the backup counter added to the number of messages that are yet to be delivered to the backup actor.\\

We can now define the actual theorem we want Stainless to prove for us:

\begin{Code}{PureScala}{lst:repcounterincthm}{Replicated counter theorem (increment)}
def preserveInv(s: ActorSystem, n: ActorRef, m: ActorRef): Boolean = {
  require(invariant(s))
  invariant(s.step(n, m))
} holds
\end{Code}

\TODO{Rep Counter Inc Result}

\subsubsection*{Replicated Counter (deliver)}

\RefCode{lst:ReplicatedCounterDel} shows a variant of the previous case study, where instead of having the primary actor forward the \stt{Inc()} message to the backup actor, it instead delivers it with its new value.

\begin{Code}{PureScala}{lst:ReplicatedCounterDel}{Replicated counter implementation (deliver)}
case class Primary() extends ActorRef
case class Backup()  extends ActorRef

case class Inc() extends Msg
case class Deliver(c: BigInt) extends Msg

case class PrimaryB(counter: BigInt) extends Behavior {
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case Inc() =>
      Backup() ! Deliver(counter + 1)
      PrimaryB(counter + 1)

    case _ => Behavior.same
  }
}

case class BackupB(counter: BigInt) extends Behavior {
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case Deliver(c) => BackupB(c)
    case _          => Behavior.same
  }
}
\end{Code}

The invariant now reads slightly differently, as can be seen in \RefCode{lst:ReplicatedCounterDelInv}, and can no longer be proven automatically by Stainless on its own. \RefCode{lst:ReplicatedCounterDel} shows the full proof.

\begin{Code}{PureScala}{lst:ReplicatedCounterDelInv}{Replicated counter implementation (deliver)}
def invariant(s: ActorSystem): Boolean = {
  validBehaviors(s)                           &&
  noMsgsToSelf(Primary()).isEmpty             &&
  noMsgsToSelf(Backup()).isEmpty              &&
  noMsgsToSelf(Backup() -> Primary()).isEmpty && {
    val PrimBehav(p) = s.behaviors(Primary())
    val BackBehav(b) = s.behaviors(Backup())
    val bInbox       = s.inboxes(Primary() -> Backup())

    p.value >= b.value && isSorted(bInbox) && bInbox.forall {
      case Deliver(Counter(i)) => p.value >= i
      case _                   => true
    }
  }
}
\end{Code}

\TODO{Rep Counter Del Result}

%\subsubsection*{Lock Service}
%
%\RefCode{lst:LockService} shows the implementation of a lock service using our framework. In this case study, an actor acts as a server holding a lock on some resource, while a number of other actors (the "agents") act as clients of the lock service, each potentially trying to acquire the lock on the resource. To model a variable number of actors with the same implementation, we define their reference as a case class parametrized by a \TODO{unique} identifier.
%
%\begin{Code}{PureScala}{lst:LockService}{Lock service implementation}
%TODO
%\end{Code}
%
%An obvious property we might want to prove is that, at any time, at most one of those agents thinks that it holds the lock. Additionally, we'd like to ensure that such an agent is actually the same one that the server granted the lock too. We express this property in \RefCode{lst:LockServiceInv}.
%
%\begin{Code}{PureScala}{lst:LockServiceInv}{Lock service invariant}
%def validBehaviors(s: ActorSystem): Boolean = {
%  s.behaviors(Server()).isInstanceOf[ServerB] &&
%  forall { (a: Agent) =>
%  	s.behaviors(a).isInstanceOf[AgentB]
%  }
%}
%
%def noMsgstoSelf(s: ActorSystem): Boolean = forall { (ref: ActorRef) =>
%  s.inboxes(ref -> ref).isEmpty
%}
%
%def hasLock(s: ActorSystem, a: ActorRef): Boolean = {
%  s.behaviors(a) match {
%    case AgentB(hasLock) => hasLock
%    case _ => false
%  }
%}
%
%def mutex(s: ActorSystem): Boolean = forall { (a: ActorRef, b: ActorRef) =>
%  (a != b) ==> !(hasLock(s, a) && hasLock(s, b))
%}
%
%def hasLockThenHead(s: ActorSystem): Boolean = forall { (ref: ActorRef) =>
%  hasLock(s, ref) ==> {
%    s.behaviors(Server()) match {
%      case ServerB(Cons(head, _)) => head == ref
%      case _ => false
%    }
%  }
%}
%
%def invariant(s: ActorSystem): Boolean = {
%  validBehaviors(s)  &&
%  noMsgstoSelf(s)    &&
%  mutex(s)           &&
%  hasLockThenHead(s)
%}
%\end{Code}
%
%\TODO{Lock service results}

%\subsubsection*{Leader Election}
%
%\TODO{Leader election}

%\subsubsection*{Key-value store}
%
%\TODO{KV store}

%\subsection{Spawning Actors}
%\label{spawn}
%
%Up until now, our framework has only been able to model Actor systems with a static topology, ie. systems where no new actors besides the ones that are statically defined can be spawned. Let's now attempt to enrich our model to account for dynamic topologies.
%
%To this end, we modify the \ActorRef definition to include both a name and an optional field holding a reference to its parent \ActorRef if any. We also add a new constructor of the \ActorRef data type, which will be assigned to actors spawned from another actor.
%
%\begin{ShortCode}{PureScala}
%abstract class ActorRef(
%  name: String,
%  parent: Option[ActorRef]
%)
%
%case class Child(name: String, getParent: ActorRef)
%  extends ActorRef(name, Some(getParent))
%\end{ShortCode}
%
%In order for actors to spawn other actors, by specifying their name and associated 
%initial behavior, we modify the \stt{ActorContext} class as follows:
%
%\begin{ShortCode}{PureScala}
%case class ActorContext(
%  self: ActorRef,
%  var toSend: List[Packet],
%  var toSpawn: List[(ActorRef, Behavior)]
%) {
%  def spawn(behavior: Behavior, name: String): ActorRef = {
%    val id: ActorRef = Child(name, self)
%    toSpawn = toSpawn :+ (id, behavior)
%    id
%  }
%  /* ... */
%}
%\end{ShortCode}
%
%As can be seen in the listing above, the context now keeps track of the names and 
%behaviors of the actors to be spawned, and provides a \stt{spawn} method which is in 
%charge of constructing the \ActorRef of the spawned actor, storing it along with the 
%behavior within the context, and returning the newly generated reference.
%
%Let's now update the case study in \RefCode{lst:ReplicatedCounterInc} to accommodate 
%these changes, while noting that we are not making use of this new feature yet. Only 
%the two \ActorRef definitions needÂ to be touched, becoming:
%
%\begin{ShortCode}{PureScala}
%case class Primary() extends ActorRef("primary", None())
%case class Backup()  extends ActorRef("backup", None())
%\end{ShortCode}
%
%Unfortunately, when we now feed the updated benchmark to Stainless, the latter is be 
%unable to prove the very same theorem it previously had no issue whatsoever with.
%
%All is not lost though, as turning on the partial evaluator described in
%\RefSec{partial} enables Stainless to verify the program in less than 10 seconds.

\subsection{Executing an Actor System with Akka}
\label{akka}

While the verification of Actor systems is in itself an interesting endeavour, it is not of much use unless one is able to run these systems, potentially in a distributed environment. In the Scala ecosystem, the most widely used real-world Actor system is Akka \TODO{REF}. \RefCode{lst:akkashim} shows a very shallow shim which allows to run an Actor system developed with our framework within Akka.

\begin{Code}{PureScala}{lst:akkashim}{Akka shim for our Actor system framework}
import akka.actor

type ActorRef = actor.ActorRef

case class ActorContext(self: actor.ActorRef, ctx: actor.ActorContext)

class Wrapper(var behavior: Behavior)
  extends actor.Actor with actor.ActorLogging {

  implicit val ctx = ActorContext(self, context)

  def receive = {
    case msg: Msg =>
      log.info(s"$\$${behavior}: $\$${msg}")
      behavior = behavior.processMsg(msg)

    case _ => ()
  }
}

abstract class ActorSystem(val name: String) {
  lazy val system = actor.ActorSystem(name)

  def spawn(behavior: Behavior, name: String): actor.ActorRef = {
    system.actorOf(actor.Props(new Wrapper(behavior)), name = name)
  }

  def run(): Unit
}
\end{Code}

\TODO{Explain shim}

It now becomes possible, with only a few alterations to the original program, to run the system on top of Akka, as shown in \RefCode{lst:akkashimex}.

\begin{Code}{PureScala}{lst:akkashim}{Akka shim for our Actor system framework}
@extern
object System extends ActorSystem("rep-counter-sys") {
  override def run(): Unit = {
    val backup  = spawn(BackupB(0), "backup")
    val primary = spawn(PrimaryB(0, backup), "primary")

    primary ! Inc()
  }
}

@extern
def main(args: Array[String]): Unit = {
  System.run()
}
\end{Code}

\section{Strong Eventual Consistency with CRDTs}
\label{crdt}

\TODO{CRDTs}

\section{Biparty Communication Protocols}
\label{biparty}

\TODO{Bipart}

\section{Conclusion}
\label{conclusion}

\TODO{Conclusion}

\section{Future Work}
\label{futurework}

\appendix

\TODO{Future Work}

\clearpage

\bibliographystyle{ieeetr}
\bibliography{report}

\end{document}
