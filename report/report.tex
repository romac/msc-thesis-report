\include{header}

\clearpage
\pagestyle{mystyle}

\section{Introduction}

\TODO{Introduction}

\subsection*{Related Works}

\TODO{Related Works}

\section{Motivation}
\label{motivation}


\TODO{Motivation}

\clearpage
\section{Verifiying Actor Systems}
\label{actors}

\subsection{The Actor Model}

\TODO{Actor Model}

\cite{actario}

\subsubsection{Message}

In our framework, messages are modelled as instances of the \InlineS{Msg} trait.

\begin{ShortCode}{PureScala}
abstract class Msg
\end{ShortCode}

\subsubsection{Actor Reference}

Each actor is associated with a unique and persistent reference, modelled as an instance
of the \ActorRef trait.

\begin{ShortCode}{PureScala}
abstract class ActorRef
\end{ShortCode}

\subsubsection{In-flight Messages}

In-flight messages are represented as a product of the \ActorRef of the destination actor,
and the message itself.

\begin{ShortCode}{PureScala}
case class Packet(dest: ActorRef, payload: Msg)
\end{ShortCode}

\subsubsection{Actor Context}

When a message is delivered to an actor, the latter is provided with a context,
which holds a reference to itself, and a mutable list of \InlineS{Packet}s to send.

\begin{ShortCode}{PureScala}
case class ActorContext(
  self: ActorRef,
  var toSend: List[Packet]
)
\end{ShortCode}

\subsubsection{Behavior}

A behavior specifies both the current state of an actor, and how this one should 
process the next incoming message. In our framework, these are modelled as a subclass 
of the abstract class \InlineS{Behavior}, which defines a single abstract method 
\InlineS{processMsg}, to be overriden for each defined behavior.

Using the provided \InlineS{ActorContext}, the implementation of the \InlineS{processMsg}
method can both access its own reference, and register messages to be sent after the
execution of the method is complete. It is also required to return a new \InlineS{Behavior}

\begin{ShortCode}{PureScala}
abstract class Behavior {
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior
}
\end{ShortCode}

\subsubsection{Transition}

Whenever a message is processed, we record the transition between the previous 
state of the system and the one after the message has been been processed. We keep 
track of this information as an instance of the \InlineS{Transition} class, which 
holds: the \InlineS{Msg} that has been delivered, its sender and receiver, the new 
behavior of the destination actor, and the list of \InlineS{Packet}s the destination 
actor wants to send.

\begin{ShortCode}{PureScala}
case class Transition(
  from: ActorRef,
  to: ActorRef,
  msg: Msg,
  newBehavior: Behavior,
  toSend: List[Packet]
)
\end{ShortCode}

\subsubsection{Actor System}

The state of the Actor system at a given point in time is modelled as a case class, 
holding the behavior associated with each actor reference, the list of in-flight messages 
between any two actors, as well as a trace of the execution up to that point, 
modelled as a list of \InlineS{Transition}s.

\begin{ShortCode}{PureScala}
case class ActorSystem(
  behaviors: CMap[ActorRef, Behavior],
  inboxes: CMap[(ActorRef, ActorRef), List[Msg]],
  trace: List[Transition]
)
\end{ShortCode}

The \InlineS{ActorSystem} class is equipped with a \InlineS{step} method, which takes 
a pair of \ActorRef as arguments, and is in charge of delivering the oldest message 
found in the corresponding inbox, and which returns the new state of the system after 
the aforementioned message has been processed.

\begin{ShortCode}{PureScala}
def step(from: ActorRef, to: ActorRef): ActorSystem
\end{ShortCode}

\subsection{Operational Semantics}
\label{semantics}

We formulate the small-step operational semantics of our Actor model in 
\RefFig{fig:opsem}, where $s: \stt{ActorSystem}$ is an Actor system,
$m: \stt{Msg}$ is a message,
$n, n_{to}, n_{from}: \stt{ActorRef}$ are references,
$b, b': \stt{Behavior}$ are behaviors,
$ps: \stt{List[Packet]}$ a list of packets to send,
$t: \stt{Transition}$ is a transition,
$c: \stt{ActorContext}$ is a context,
and $\emptyset_n: \stt{ActorContext}$ is the empty context for an actor whose
self-reference is $n$, defined as $\emptyset_n := \stt{ActorContext}(n, \stt{Nil})$.

\begin{figure}[!h]
\begin{framed}
 
\begin{equation}
\dfrac{
  \not\exists m \in \stt{$s$.inboxes}(n_{from}, n_{to})
}{
  \langle \stt{$s$.step}(n_{from}, n_{to}) \rangle \longrightarrow \stt{s}
}
\tag{STEP-NOMSG}
\end{equation}

\vspace{10pt}
\begin{equation}
\dfrac{
  \exists m \in \stt{$s$.inboxes}(n_{from}, n_{to}) \qquad
  \langle \stt{$s$.deliverMsg}(n_{to}, n_{from}, m) \rangle \Rightarrow (b, ps, t)
}{
  \langle \stt{$s$.step}(n_{from}, n_{to}) \rangle \longrightarrow s \uplus (n_{to} \mapsto b, \ldots, t)
}
\tag{STEP}
\end{equation}

\vspace{10pt}
\begin{equation}
\dfrac{
  \langle \stt{$s$.behaviors($n_{to}$).processMsg}(m, \emptyset_{n_{to}}) \rangle \longrightarrow (b, c) 
}{
   \langle \stt{$s$.deliverMsg}(n_{to}, n_{from}, m) \rangle \longrightarrow (b, \stt{$c$.toSend}, t)
}
\tag{DELIVER-MSG}
\end{equation}

\vspace{10pt}
\begin{equation}
\dfrac{
  \stt{$b$.processMsg}(m, \emptyset_{n_{to}}) = [i_1, \ldots, i_n, b'] \qquad
  \emptyset_{n_{to}} \vdash \langle [i_1, \ldots, i_n] \rangle \Rightarrow c
}{
   \langle \stt{$b$.processMsg}(m, \emptyset_{n_{to}}) \rangle \longrightarrow (b', c)
}
\tag{PROCESS-MSG}
\end{equation}

\vspace{10pt}
\begin{equation}
\dfrac{\empty}{
   \langle \stt{Nil}, c \rangle \Rightarrow c
}
\tag{I-NIL}
\end{equation}

\vspace{10pt}
\begin{equation}
\dfrac{
  \langle i, c \rangle \Rightarrow c'
}{
  \langle \stt{$i$ :: $is$}, c \rangle \Rightarrow \langle is, c' \rangle
}
\tag{I-CONS}
\end{equation}

\vspace{10pt}
\begin{equation}
\dfrac{\empty}{
   \langle n\ \stt{!}\ m, c \rangle \Rightarrow (b',\ \stt{$c$.copy(toSend $\mapsto$ ($n, m$) :: $c$.toSend)})
}
\tag{I-SEND}
\end{equation}

\end{framed}
\vspace{-10pt}
\caption{Operational semantics\label{fig:opsem}}
\end{figure}

\subsection{Proving Invariants}
\label{invariants}

After having defined an Actor system with our framework, one might want to verify that this 
system preserves some invariant between each step of its execution. That is to say, 
for an \InlineS{ActorSystem} $s$, any two \ActorRef $n, m$,
and an invariant \InlineS{inv: ActorSystem $\ \to\ $ Boolean}, if $\texttt{inv}(s)$ holds, 
then $\texttt{inv}(s\texttt{.step}(n, m))$ should hold as well. We express this 
property more formally in \RefFig{fig:stepinvariant}.

\begin{figure}[!h]
$$\forall s: \texttt{ActorSystem},\, n: \texttt{ActorRef},\, m: \texttt{ActorRef}.\ \texttt{inv($s$)} \implies \texttt{inv($s$.step($n, m$))}$$
\vspace{-20pt}
\caption{Invariant preservation property\label{fig:stepinvariant}}
\end{figure}

This property can be trivially expressed in PureScala as:

\begin{ShortCode}{PureScala}
def inv(s: ActorSystem): Boolean = {
  /* ... */
}

def preserveInv(s: ActorSystem, n: ActorRef, m: ActorRef): Boolean = {
  require(inv(s))
  inv(s.step(n, m))
} holds
\end{ShortCode}

When encoutering such a definition, Stainless will generate a verification condition 
equivalent to \RefFig{fig:stepinvariant}, which will then be discharged to Inox and the
underlying SMT solver.

\subsection{Reasoning About Traces}
\label{traces}

\TODO{Traces}

\subsection{Case studies}
\label{casestudies}

\subsubsection*{Replicated Counter (increment)}

As a first and very simple case study, we will study an Actor system which models a
replicated counter, which can only be incremented by one unit. This system is 
composed of two actors, a primary counter whose reference is \texttt{Primary()},
and a backup counter whose reference is \texttt{Backup()}.
Each of these reference is associated with a behavior: the primary counter reference with
an instance of \texttt{PrimaryB}, and the backup counter reference with an instance 
of \texttt{BackupB}, both of which hold a positive integer, representing the value of the
counter. Whenever the primary actor receives a message \texttt{Inc()}, it forwards that
message to the backup actor, and returns a new instance of \texttt{PrimaryB} with the
counter incremented by one. When the backup actor receives an \texttt{Inc()} message,
it just returns a new instance of \texttt{BackupB} with the counter incremented by one. 
The corresponding PureScala implementation can be found
in \RefCode{lst:ReplicatedCounterInc}.

\begin{Code}{PureScala}{lst:ReplicatedCounterInc}{Replicated counter implementation (increment)}
case class Primary() extends ActorRef
case class Backup()  extends ActorRef

case class Inc() extends Msg

case class PrimaryB(counter: BigInt) extends Behavior {
  require(counter >= 0)
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case Inc() =>
      Backup() ! Inc()
      PrimaryB(counter + 1)
  }
}

case class BackupB(counter: BigInt) extends Behavior {
  require(counter >= 0)
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case Inc() => BackupB(counter + 1)
  }
}
\end{Code}

An interesting invariant of the system we might want to verify is preserved at each 
step, is 

\subsubsection*{Replicated Counter (deliver)}

\begin{Code}{PureScala}{lst:ReplicatedCounterDel}{Replicated counter implementation (deliver)}
case class Primary() extends ActorRef
case class Backup()  extends ActorRef

case class Inc() extends Msg
case class Deliver(c: BigInt) extends Msg

case class PrimaryB(counter: BigInt) extends Behavior {
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case Inc() =>
      Backup() ! Deliver(counter + 1)
      PrimaryB(counter + 1)

    case _ => Behavior.same
  }
}

case class BackupB(counter: BigInt) extends Behavior {
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case Deliver(c) => BackupB(c)
    case _          => Behavior.same
  }
}
\end{Code}

\subsubsection*{Lock Service}

\RefCode{lst:ReplicatedCounterDel}

\begin{Code}{PureScala}{lst:ReplicatedCounterDel}{Replicated counter implementation (deliver)}
case class Server() extends ActorRef
object Server {
  case class Lock(agent: ActorRef) extends Msg
  case class Unlock(agent: ActorRef) extends Msg
}

case class Agent(id: BigInt) extends ActorRef
object Agent {
  case object Lock extends Msg
  case object Unlock extends Msg
  case object Grant extends Msg
}

// The head of `agents` holds the lock, the tail are waiting for the lock
case class ServerB(agents: List[ActorRef]) extends Behavior {
  def isLocked: Boolean = agents.nonEmpty

  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case Server.Lock(agent) if agents.isEmpty =>
      agent ! Agent.Grant
      ServerB(List(agent))

    case Server.Lock(agent) =>
      ServerB(agents :+ agent)

    case Server.Unlock(agent) if agents.nonEmpty =>
      val newAgents = agents.tail
      if (newAgents.nonEmpty) newAgents.head ! Agent.Grant
      ServerB(newAgents)

    case _ =>
      Behavior.same
  }
}

case class AgentB(holdsLock: Boolean) extends Behavior {
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case Agent.Lock =>
      Server() ! Server.Lock(ctx.self)
      Behavior.same

    case Agent.Unlock if holdsLock =>
      Server() ! Server.Unlock(ctx.self)
      AgentB(false)

    case Agent.Grant =>
      AgentB(true)

    case _ =>
      Behavior.same
  }
}
\end{Code}

\subsubsection*{Leader Election}

\TODO{Leader election}

\subsubsection*{Key-value store}

\TODO{KV store}

\subsection{Executing an Actor System with Akka}
\label{traces}

\section{Strong Eventual Consistency with CRDTs}
\label{crdt}

\TODO{CRDTs}

\section{Biparty Communication Protocols}
\label{biparty}

\TODO{Bipart}

\section{Conclusion}
\label{conclusion}

\TODO{Conclusion}

\section{Future Work}
\label{futurework}

\appendix

\TODO{Future Work}

\clearpage

\bibliographystyle{ieeetr}
\bibliography{report}

\end{document}
