\documentclass[a4paper,twoside]{article}
\usepackage[a4paper]{geometry}

% \usepackage[a4paper,showframe]{geometry} % add showframe for debug
% \usepackage{titleps}

\usepackage[pagestyles]{titlesec}
\usepackage[all]{nowidow} % avoid orphan lines

% Extra colours; need to be first
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}

% Basic packages
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

% Landscape mode
\usepackage{pdflscape}

% Additional font
\usepackage{FiraMono}

% Bibtex+cite
\usepackage{cite}
\usepackage{url}
\usepackage[nottoc,numbib]{tocbibind}

% URL
\usepackage[
  colorlinks=true,
  urlcolor=blue,
  citecolor=black,
  linkcolor=.
]{hyperref}

% Lists
\usepackage{scrextend}
\addtokomafont{labelinglabel}{\sffamily}
\usepackage[inline]{enumitem} % for enumerate* environment.

% Maths & symbols
\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{pifont}
\usepackage{framed}
\usepackage{stmaryrd}
\newcommand{\lb}[2]{\llbracket\, #1\,;\, #2\, \rrbracket}

% Mono font
\usepackage[scaled]{beramono}

% Spacing
\usepackage{xspace}

% Graphics
\usepackage{graphicx}

% Table
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{multirow}

% Floating placement
\usepackage{placeins}
% use \FloatBarrier before a \section to ensure all floating are displayed
% before the new section

% Caption styling
\usepackage[justification=centering]{caption}

% Additional colours
\definecolor{c1}{HTML}{006C71}
\definecolor{c2}{HTML}{005155}
\definecolor{c3}{HTML}{FF8928}
\definecolor{c4}{HTML}{E86900}
\colorlet{ImportantCode}{ForestGreen}
\colorlet{ImportantCode2}{RubineRed}
\colorlet{ImportantCode3}{RedOrange}

% TIKZ & related packages/settings
\usepackage{tikz}
\usepackage{pgfplots}
\usetikzlibrary{shapes,fit,backgrounds,arrows,positioning,chains,patterns}
% \pgfplotsset{compat = 1.14}

% for caching tikz pictures
% \usetikzlibrary{external}
% \tikzexternalize[prefix=tikz-figures/]
% \pgfrealjobname{tikz}

% Layout
\usepackage{chngpage}
\usepackage{rotating}

% Line spacing
\linespread{1.1}

% Listings
\usepackage{listings,multicol}
\usepackage{lstscala}

\lstdefinelanguage{PureScala}{ % Using `Scala` result in a infinite recursion
  style=scala-color,
  morekeywords={[2]Unit,Boolean,Byte,Int,BigInt,String,Char,Option,List,true,false},
  %keywordstyle={[2]\color{blue!30!darkgray}\bfseries}
}

\newcommand{\Inline}[1]{\lstinline[basicstyle=\small\ttfamily,columns=fixed]|#1|}
\newcommand{\InlineS}[1]{\lstinline[language=PureScala,basicstyle=\small\ttfamily,columns=fixed]|#1|}
% %\newcommand{\inlineScala}[1]{\lstinline[language=MyScala,breaklines=true,breakatwhitespace=true]|#1|}

% Use code in description item, Based on http://tex.stackexchange.com/a/181325/77356
\newcommand*{\lstitem}[1]{
  \setbox0\hbox{\textbf{\Inline{#1}}}
  \item[\usebox0]
}

% %\lstset{aboveskip=5pt,belowskip=10pt}
% \lstset{captionpos=b,abovecaptionskip=1em}

% For long listings
\lstdefinestyle{LongCode}{
  %aboveskip=1ex,
  basicstyle=\small\ttfamily,
  % basicstyle=\scriptsize\ttfamily,
  % basicstyle=\tiny\ttfamily,
  %belowskip=1ex,
  breaklines=true,
  postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow}},
  breakautoindent=false,
  %breakatwhitespace=false,
  %columns=fullflexible,
  multicols=2,
  framerule=0pt,
  framexrightmargin=0em,
  framexleftmargin=0em,
  % numbers=left,
  % numberstyle=\footnotesize\sffamily,
  tabsize=2
}


% Env for short code: no label, no caption and "inlined" with a box
\lstnewenvironment{ShortCode}[1]
    {
      \lstset{
        language=#1,
        basicstyle=\small\ttfamily,
        frame=trBL % box the frame & double line on bottom and left side
      }
    }
    {
    }

% Env for longer code: label, caption and "floating" with a box
\lstnewenvironment{Code}[3]
    {
      \lstset{
        language=#1,
        basicstyle=\small\ttfamily,
        label={#2},
        caption=#3,
        captionpos=b, % bottom
        float=!h,     % "here"
        frame=trBL,   % box the frame & double line on bottom and left side
        % frameround=tttt
      }
    }
    {
      % DEBUG:
      % 1: #1 \\
      % 2: #2 \\
      % 3: #3
    }



% Tables
% \newcommand{\heading}[1]{\multicolumn{1}{c}{\textbf{#1}}}
% \newcommand{\vheading}[1]{\rotatebox[origin=c]{90}{~\textbf{#1}~}}


% To centre table too wide
% credit: http://tex.stackexchange.com/a/27099/77356
\makeatletter
\newcommand*{\centerfloat}{%
  \parindent \z@
  \leftskip \z@ \@plus 1fil \@minus \textwidth
  \rightskip\leftskip
  \parfillskip \z@skip}
\makeatother

% General styling
%\let\oldsection\section
%\renewcommand\section{\cleardoublepage\oldsection}

% For some reason page margin are swapped when having a title page with a
% different geometry. We fix that manually by 1) swapping the margin and
% 2) swapping the page number position (page style)
% credit: http://tex.stackexchange.com/a/36016/77356
\makeatletter
\newcommand*{\flipmargins}{%
  \clearpage
  \setlength{\@tempdima}{\oddsidemargin}%
  \setlength{\oddsidemargin}{\evensidemargin}%
  \setlength{\evensidemargin}{\@tempdima}%
  \if@reversemargin
    \normalmarginpar
  \else
    \reversemarginpar
  \fi
}
\makeatother

\newpagestyle{mystyle_no_header}{
  \setfoot[\thepage][][]{}{}{\thepage}
}

\newpagestyle{mystyle}{
  % \sethead[][][\firsttitlemarks\ifthesubsection{\thesubsection~\subsectiontitle}{\thesection~\sectiontitle}]{\firsttitlemarks\ifthesubsection{\thesubsection~\subsectiontitle}{\thesection~\sectiontitle}}{}{}
  \sethead[\thesection~\sectiontitle][][]{}{}{\thesection~\sectiontitle}
  % \setfoot[][][\thepage]{\thepage}{}{}
  \setfoot[\thepage][][]{}{}{\thepage}
}

% Additional macros
\newcommand{\TODO}[1]{\textcolor{YellowOrange}{(TODO: #1)}} % for inline TODO
%\newcommand{\TODO}[1]{\textcolor{YellowOrange}{(TODO)}} % for inline TODO
% \newcommand{\TODO}[1]{\underline{(#1)}} % for inline TODO, PRINTING
\newcommand{\URL}[2]{#2:\xspace\href{#1}{#1}}
\newcommand{\RefSec}[1]{Section~\ref{#1}}
\newcommand{\RefTable}[1]{Table~\ref{#1}}
\newcommand{\RefApp}[1]{Appendix~\ref{#1}}
\newcommand{\RefFig}[1]{Figure~\ref{#1}}
\newcommand{\RefCode}[1]{Listing~\ref{#1}}
\newcommand{\BigO}[1]{\mathcal{O}(#1)}
\newcommand{\ActorRef}{\InlineS{ActorRef}\ }
\newcommand{\stt}[1]{\texttt{\small{#1}}}
%\newcommand{\stt}[1]{\InlineS{#1}}

%%%

\title{Systems Modeling With Stainless}

\date{
%  {\small Version 0.6}\\
  {\small (Draft)}\\
  January 2018
}

\author{Romain Ruetschi}

\begin{document}

\newgeometry{centering}
\pagenumbering{gobble}
\maketitle

\vfill

\begin{abstract}

\TODO{Abstract}

\end{abstract}

\vfill

\begin{center}
    Master Thesis Project under the supervision of \\
    Prof. Viktor Kuncak \& Dr. Jad Hamza \\
    Lab for Automated Reasoning and Analysis LARA - EPFL
\end{center}

\begin{center}
    \includegraphics[width = 40mm]{res/epfl-logo}
\end{center}

\clearpage\null\newpage

\restoregeometry              %% restore the layout
\flipmargins
\pagestyle{mystyle_no_header}
\pagenumbering{arabic}

\tableofcontents
% \lstlistoflistings

\clearpage
\pagestyle{mystyle}

% ===========================================================================================
% ===========================================================================================

\section{Introduction}

\TODO{Introduction}

\clearpage

\section{Program Verification with Stainless}
\label{verif}

\TODO{Describe Stainless/Inox pipeline}

\clearpage
\section{Symbolic Partial Evaluation of PureScala Programs}
\label{symbolic}

\subsection{Motivation}
\label{symbolic-motivation}

Let's consider the following program:

\begin{Code}{PureScala}{lst:symintro}{Example program}
def foldLeft[A, B](list: List[A], z: B)(f: (B, A) => B): B = list match {
  case Nil     => z
  case x :: xs => foldLeft(xs, f(z, x))(f)
}

def insert[A, B](kvs: List[(A, B)], map: Map[A, B]) = {
  foldLeft(kvs, map) {
    case (acc, (k, v)) if !acc.contains(k) => acc.updated(k, v)
    case (acc, _)                          => acc
  }
}

def test(map: Map[String, Int], x: Int, y: Int): (Int, Map[String, Int]) = {
  require(!map.contains("a") && map.contains("b"))

  val xs  = ("a", x) :: ("b", y) :: Nil
  val res = insert(xs, map)

  res("a") == x && res("b") == map("b")
} holds
\end{Code}

Although this program is correct, Stainless is unfortunately unable to prove the verification condition corresponding to \stt{test}'s postcondition on its own. To remedy to this problem, one could refine the program by adding contracts to the \stt{foldLeft} and \stt{insert} functions, or introduce additional lemmas. While this is a reasonable way of going at the problem, we will discuss in this chapter an alternative way of proving such programs correct. The main insight we will make use of is that, although none of the arguments to \stt{insert} are fully known within the \stt{test} function, the knowledge we have of \stt{map} from \stt{test}'s precondition combined with the known structure of \stt{xs} is enough to \textit{partially evaluate} in a \textit{symbolic} way the body of the function, yielding a much simpler expression which in turn makes the postcondition much easier to verify. Before we discuss this idea in greater details, let's look at how one would "manually" prove correct the above program:

\begin{enumerate}

\item Let's consider the call to \stt{insert} in the \stt{test} function:

\begin{ShortCode}{PureScala}
insert(xs, map)
\end{ShortCode}

\item We start by inlining the definition of \stt{xs}:

\begin{ShortCode}{PureScala}
insert(("a", x) :: ("b", y) :: Nil, map)
\end{ShortCode}

\item We then unfold the definition of \stt{insert}:

\begin{ShortCode}{PureScala}
foldLeft(("a", x) :: ("b", y) :: Nil, map) {
  case (acc, (k, v)) if !acc.contains(k) => acc.updated(k, v)
  case (acc, _)                          => acc
}
\end{ShortCode}

\item We now unfold the definition of \stt{foldLeft}:

%The idea here is that a recursive function must contain a \textit{guarded} recursive call to be terminating, as it would otherwise call itself recursively indefinitely and thus not terminate (we discuss termination in more detail in \RefSec{termination}). We can thus look at the function's body, and see whether it contains a conditional expression whose condition can be reduced to a boolean literal under the current path condition. If that is not the case, we cannot safely unfold the function and we stop here. Otherwise, we can replace the conditional expression by the appropriate branch, and evaluate the resulting expression under the new path condition induced by the condition. As long as the function is terminating, this process will terminate as we are either going to end up with a branch that does not contain a recursive call, or we will not be able to evaluate the condition to a boolean value and will thus not proceed further.\\

%In the case of \stt{foldLeft}, there is indeed such a conditional expression, and under the current path condition, we are able to evaluate \stt{list.isInstanceOf[Nil]} to \stt{false} given that the path condition contains \stt{list = Cons("a" -> 1, ...)}. We can thus unfold it, replace the "if-then-else" expression by its "else" branch, and continue:

\begin{ShortCode}{PureScala}
val f = {
  case (acc, (k, v)) if !acc.contains(k) => acc.updated(k, v)
  case (acc, _)                          => acc
}

(("a", x) :: ("b", y) :: Nil) match {
  case Nil     => map
  case x :: xs => foldLeft(xs, f(z, x))(f)
}
\end{ShortCode}

For legibility, we have assigned the supplied match expression to a variable instead of inlining it straight away.

\item We select the second case of the pattern match:

\begin{ShortCode}{PureScala}
val f = {
  case (acc, (k, v)) if !acc.contains(k) => acc.updated(k, v)
  case (acc, _)                          => acc
}

foldLeft("b" -> y :: Nil, f(map, ("a", x)))(f)
\end{ShortCode}

\item We now evaluate the first two arguments of the call to \stt{foldLeft}. The first one stays as is as it is already in normal form. The second argument \InlineS{f(map, ("a", x))} becomes:

\begin{ShortCode}{PureScala}
(map, ("a", x)) match {
  case (acc, (k, v)) if !acc.contains(k) => acc.updated(k, v)
  case (acc, _)                          => acc
}
\end{ShortCode}

\item Recall the precondition of the \stt{test} function: \InlineS{!map.contains("a") && map.contains("b")}. When we inline the scrutinee into the guard of the first case, we obtain \InlineS{!map.contains("a")}, which by the aforementioned precondition we can deduce is \InlineS{true}. We thus select the first case, and inline the scrutinee within it, yielding:

\begin{ShortCode}{PureScala}
map.updated("a", x)
\end{ShortCode}

\item We are now left with this expression:

\begin{ShortCode}{PureScala}
foldLeft("b" -> y :: Nil, map.updated("a", x))(f)
\end{ShortCode}

\item We can now unfold \stt{foldLeft} one more time:

\begin{ShortCode}{PureScala}
(("b", y) :: Nil) match {
  case Nil     => map.updated("a", x)
  case x :: xs => foldLeft(xs, f(z, x))(f)
}
\end{ShortCode}

\item Once again, we recurse in the second case of the match expression:

\begin{ShortCode}{PureScala}
foldLeft(Nil, f(map.updated("a", x), ("b", y)))(f)
\end{ShortCode}

\item We now unfold the definition of \stt{f} in \InlineS{f(map.updated("a", x), ("b", y))}, yielding:

\begin{ShortCode}{PureScala}
(map.updated("a", x), ("b", y)) match {
  case (acc, (k, v)) if !acc.contains(k) => acc.updated(k, v)
  case (acc, _)                          => acc
}
\end{ShortCode}

\item Recall once again the precondition of the \stt{test} function: \InlineS{!map.contains("a") && map.contains("b")}. This time, the guard reads as \InlineS{!map.contains("b")}, which by precondition we can deduce is \InlineS{false}. We thus select the second case, and inline the scrutinee within it, yielding:

\begin{ShortCode}{PureScala}
map.updated("a", x)
\end{ShortCode}

\item We are now left with this expression:

\begin{ShortCode}{PureScala}
foldLeft(Nil, map.updated("a", x))(f)
\end{ShortCode}

\item We can now unfold \stt{foldLeft} one last time:

\begin{ShortCode}{PureScala}
Nil match {
  case Nil     => map.updated("a", x)
  case x :: xs => foldLeft(xs, f(z, x))(f)
}
\end{ShortCode}

\item This time, we recurse in the first case, which leaves us with:

\begin{ShortCode}{PureScala}
map.updated("a", x)
\end{ShortCode}

\item At last, we substitute this expression for the call to \stt{insert} within \stt{test}'s body, resulting in:

\begin{ShortCode}{PureScala}
def test(map: Map[String, Int], x: Int, y: Int): (Int, Map[String, Int]) = {
  require(!map.contains("a") && map.contains("b"))

  val xs  = ("a", x) :: ("b", y) :: Nil
  val res = map.updated("a", x)

  res("a") == x && res("b") == map("b")
} holds
\end{ShortCode}

\item This expression cannot be reduced further, as \stt{map} is abstract and \stt{updated} is a special language construct which can only be evaluated when applied to a concrete, finite map.

\item If one knows the semantics of \stt{Map}, it becomes fairly obvious that the postcondition is valid, for any initial value of \stt{map}, \stt{x} and \stt{y}.

\end{enumerate}

We want to draw the reader's attention to the fact that the actual values \stt{x} and \stt{y} did not play any role in this process. Moreover, while the exact content of the \stt{Map} underlying the \stt{map} variable was unknown, we knew enough about it from the precondition of \stt{test} to successfully reduce the program to a simple expression. We formalize this whole process in the next section.

\subsection{Symbolic Partial Evaluation}

Let's first get a couple of definitions out of the way:

\begin{itemize}
\item \textit{Partial evaluation} \cite{Jones:1993:PEA:153676} is the process of executing a program in the presence of partial inputs, effectively specializing it  program that is more performant or easier to reason about than the initial one.
\item \textit{Symbolic evaluation} \cite{King:1970:PV:905403} is the process of gathering knowledge about symbolic values in a program by executing it, in order to verify whether or not a given program satisfies some properties, such as the absence of divisions by zero, or the preservation of some invariant during execution \cite{DBLP:journals/corr/BaldoniCDDF16}.
\item A \textit{path condition} is a quantifier-free formula in conjunctive normal form which encodes the knowledge about the symbolic values encountered so far that the evaluator has gathered along the way.
\end{itemize}

Combining both techniques into a single evaluation procedure, ie. a procedure which partially evaluates a program with symbolic inputs while maintaining a \textit{path condition}, has been shown to increase both performance and reasoning abilities of verifications systems in some cases \cite{partialsym}. We call such a procedure a \textit{symbolic partial evaluator}. The key benefit of this technique is that, whenever the evaluator encounters a boolean expression while evaluating a program, it can make use of the path condition to hopefully determine whether the expression is \InlineS{true} or \InlineS{false}.\\

\RefCode{lst:PC} shows a simple program annotated with the current path condition at various points of execution. This path condition enables the partial evaluator to reduce the whole expression to the \InlineS{else} branch of the conditional expression  because, under the path condition at step 2, the condition \InlineS{x > 0} is provably \InlineS{false}.

\begin{Code}{PureScala}{lst:PC}{Program annotated with path conditions and result of its symbolic partial evaluation}
// Expression before evaluation:
{
  // 1. PC = true
  assume(x <= 0)
  // 2. PC = x <= 0
  if (x > 0) {
    // 3. PC = x <= 0 && x > 0
    x
  } else {
    // 4. PC = x <= 0 && !(x > 0)
    -x
  }
}

// Resulting expression after evaluation:
{
  assume(x <= 0)
  bar(-x)
}
\end{Code}

\subsection{Semantics}

We subsequently denote the path condition by $\Delta$, an boolean expression $e$ that  evaluates to \InlineS{true} under $\Delta$ by $e \in \Delta$. and a variable $v$ that is bound to an expression $e$ under $\Delta$ by $v \mapsto_\Delta e$. We will not delve into the details of how to decide whether a given condition is satisfiable under some path condition, but a reasonable although much too simplistic approximation would be to maintain a set of expressions and simply testing for membership. The actual implementation found in Inox (which predates our work) is much more complex and powerful implementation of this very idea. Moreover, we denote the fact that an expression $e$ evaluates to an expression $e'$ under a path condition $\Delta$ by $\lb{e}{\Delta} \longrightarrow e'$. Given $c, v$ two expressions, and \stt{x} a variable, we note $\Delta \cup c$ the addition of $c$ as a conjunct to the path condition $\Delta$, and $\Delta \uplus x \mapsto v$ the addition of the binding \stt{val x = $v$}. At last, the fact that an expression $e$ can be simplified to a boolean value under a path condition $\Delta$ is captured by $\stt{e} \Downarrow \Delta$. \RefFig{fig:symbolicsem} shows the operation semantics followed by our implementation, expressed in those terms. \\

\subsubsection*{Evaluation of Boolean expressions}

To determine the value of an expression $c$ of type \stt{Boolean}, the evaluator proceeds as follows:

\begin{enumerate}
\item If $c$ is a boolean literal, the evaluator returns $c$.
\item Otherwise, it checks whether the  formula $\Delta_{CNF} \implies c$ is valid, where $\Delta_{CNF}$ is the CNF formula corresponding to the path condition $\Delta$:
\begin{enumerate}
\item If it is valid, the evaluator returns \InlineS{true}.
\item Otherwise, it checks whether the formula $\Delta_{CNF} \implies \neg\,c'$ is valid, in which case it returns \InlineS{false}.
\item If none are valid, the expression goes through the other evaluation rules based on its structure.
\end{enumerate}
\end{enumerate}

\subsubsection*{Evaluation of conditional expressions}

When encountering a conditional expression $E = \stt{if ($c$) $t$ else $e$}$, under a path condition $\Delta$, the evaluator proceeds as follows:

\begin{enumerate}
\item It partially evaluates $c$, resulting in an expression $c'$.
\item If $c'$ is the boolean literal \InlineS{true}, it recurses into the \stt{then} branch of the conditional expression under the path condition $\Delta \cup c'$.
\item If $c'$ is the boolean literal \InlineS{false}, it recurses into the 
\stt{else} branch under the path condition $\Delta \cup \neg\,c'$.
\item If $c'$ is not a literal, it evaluates both branches under their respective path conditions. We denote the result of their evaluation respectively by $t'$ and $e'$. It then returns the expression \stt{if ($c'$) $t'$ else $e'$}.
\end{enumerate}

\subsubsection*{Evaluation of pattern matches}

Pattern matches are converted to an equivalent conditional expression with explicit type checks, casts, and field accesses, before being fed back to the evaluator.

\subsubsection*{Evaluation of function invocations}



\begin{figure}[htb]
\begin{framed}

\begin{equation}
\dfrac{
  v \mapsto_\Delta e
}{
  \lb{v}{\Delta} \longrightarrow e
}
\end{equation}
 
\begin{equation}
\dfrac{
  e \in \Delta
}{
  \lb{e}{\Delta} \longrightarrow \stt{true}
}
\end{equation}

\begin{equation}
\dfrac{
  \neg\, e \in \Delta
}{
  \lb{e}{\Delta} \longrightarrow \stt{false}
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{e}{\Delta} \longrightarrow e'
}{
  \lb{\lambda x_1, \ldots, x_n.\, e}{\Delta} \longrightarrow \lambda x_1, \ldots, x_n.\, e'
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{\neg\,l \stt{ || } r}{\Delta} \longrightarrow e'
}{
  \lb{\stt{$l$ ==> $r$}}{\Delta} \longrightarrow e'
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{e_1}{\Delta} \longrightarrow \stt{false}
}{
  \lb{\stt{$e_1$ \&\&\,\ldots\,\&\& $e_n$}}{\Delta} \longrightarrow \stt{false}
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{e_1}{\Delta} \longrightarrow e_1' \qquad
  \lb{\stt{$e_2$ \&\&\,\ldots\,\&\& $e_n$}}{\Delta} \longrightarrow e'
}{
  \lb{\stt{$e_1$ \&\&\,\ldots\,\&\& $e_n$}}{\Delta} \longrightarrow \stt{$e_1'$ \&\& } e' 
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{e_1}{\Delta} \longrightarrow \stt{true}
}{
  \lb{\stt{$e_1$ ||\,\ldots\,|| $e_n$}}{\Delta} \longrightarrow \stt{true}
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{e_1}{\Delta} \longrightarrow e_1' \qquad
  \lb{\stt{$e_2$ ||,\ldots\,|| $e_n$}}{\Delta} \longrightarrow e'
}{
  \lb{\stt{$e_1$ ||,\ldots\,|| $e_n$}}{\Delta} \longrightarrow \stt{$e_1'$ || } e'
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{c}{\Delta} \longrightarrow \stt{true}
}{
  \lb{\stt{if ($c$) $t$ else $e$}}{\Delta} \longrightarrow \lb{t}{\Delta \cup c}
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{c}{\Delta} \longrightarrow \stt{false}
}{
  \lb{\stt{if ($c$) $t$ else $e$}}{\Delta} \longrightarrow \lb{e}{\Delta \cup \neg \,c}
}
\end{equation}

%\begin{equation}
%\dfrac{
%  \lb{c}{\Delta} \longrightarrow c' \qquad
%  \lb{t}{\Delta \cup c'} \longrightarrow t' \qquad
%  \lb{e}{\Delta \cup \neg c'} \longrightarrow e' \qquad
%  t' = e'
%}{
%  \lb{\stt{if ($c$) $t$ else $e$}}{\Delta} \longrightarrow t'
%}
%\end{equation}

\begin{equation}
\dfrac{
  \lb{c}{\Delta} \longrightarrow c' \qquad
  \lb{t}{\Delta \cup c'} \longrightarrow t' \qquad
  \lb{e}{\Delta \cup \neg\, c'} \longrightarrow e' \qquad
%  t' \not= e'
}{
  \lb{\stt{if ($c$) $t$ else $e$}}{\Delta} \longrightarrow \stt{if ($c'$) $t'$ else $e'$}
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{p}{\Delta} \longrightarrow \stt{true} \qquad
  \lb{e}{\Delta} \longrightarrow e'
}{
  \lb{\stt{assume($p$); $e$}}{\Delta} \longrightarrow e'
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{p}{\Delta} \longrightarrow \stt{false} \qquad
  \lb{e}{\Delta} \longrightarrow e'
}{
  \lb{\stt{assume($p$); $e$}}{\Delta} \longrightarrow \stt{assume(false); $e'$}
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{p}{\Delta} \longrightarrow p' \qquad
  \lb{e}{\Delta \cup p'} \longrightarrow e'
}{
  \lb{\stt{assume($p$); $e$}}{\Delta} \longrightarrow
  \stt{assume($p'$); $e'$}
}
\end{equation}

\end{framed}
\vspace{-10pt}
\caption{Operational semantics of the symbolic partial evaluator \label{fig:symbolicsem}}
\end{figure}

\begin{figure}[htb]\ContinuedFloat
\centering
%\begin{adjustwidth}{-1mm}{-1cm}
\begin{framed}


\begin{equation}
\dfrac{
  \stt{T$_2$:\,ADTType} \qquad
  \neg \stt{isSort(T$_2$)}
}{
  \lb{\stt{C(T$_1$, $a_1, \ldots, a_n$).isInstanceOf[T$_2$]}}{\Delta}
  \longrightarrow \stt{T$_1$.id == T$_2$.id}
}
\end{equation}

\begin{equation}
\dfrac{
  \stt{T:\,ADTType} \qquad
  \stt{isSort(T)}
}{
  \lb{\stt{$e$.isInstanceOf[T]}}{\Delta} \longrightarrow \stt{true}
}
\end{equation}

\begin{equation}
\dfrac{
  \stt{T:\,ADTType} \qquad
  \lb{e}{\Delta} \longrightarrow e' \qquad
  \stt{isInstanceOf(e', T, $\Delta$) == Some($b$)}
}{
  \lb{\stt{$e$.isInstanceOf[T]}}{\Delta} \longrightarrow b
}
\end{equation}

\begin{equation}
\dfrac{
  \stt{T:\,ADTType} \qquad
  \lb{e}{\Delta} \longrightarrow e' \qquad
  \stt{isInstanceOf($e'$, T, $\Delta$) == None}
}{
  \lb{\stt{$e$.isInstanceOf[T]}}{\Delta} \longrightarrow \stt{$e'$.isInstanceOf[T]}
}
\end{equation}

\begin{equation}
\dfrac{
  \stt{T:\,ADTType}
}{
  \lb{\stt{$e$.asInstanceOf[T]}}{\Delta} \longrightarrow \stt{$\lb{e}{\Delta}$.asInstanceOf[T]}
}
\end{equation}

\begin{equation}
\dfrac{
  \stt{$e$.getType} = \stt{MatchExpr} \quad
  \lb{\stt{matchToIfThenElse($e$)}}{\Delta} \longrightarrow e'
}{
  \lb{e}{\Delta} \longrightarrow e'
}
\end{equation}

\end{framed}
\vspace{-10pt}
\caption{Operational semantics of the symbolic partial evaluator \label{fig:symbolicsem}}
\end{figure}

%------------------------------------------------------------------------

\begin{landscape}
\begin{figure}[htb]\ContinuedFloat
\centering
%\begin{adjustwidth}{-1mm}{-1cm}
\begin{framed}

\begin{equation}
\dfrac{
%  \text{\TODO{This is overly simplistic}}
}{
  \lb{\stt{let x:\,T = $v$ in $e$}}{\Delta} \longrightarrow
  \lb{e[\stt{x}/\stt{$v$}]}{\Delta}
}
\end{equation}

%\begin{equation}
%\dfrac{
%  e = \stt{let x:\,T = if ($c_1$) $t_1$ else $e_1$ in if ($c_2$) $t_2$ else $e_2$}
%  \qquad c_ 1 = c_2
%}{
%  \lb{e}{\Delta} \longrightarrow
%  \lb{\stt{if ($c_1$) let x:\,T = $t_1$ in $t_2$ else let x:\,T = $e_1$ in $e_2$}}{\Delta}
%}
%\end{equation}

\begin{equation}
\dfrac{
  \lb{f}{\Delta} \longrightarrow \lambda \stt{x$_1$:\,T$_1$,\ldots,x$_n$:\,T$_n$.\,$b$}
  \qquad
  \lb{e_i}{\Delta} \longrightarrow e_i',\, i \in \{1 \ldots n\}
}{
  \lb{f(e_1,\ldots,e_n)}{\Delta} \longrightarrow
  \lb{b[\stt{x}_1/e_1',\ldots,\stt{x}_n/e_n']}{\Delta}
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{f}{\Delta} \longrightarrow f' \qquad
  \lb{e_i}{\Delta} \longrightarrow e_i',\, i \in \{1 \ldots n\}
}{
  \lb{f(e_1,\ldots,e_n)}{\Delta} \longrightarrow
  f'(e_1', \ldots, e_n')
}
\end{equation}

\begin{equation}
\dfrac{
 \neg\,\stt{f.isRecursive} \quad
 \stt{f.params} = \langle \stt{x}_1, \ldots, \stt{x}_n \rangle \quad
 \lb{e_i}{\Delta} \longrightarrow e_i',\, i \in \{1 \ldots n\} \quad
 \lb{\stt{f.pre($e_1',\ldots,e_n'$)}}{\Delta} \longrightarrow \stt{true}
}{
  \lb{\stt{f}(e_1,\ldots,e_n)}{\Delta} \longrightarrow
  \lb{\stt{f.body}[\stt{x}_1/e_1',\ldots,\stt{x}_n/e_n']}{\Delta}
}
\label{fig:symbolicsem:fi1}
\end{equation}

\begin{equation}
\dfrac{
 \stt{id.body} \Downarrow \Delta \uplus \{\,\stt{x}_i \mapsto e_i'\,|\, 1 \leq i \leq n\,\}
 \quad
 \stt{id.params} = \langle \stt{x}_1, \ldots, \stt{x}_n \rangle
 \quad
 \lb{e_i}{\Delta} \longrightarrow e_i',\  i \in \{1 \ldots n\}
 \quad
 \lb{\stt{f.pre($e_1',\ldots,e_n'$)}}{\Delta} \longrightarrow \stt{true}
}{
  \lb{\stt{id}(e_1,\ldots,e_n)}{\Delta} \longrightarrow
  \lb{\stt{id.body}[\stt{x}_1/e_1',\ldots,\stt{x}_n/e_n']}{\Delta}
}
\label{fig:symbolicsem:fi2}
\end{equation}

\begin{equation}
\dfrac{
 \lb{e_i}{\Delta} \longrightarrow e_i',\, i \in \{1 \ldots n\}
}{
  \lb{\stt{id}(e_1,\ldots,e_n)}{\Delta} \longrightarrow
  \stt{id}(e_1',\ldots,e_n')
}
\label{fig:symbolicsem:fi3}
\end{equation}

\begin{equation}
\dfrac{
  (\stt{cons}, (e_1, \ldots, e_n)) = \stt{deconstruct(e)} \quad
  \lb{e_i}{\Delta} \longrightarrow e_i',\, i \in \{1 \ldots n\}
}{
  \lb{e}{\Delta} \longrightarrow \stt{cons}(e_1', \ldots, e_n')
}
\end{equation}

\begin{equation}
\dfrac{
 e = \stt{if ($c$) $t_1$ else $t_2$} \quad
 \lb{c}{\Delta} \longrightarrow r \quad
 r \in \{\stt{true}, \stt{false}\}
}{
  \stt{e} \Downarrow \Delta
}
\end{equation}

\end{framed}
\vspace{-10pt}
\caption{Operational semantics of the symbolic partial evaluator \label{fig:symbolicsem}}
\end{figure}
\end{landscape}

\subsection{Implementation}

We have implemented the symbolic partial evaluator described above within Stainless\footnote{\url{https://github.com/romac/stainless/tree/sym-partial-eval}} in about 900 lines of code, leveraging Inox to check for the validity of the formulas underlying the path condition.\\

In order to invoke the partial evaluator on a function definition, a user must supply the new \stt{--partial-eval} flag and annotate the function with the \stt{@partialEval} annotation. Any such function will then be partially evaluated, and its body will be substituted by the resulting expression. Enabling the \stt{partial-eval} debug section instructs Stainless to print the result of the evaluation. This effectively enable users to use Stainless as a symbolic partial evaluator for PureScala program.

\subsection{Case Study: Key-value Store Algebra}
\label{symcases}

In \RefCode{lst:symkvstore}, we define a monadic domain-specific language to manipulate a key-value store, along with a tracing interpreter which maps the operations over a PureScala \stt{Map}. A simple program which makes use of this DSL to insert a list of concrete values into the store is shown in \RefCode{lst:symkvstoreinv}. Without additional lemmas, Stainless is unfortunately unable to verify the postcondition of the \stt{result} function. On the other hand, turning on the partial evaluator turns the associated verification condition into a much more concrete form, which in turns allow the verification to promptly go through. We will note that, although the exact amount of \textit{fuel} we give to the interpreter is unknown, the precondition of the \stt{result} function constrains it to be greater than 10. Because the program expressed in that DSL requires less than 10 steps to be fully interpreted, the evaluator is able to reduce it to normal form, something which would not be possible with a non-symbolic partial evaluator.

\begin{Code}{PureScala}{lst:kvvc}{Partially evaluated verification condition}
val (res, trace) = (
  map.updated("foo", "bar").updated("toto", "tata")("foo"),
  Get("foo") :: Put("toto", "tata") :: Put("foo", "bar") :: init
)

res == Some("bar") &&
trace.take(3) == Get("foo") :: Put("toto", "tata") :: Put("foo", "bar") :: Nil()
\end{Code}

\begin{Code}{PureScala}{lst:symkvstoreinv}{Example program}
def insert(kvs: List[(String, String)])(after: Op): Op = kvs match {
  case Nil() => after
  case Cons((k, v), rest) => put(k, v) { () => insert(rest)(after) }
}

val xs = List("foo" -> "bar", "toto" -> "tata")
val program = insert(xs) {
  get("foo") { foo =>
    pure(foo)
  }
}

@partialEval
def result(map: Map[String, String], init: List[Label], fuel: BigInt) = {
  require(fuel > 10)
  interpret(program)(map, init, fuel)
} ensuring { case (res, trace) => prop(res, trace) }

@inline
def prop(res: Option[String], trace: List[Label]) = {
  res == Some("bar") &&
  trace.take(3) == List(
    Label.Get("foo"),
    Label.Put("toto", "tata"),
    Label.Put("foo", "bar")
  )
}
\end{Code}

\begin{landscape}
\begin{Code}{PureScala}{lst:symkvstore}{Key-value store implementation}
sealed abstract class Label
object Label {
  case class Get(key: String)                extends Label
  case class Put(key: String, value: String) extends Label
}

sealed abstract class Op
case class Pure(value: Option[String])                     extends Op
case class Get(key: String, next: Option[String] => Op)    extends Op
case class Put(key: String, value: String, next: () => Op) extends Op

def get(key: String)(next: Option[String] => Op): Op    = Get(key, next)
def put(key: String, value: String)(next: () => Op): Op = Put(key, value, next)
def pure(value: Option[String]): Op                     = Pure(value)

def interpret(op: Op)(kv: Map[String, String], trace: List[Label], fuel: BigInt): (Option[String], List[Label]) = {
  require(fuel >= 0)
  decreases(fuel)

  op match {
    case Pure(value) =>
      (value, trace)

    case Get(key, next) if fuel > 0 =>
      interpret(next(kv.get(key)))(kv, Label.Get(key) :: trace, fuel - 1)

    case Put(key, value, next) if fuel > 0 =>
      interpret(next())(kv.updated(key, value), Label.Put(key, value) :: trace, fuel - 1)

    case _ =>
      (None(), trace)
  }
}
\end{Code}
\end{landscape}

\subsection{1st Futamura Projection}

Let us consider the case where one were to define a language, implement an interpreter for it in PureScala, and then write a program in this language. One could then partially evaluate the interpreter applied to the program, while keeping the inputs and I/O operations abstract. The resulting expression could then be seen as a "compiled" version of the original program, represented as a PureScala program, which can be linked to a small runtime and compiled to a lower-level languageÂ using the infrastructure provided by the Scala language itself, PureScala being a strict subset of Scala.\\

The technique of partially evaluating an interpreter over a known program is known as the \textit{1st Futamura projection} \cite{futamura}, and can theoretically be applied to the partial evaluator itself, yielding a compiler (the 2nd projection) or even a converter from any interpreter to a compiler (3rd projection).\RefCode{lst:symevalex} features an example involving an interpreter for a simple language with variables, arithmetic expressions and an I/O operation.

\begin{Code}{PureScala}{lst:symevalex}{Implementation an interpreter for a simple language}
sealed trait Expr
case class Var(name: String)     extends Expr
case class Num(value: Int)       extends Expr
case class Add(l: Expr, r: Expr) extends Expr
case class Mul(l: Expr, r: Expr) extends Expr
case class Rand(max: Expr)       extends Expr

case class Context(bindings: List[(String, Expr)]) {
  def contains(name: String): Boolean =
  	apply(name).isDefined

  def apply(name: String): Option[Expr] =
    bindings.find(_._1 == name).map(_._2)
}

implicit val state = Random.newState

@extern
def random(max: Int): Int = {
  Random.nextInt(max)
}

case class Error(msg: String)
def interpret(expr: Expr, ctx: Context): Either[Error, Int] = {
  expr match {
    case Num(value) => Right(value)

    case Var(name)  => ctx(name) match { 
      case None()      => Left(Error("Unbound variable: " + name))
      case Some(value) => interpret(value, ctx)
    }

    case Add(l, r)  => for {
      le <- interpret(l, ctx)
      re <- interpret(r, ctx)
    } yield le + re

    case Mul(l, r)  => for {
      le <- interpret(l, ctx)
      re <- interpret(r, ctx)
    } yield le * re

    case Rand(max) =>
      interpret(max, ctx).map(random(_))
  }
}
\end{Code}

\begin{Code}{PureScala}{lst:symevalex}{"Compilation" of a simple program}
val program: Expr = Mul(Num(10), Add(Var("x"), Rand(Num(42))))

@partialEval
def compiled(ctx: Context): Int = {
  require(ctx contains "x")
  interpret(program, ctx).get.            // 10 * (ctx("x") + random(42))
}

@partialEval
def test(y: Int) = {
  val ctx = Context(Map("y" -> Num(y)))
  interpret(program, ctx)                 // Left(Error("Unbound variable: x"))
} ensuring { _.isLeft }
\end{Code}

\subsection{Termination}

As Stainless comes with a powerful termination checker, we suggest to only enable the partial evaluator on functions which have been proved terminating by Stainless. As an additional measure, we have bounded the maximum number of evaluation steps that can be performed. This ensure that, should one still run the evaluator on a non-termination function, Stainless will not hang or crash.\\

\begin{Code}{PureScala}{lst:nontermloop}{Example of non-terminating program}
def bar(xs: List[BigInt]): List[BigInt] = {
  if (xs.isEmpty) Nil() else bar(Cons(xs.head, xs))
}

@partialEval
def test = {
  bar(List(1)) == Nil()
} holds
\end{Code}

Moreover, we argue that, when ran over a program that Stainless deems terminating, the  evaluator terminates as well. We note that, at point in the pipeline, the only source of non-termination are calls to recursive functions. As such, because the evaluator will only unfold a function invocation when the precondition is satisfied, and when any of the following two statement is true:

\begin{enumerate}[label=(\alph*)]
\item The unfolded expression does not contain a recursive call
\item Otherwise, it is possible to determine under the current path condition whether a recursive call will be reached or not
\end{enumerate}

The understand why the second property is important, consider the program in  \RefCode{lst:tricky}. If the evaluator only looked at the outermost conditional statement to determine whether the call to \stt{tricky} in \stt{test} could be unfolded in productive way, it would end up in an infinite loop. Indeed, because \stt{n} is greater than 0 under the path condition, the \stt{then} branch of the outermost \InlineS{if} will be selected, and evaluation will continue recursively from there. Because we don't know anything about \stt{xs}, the evaluator will then speculatively evaluate both branches of the match expression, and will thus encounter another recursive call, which it will deem worthy of unfolding because, by the same reasoning,  the outermost \InlineS{if} can be reduced to its \stt{then} branch. On the other hand, property (b) will forbid the evaluator to unfold \stt{tricky} because it is not possible to deduce, under the current path condition, whether or not the recursive call will be reached.

On the other hand, if we supply \stt{tricky} with a partially known list, such as in the function \stt{test2}, \stt{tricky} will still be unfolded until the function is eventually applied to the abstract list \stt{xs}.\\

While this no formal argument, we believe that these conditions are sufficient to ensure the termination of the evaluation of provably terminating programs.

\begin{Code}{PureScala}{lst:tricky}{Tricky program to evaluate without ending up in an infinite loop}
def tricky(n: Int, xs: List[Int]): Int = {
  if (n > 0) {
    xs match {
      case Nil()       => n
      case Cons(x, xs) => x + tricky(n, xs)
    }
  } else {
    0
  }
}

@partialEval
def test1(n: Int, xs: List[Int]) = {
  require(n > 0)
  tricky(n, xs) // tricky(n, xs)
}

@partialEval
def test2(n: Int, xs: List[Int]) = {
  require(n > 0)
  tricky(n, Cons(1, Cons(2, Cons(3, xs)))) // 1 + (2 + (3 + trick(n, xs)))
}
\end{Code}

Regarding termination checking itself, we have ensured that the partial evaluator cannot be enabled when checking termination in Stainless, as doing so could prevent the termination checker to itself terminate, or even yield incorrect results.

\subsection{Conclusion}

We have presented, formalized and implemented a symbolic partial evaluator for PureScala programs which:

\begin{enumerate}
\item enhances the verification capability of Stainless by allowing the system to reason about programs at a semantic level closer to those of PureScala, effectively simplifying the verification conditions then generated by the system. This in turn helped us reason about a tracing interpreter for a simple algebra over a key-value store.
\item effectively turns Stainless into a symbolic partial evaluator for PureScala programs, thanks to user-land annotations which allow users to selectively simplify parts of their programs. This allowed us to turn an interpreter for a simple programming language into a compiler from that language to PureScala.
\end{enumerate}

\subsection{Further Work}
\label{sym-further}

\subsubsection*{Nondeterministic Evaluator}

The evaluator described in this chapter is \textit{deterministic}, in the sense that its evaluation function maps one expression to exactly one expression in a deterministic way. We believe that it could be worthwhile to investigate the potential use cases of a so-called \textit{non-deterministic} evaluator. That is to say, an evaluator which, when given a single expression, would return potentially multiple results. For example, when the evaluator would be applied to an expression \stt{$s$ = if ($c$) $t$ else $e$} whose condition $c$ it is not able to evaluate to a boolean literal, it would return all the possible expressions resulting from first evaluating the condition and both branches nondeterministically. We show some pseudo-code in \RefCode{lst:nondet}.\\

One potential use case of such an evaluator that we see, when combined with a way to trigger its application in user-land code, is for implementing a symbolic \textit{partial order reduction} algorithm. In a bit more detail, the evaluator could be used to compute the set of (potentially symbolic) transitions that results from taking a step at a given (potentially symbolic) state.

\begin{Code}{PureScala}{lst:nondet}{Pseudo-code of a non-deterministc evaluator}
def ndEval(expr: Expr, pc: PC): Stream[Expr] = {
 case IfExpr(c, t, e) =>

ndEval(e, pc) == for {
  cs <- eval(c, pc)
  ts = eval(t, pc withCond c)
  es = eval(e, pc withCond not(c))
} yield ts ++ es
\end{Code}

%------------------------------------------------------------------------

\clearpage
\section{Verifiying Actor Systems}
\label{actors}

\subsection{Motivation}

Over the last few decades, many different models of concurrent computation have been discovered, such as \textit{Petri Nets}, \textit{Communicating Sequential Processes} and the \textit{$\pi$-calculus} \cite{algebraicactors}. 

Moreover, because actors do not share memory and rely on asynchronous message passing, the Actor Model is well suited to model distributed systems as well.

\subsection{A Simple Actor Model for Verification}

\subsubsection{Introduction}

\subsubsection{Implementation}
\label{actor-impl}

We now below the PureScala implementation of the model 

\subsubsection*{Message}

In our framework, messages are modelled as constructors of the \InlineS{Msg} abstract class.

\begin{ShortCode}{PureScala}
abstract class Msg
case class Hello(name: String) extends Msg
\end{ShortCode}

\vspace{-15pt}
\subsubsection*{Actor Reference}

Each actor is associated with a unique and persistent reference, modelled as an instance of the \ActorRef abstract class.

\begin{ShortCode}{PureScala}
abstract class ActorRef
case class Primary() extends ActorRef
\end{ShortCode}

\vspace{-15pt}
\subsubsection*{In-flight Messages}

In-flight messages are represented as a product of the \ActorRef of the destination actor, and the message itself.

\begin{ShortCode}{PureScala}
case class Packet(dest: ActorRef, payload: Msg)
\end{ShortCode}

\vspace{-15pt}
\subsubsection*{Actor Context}

When a message is delivered to an actor, the latter is provided with a context,
which holds a reference to itself, and a mutable list of \InlineS{Packet}s to send.

\begin{ShortCode}{PureScala}
case class ActorContext(
  self: ActorRef,
  var toSend: List[Packet]
)
\end{ShortCode}

\vspace{-15pt}
\subsubsection*{Behavior}

A behavior specifies both the current state of an actor, and how this one should 
process the next incoming message. In our framework, these are modelled as a subclass 
of the abstract class \InlineS{Behavior}, which defines a single abstract method 
\InlineS{processMsg}, to be overriden for each defined behavior.

Using the provided \InlineS{ActorContext}, the implementation of the \InlineS{processMsg}
method can both access its own reference, and register messages to be sent after the
execution of the method is complete. It is also required to return a new \InlineS{Behavior}

\begin{ShortCode}{PureScala}
abstract class Behavior {
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior
}
\end{ShortCode}

\vspace{-15pt}
\subsubsection*{Actor System}

The state of the Actor system at a given point in time is modelled as a case class, 
holding the behavior associated with each actor reference, and the list of in-flight messages between any two actors.

\begin{ShortCode}{PureScala}
case class ActorSystem(
  behaviors: CMap[ActorRef, Behavior],
  inboxes: CMap[(ActorRef, ActorRef), List[Msg]]
)
\end{ShortCode}
% trace: List[Transition]

The \InlineS{ActorSystem} class is equipped with a \InlineS{step} method, which takes 
a pair of \ActorRef as arguments, and is in charge of delivering the oldest message 
found in the corresponding inbox, and which returns the new state of the system after 
the aforementioned message has been processed.

\begin{ShortCode}{PureScala}
def step(from: ActorRef, to: ActorRef): ActorSystem
\end{ShortCode}

\subsubsection{Comparison with Akka and Akka Typed}

\subsubsection*{Akka}

Akka is a powerful Scala implementation of the Actor model, suitable for both concurrent and distributed systems. 

\subsubsection*{Akka Typed}

\subsubsection*{Notable Differences}

While we initially set to mimic the API offered by the Akka Typed library\footnote{\url{https://doc.akka.io/docs/akka/2.5.4/scala/typed.html}}, we quickly ran into some limitations of Stainless's type system. Namely, the lack of an encoding for both existential types, and various issues with the encoding of co-/contravariant class hierarchies. While some of those issues got fixed over the last few months, we have been unable to provide a typed API similar in spirit to Akka Typed. For lack of time, we have decided to go with the untyped API described in \RefSec{actor-impl}.\\

Another notable difference between our model and both the one implemented in Akka\footnote{\url{https://doc.akka.io/docs/akka/current/general/message-delivery-reliability.html}}, is that we rely on \textit{exactly-once} delivery of messages. We experimented with a weaker model that only relied on \textit{at-most-once} delivery but it quickly became clear that the amount of work needed to verify the very same systems we describe below would be too much in the context of this project.

% (archive: \url{http://archive.is/XU8if})}

\subsection{Operational Semantics}
\label{semantics}

We formulate the small-step operational semantics of our Actor model in 
\RefFig{fig:opsem}, where $s: \stt{ActorSystem}$ is an Actor system,
$m: \stt{Msg}$ is a message,
$n, n_{to}, n_{from}: \stt{ActorRef}$ are references,
$b, b': \stt{Behavior}$ are behaviors,
$ps: \stt{List[Packet]}$ a list of packets to send,
% $t: \stt{Transition}$ is a transition,
$c: \stt{ActorContext}$ is a context,
and $\emptyset_n: \stt{ActorContext}$ is the empty context for an actor whose
self-reference is $n$, defined as $\emptyset_n := \stt{ActorContext}(n, \stt{Nil})$.

\begin{figure}[!h]
\begin{framed}
 
\begin{equation}
\dfrac{
  \not\exists m \in \stt{$s$.inboxes}(n_{from}, n_{to})
}{
  \stt{$s$.step}(n_{from}, n_{to}) \leadsto \stt{s}
}
\tag{STEP-NOMSG}
\end{equation}

\vspace{10pt}
\begin{equation}
\dfrac{
  \exists m \in \stt{$s$.inboxes}(n_{from}, n_{to}) \qquad
  \stt{$s$.deliverMsg}(n_{to}, n_{from}, m) \leadsto (b, ps, t)
}{
  \stt{$s$.step}(n_{from}, n_{to}) \leadsto s \uplus (n_{to} \mapsto b, \ldots, t)
}
\tag{STEP}
\end{equation}

\vspace{10pt}
\begin{equation}
\dfrac{
  \stt{$s$.behaviors($n_{to}$).processMsg}(m, \emptyset_{n_{to}}) \leadsto (b, c) 
}{
  \stt{$s$.deliverMsg}(n_{to}, n_{from}, m) \leadsto (b, \stt{$c$.toSend}, t)
}
\tag{DELIVER-MSG}
\end{equation}

\vspace{10pt}
\begin{equation}
\dfrac{
  \stt{$b$.processMsg}(m, \emptyset_{n_{to}}) = i_1 ::\, \ldots ::\,i_n ::\, b' ::\,\stt{Nil} \qquad
  \langle i_1 ::\, \ldots ::\,i_n ::\,\stt{Nil}, \emptyset_{n_{to}} \rangle \longrightarrow c
}{
   \stt{$b$.processMsg}(m, \emptyset_{n_{to}}) \leadsto (b', c)
}
\tag{PROCESS-MSG}
\end{equation}

\vspace{10pt}
\begin{equation}
\dfrac{\empty}{
   \langle \stt{Nil}, c \rangle \longrightarrow c
}
\tag{I-NIL}
\end{equation}

\vspace{10pt}
\begin{equation}
\dfrac{
  \langle i, c \rangle \longrightarrow c'
}{
  \langle \stt{$i ::\,is$}, c \rangle \Rightarrow \langle is, c' \rangle
}
\tag{I-CONS}
\end{equation}

\vspace{10pt}
\begin{equation}
\dfrac{
  \empty
}{
  \langle n\ \stt{!}\ m, c \rangle \longrightarrow (b',\ \stt{$c$.copy(toSend $\mapsto$ ($n$, $m$) $::$ $c$.toSend)})
}
\tag{I-SEND}
\end{equation}

\end{framed}
\vspace{-10pt}
\caption{Operational semantics\label{fig:opsem}}
\end{figure}

\subsection{Proving Invariants}
\label{invariants}

After having defined an Actor system with our framework, one might want to verify that this system preserves some invariant between each step of its execution. That is to say, for an \InlineS{ActorSystem} $s$, any two \ActorRef $n, m$, and an invariant \InlineS{inv: ActorSystem $\ \to\ $ Boolean}, if $\texttt{inv}(s)$ holds, then $\texttt{inv}(s\texttt{.step}(n, m))$ should hold as well. We express this property more formally in \RefFig{fig:stepinvariant}. Because we are essentially doing a proof by induction over execution steps here, one needs also to ensure the invariant holds for some initial system. These two properties can be easily expressed in PureScala, as shown in \RefCode{lst:preserveInv}.

\begin{figure}[!h]
$$\forall s: \stt{ActorSystem},\, n: \stt{ActorRef},\, m: \stt{ActorRef}.\ \stt{inv($s$)} \implies \stt{inv($s$.step($n, m$))}$$
\vspace{-20pt}
\caption{Invariant preservation property\label{fig:stepinvariant}}
\end{figure}

\begin{Code}{PureScala}{lst:preserveInv}{Invariant preservation theorem in PureScala}
def inv(s: ActorSystem): Boolean = {
  /* ... */
}

def preserveInv(s: ActorSystem, n: ActorRef, m: ActorRef): Boolean = {
  require(inv(s))
  inv(s.step(n, m))
} holds

def initial: ActorSystem = /* ... */

def initialInv: Boolean = {
  invariant(initial)
} holds
\end{Code}

\subsection{Case studies}
\label{casestudies}

\subsubsection{Increment-based Replicated Counter}
\label{repcounterinc}

As a first and very simple case study, we will study an Actor system which models a replicated counter, which can only be incremented by one unit. This system is composed of two actors, a primary counter whose reference is \stt{Primary()},and a backup counter whose reference is \stt{Backup()}. Each of these reference is associated with a behavior: the primary counter reference with an instance of \stt{PrimaryB}, and the backup counter reference with an instance of \stt{BackupB}, both of which hold a positive integer, representing the value of the counter. Whenever the primary actor receives the message \stt{Inc()}, it forwards that message to the backup actor, and returns a new instance of \stt{PrimaryB} with the counter value incremented by one. When the backup actor receives the \stt{Inc()} message, it too returns a new instance of \stt{BackupB} with the counter value incremented by one. The corresponding PureScala implementation can be found in \RefCode{lst:ReplicatedCounterInc}.\\

We now want to verify that the following properties stay valid between at execution step: the \stt{Backup()} actor does not send itself any messages, both actors have the proper corresponding behavior, the value of the primary counter is equal to the value of the backup counter added to the number of \stt{Inc()} messages that are yet to be delivered to the backup actor. \RefCode{lst:repcounterincinv} presents the corresponding invariant, while \RefCode{lst:repcounterincthm} shows the invariant preservation theorem that we want to prove.

\begin{Code}{PureScala}{lst:ReplicatedCounterInc}{Increment-based replicated counter implementation}
case class Primary() extends ActorRef
case class Backup()  extends ActorRef

case class Inc() extends Msg

case class PrimaryB(counter: BigInt) extends Behavior {
  require(counter >= 0)

  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case Inc() =>
      Backup() ! Inc()
      PrimaryB(counter + 1)
  }
}

case class BackupB(counter: BigInt) extends Behavior {
  require(counter >= 0)

  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case Inc() => BackupB(counter + 1)
  }
}
\end{Code}

\begin{Code}{PureScala}{lst:repcounterincinv}{Increment-based replicated counter invariant}
def invariant(s: ActorSystem): Boolean = {
  s.inboxes((Backup(), Backup())).isEmpty && {
    (s.behaviors(Primary()), s.behaviors(Backup())) match {
      case (PrimaryB(p), BackupB(b)) =>
        p.value == b.value + s.inboxes(Primary() -> Backup()).length
      case _ => false
    }	
  }
}
\end{Code}

\begin{Code}{PureScala}{lst:repcounterincthm}{Replicated counter theorem (increment)}
def preserveInv(s: ActorSystem, n: ActorRef, m: ActorRef): Boolean = {
  require(invariant(s))
  invariant(s.step(n, m))
} holds
\end{Code}

\subsubsection{Delivery-based Replicated Counter}

\RefCode{lst:ReplicatedCounterDel} shows a variant of the previous case study, where instead of having the primary actor forward the \stt{Inc()} message to the backup actor, the former instead sends the latter the new value.

\begin{Code}{PureScala}{lst:ReplicatedCounterDel}{Delivery-based Replicated counter implementation}
case object Primary extends ActorRef
case object Backup  extends ActorRef

case object Inc extends Msg
case class Deliver(c: BigInt) extends Msg

case class PrimaryB(counter: BigInt) extends Behavior {
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case Inc =>
      Backup ! Deliver(counter + 1)
      PrimaryB(counter + 1)

    case _ => Behavior.same
  }
}

case class BackupB(counter: BigInt) extends Behavior {
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case Deliver(c) => BackupB(c)
    case _          => Behavior.same
  }
}
\end{Code}

The invariant now reads slightly differently, as can be seen in \RefCode{lst:ReplicatedCounterDelInv}.

\begin{Code}{PureScala}{lst:ReplicatedCounterDelInv}{Delivery-based replicated counter invariant}
def validBehaviors(s: ActorSystem): Boolean = {
  (s.behaviors(Primary), s.behaviors(Backup) match {
    case (p: PrimaryB, b: BackupB) => true
    case _                         => false
  }
}

def invariant(s: ActorSystem): Boolean = {
  validBehaviors(s)                       &&
  s.inboxes(Primary -> Primary).isEmpty   &&
  s.inboxes(Backup -> Backup).isEmpty     &&
  noMsgsToSelf(Backup -> Primary).isEmpty &&
  {
    val PrimaryB(p) = s.behaviors(Primary)
    val BackupB(b)  = s.behaviors(Backup)
    val bInbox      = s.inboxes(Primary -> Backup)

    p.value >= b.value && isSorted(bInbox) && bInbox.forall {
      case Deliver(Counter(i)) => p.value >= i
      case _                   => true
    }
  }
}
\end{Code}

\subsubsection{Lock Service}

\RefCode{lst:LockService} shows the implementation of a lock service using our framework. In this case study, an actor acts as a server holding a lock on some resource, while a number of other actors (the "agents") act as clients of the lock service, each potentially trying to acquire the lock on the resource. To model a variable number of actors with the same implementation, we define their reference as a case class parametrized by a \TODO{unique} identifier.

An obvious property we might want to prove is that, at any time, at most one of those agents thinks that it holds the lock. Additionally, we'd like to ensure that such an agent is actually the same one that the server granted the lock too. We express this property in \RefCode{lst:LockServiceInv}.

\begin{Code}{PureScala}{lst:LockService}{Lock service implementation}
case class Server() extends ActorRef
object Server {
  case class Lock(agent: ActorRef) extends Msg
  case class Unlock(agent: ActorRef) extends Msg
}

case class Agent(id: Int) extends ActorRef
object Agent {
  case object Lock   extends Msg
  case object Unlock extends Msg
  case object Grant  extends Msg
}

// The head of `agents` holds the lock, the tail are waiting for the lock
case class ServerB(agents: List[ActorRef]) extends Behavior {
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case Server.Lock(agent) if agents.isEmpty =>
      agent ! Agent.Grant
      ServerB(List(agent))

    case Server.Lock(agent) =>
      ServerB(agents :+ agent)

    case Server.Unlock(agent) if agents.nonEmpty =>
      val newAgents = agents.tail
      if (newAgents.nonEmpty) newAgents.head ! Agent.Grant
      ServerB(newAgents)

    case _ =>
      Behavior.same
  }
}

case class AgentB(holdsLock: Boolean) extends Behavior {
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case Agent.Lock =>
      Server() ! Server.Lock(ctx.self)
      Behavior.same

    case Agent.Unlock if holdsLock =>
      Server() ! Server.Unlock(ctx.self)
      AgentB(false)

    case Agent.Grant =>
      AgentB(true)

    case _ =>
      Behavior.same
  }
}
\end{Code}

\begin{Code}{PureScala}{lst:LockServiceInv}{Lock service invariant}
def hasLock(s: ActorSystem, a: ActorRef): Boolean = {
  s.behaviors(a) match {
    case AgentB(hasLock) => hasLock
    case _ => false
  }
}

def mutex(s: ActorSystem): Boolean = forall { (a: ActorRef, b: ActorRef) =>
  (a != b) ==> !(hasLock(s, a) && hasLock(s, b))
}

def hasLockThenHead(s: ActorSystem): Boolean = forall { (ref: ActorRef) =>
  hasLock(s, ref) ==> {
    s.behaviors(Server()) match {
      case ServerB(Cons(head, _)) => head == ref
      case _ => false
    }
  }
}

def invariant(s: ActorSystem): Boolean = {
  mutex(s) && hasLockThenHead(s)
}
\end{Code}

\TODO{Lock service invariant proof}

%\subsubsection*{Leader Election}
%
%\TODO{Leader election}

%\subsubsection*{Key-value store}
%
%\TODO{KV store}

\subsection{Spawning Actors}
\label{spawn}

\subsubsection{Updating The Model}

Up until now, our framework has only been able to model Actor systems with a static topology, ie. systems where no new actors besides the ones that are statically defined can be spawned. Let's now attempt to enrich our model to account for dynamic topologies.

To this end, we modify the \ActorRef definition to include both a name and an optional field holding a reference to its parent \ActorRef if any. We also add a new constructor of the \ActorRef data type, which will be assigned to actors spawned from another actor.

\begin{ShortCode}{PureScala}
abstract class ActorRef(
  name: String,
  parent: Option[ActorRef] = None()
)

case class Child(name: String, getParent: ActorRef)
  extends ActorRef(name, Some(getParent))
\end{ShortCode}

In order for actors to spawn other actors, by specifying their name and associated 
initial behavior, we modify the \stt{ActorContext} class as follows:

\begin{ShortCode}{PureScala}
case class ActorContext(
  self: ActorRef,
  var toSend: List[Packet],
  var toSpawn: List[(ActorRef, Behavior)]
) {
  def spawn(behavior: Behavior, name: String): ActorRef = {
    val id: ActorRef = Child(name, self)
    toSpawn = toSpawn :+ (id, behavior)
    id
  }
  /* ... */
}
\end{ShortCode}

As can be seen in the listing above, the context now keeps track of the names and 
behaviors of the actors to be spawned, and provides a \stt{spawn} method which is in  charge of constructing the \ActorRef of the spawned actor, storing it along with the  behavior within the context, and returning the newly generated reference.

\subsubsection{Case Study}

\RefCode{lst:spawncode} defines a simple system with a dynamic topology, where one actor named \stt{Primary} waits for a \stt{Spawn} message to spawn a child actor, and change its behavior from \stt{BeforeB} to \stt{AfterB} in order to keep track of the reference to the child. The invariant we would to verify holds here, states that, if the \stt{Primary} actor has behavior \stt{BeforeB()}, then the behavior associated with the \ActorRef of its child actor must be \stt{Stopped}. On the other hand, if the \stt{Primary} actor has behavior \stt{AfterB(child)}, then the behavior associated with \stt{child} must be \stt{ChildB}. This test case verifies promptly, provided that the partial evaluator is enabled.

\begin{Code}{PureScala}{lst:spawncode}{}
case object Primary extends ActorRef("primary")
case object Spawn extends Msg

case class BeforeB() extends Behavior {
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case Spawn =>
      val child = ctx.spawn(ChildB(), "child")
      AfterB(child)
  }
}

case class AfterB(child: ActorRef) extends Behavior {
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case _ => Behavior.same
  }
}

case class ChildB() extends Behavior {
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case _ => Behavior.same
  }
}

def invariant(s: ActorSystem): Boolean = {
  s.behaviors(Primary) match {
    case BeforeB() =>
      s.isStopped(Child("child", Primary()))
    case AfterB(child) =>
      s.behaviors(child) == ChildB()

    case _ => false
  }
}

def theorem(s: ActorSystem, from: ActorRef, to: ActorRef): Boolean = {
  require(invariant(s))
  invariant(s.step(from, to))
} holds
\end{Code}

\subsection{Running an Actor System on Akka}
\label{akka}

While the verification of Actor systems is in itself an interesting endeavour, it is not of much use unless one is able to run these systems, potentially in a distributed environment. Thanks to the shim presented in \RefCode{lst:akkashim}, it is effectively possible run an Actor system developed with our framework on top of Akka, with only a few alterations to the original program. With this shim, the \ActorRef type is mapped to Akka's \ActorRef, while the \stt{ActorContext} now only contains the actor's self-reference, as well as the underlying Akka context. The shim also defines an actual Akka actor, parametrized by an underlying \stt{Behavior}, to which all messages of type \stt{Msg} will be delegated. The \stt{ActorSystem} class becomes abstract, and concrete subclasses need to provide it with an actual Akka system, as well as provide an implementation of its \stt{run} method. Within this method, one can spawn new top-level actors, get a reference to those, and send them messages. \RefCode{lst:akkashimex} shows such an implementation for the replicated counter described in \RefSec{repcounterinc}.

\begin{Code}{PureScala}{lst:akkashim}{Akka shim for our Actor framework}
import akka.actor

type ActorRef = actor.ActorRef

case class ActorContext(self: actor.ActorRef, ctx: actor.ActorContext)

class AkkaWrapper(var behavior: Behavior)
  extends actor.Actor with actor.ActorLogging {

  implicit val ctx = ActorContext(self, context)

  def receive = {
    case msg: Msg =>
      log.info(s"$\$${behavior}: $\$${msg}")
      behavior = behavior.processMsg(msg)

    case _ => ()
  }
}

abstract class ActorSystem(val system: actor.ActorSystem) {
  def spawn(behavior: Behavior, name: String): actor.ActorRef = {
    system.actorOf(actor.Props(new AkkaWrapper(behavior)), name = name)
  }

  def run(): Unit
}
\end{Code}

\begin{Code}{PureScala}{lst:akkashimex}{Akka shim for our Actor system framework}
@extern
object System extends ActorSystem("rep-counter-sys") {
  def run(): Unit = {
    val backup  = spawn(BackupB(0), "backup")
    val primary = spawn(PrimaryB(0, backup), "primary")

    primary ! Inc()
  }
}

@extern
def main(args: Array[String]): Unit = {
  System.run()
}
\end{Code}

\subsection{Conclusion}

\TODO{Conclusion}

\subsection{Further Work}

\subsubsection*{Real-world Case Study}

\subsubsection*{Weaker Guarantees On Message Delivery}

\subsubsection*{Name Uniqueness}

It is important to note that, within this model, actor references are not guaranteed to be unique as a user could spawn two actors with the same name. \TODO{++}

\subsection{Reasoning About Traces}

\TODO{Traces}

%\clearpage
%\section{Verification of Conflict-Free Replicated Data Types}
%\label{crdt}
%
%\textbf{\textcolor{Red}{Will only be included if time allows}}
%
%\subsection{Motivation}
%
%Because both faults and network partitions are a common occurrence in distributed systems, these often make use of data replication in order to improve reliability \TODO{citation}, which itself can lead to  consistency issues. One increasingly popular way to mitigate this problem is to model the replicated data using \textit{Conflict-free Replicated Data Types} (CRDTs) \cite{crdt} \cite{crdtstudy}. These data types come in two flavours: \textit{Commutative Replicated Data Types} (CmRDTs, or \textit{Op-based CRDTs}) and \textit{Commutative Replicated Data Types} (CvRDTs, or \textit{State-based CDRTs}).
%
%\TODO{Explain eventual consistency + both models + choice of CvRDTs}
%
%\subsection{Verifying CRDTs Implementations}
%
%\subsubsection{GCounter}
%\subsubsection{PNCounter}
%\subsubsection{GSet}
%\subsubsection{TwoPSet}
%\subsubsection{ORSet}
%
%\subsection{Conclusion}
%
%\TODO{Conclusion}

\clearpage
\section{Biparty Communication Protocols}
\label{biparty}

\subsection{Motivation}
\label{sess-mot}

Most systems made of components exchanging messages between them, such as Actor systems, do so by following a \textit{communication protocol}. A protocol is a set of rules which the components must follow when receiving, processing, and replying to a message. While it is possible to verify that a system correctly implements a given protocol, doing so is usually not trivial and often requires a sizeable amount of work, depending of course on the model one is working with. In the case of the Actor model we developed in \RefSec{actors}, in which messages are \textit{unityped}, verifying that a system followed some kind of protocol often required encoding a small type system within the invariants, for example to ensure that a message sent by an actor was of the right type. Moreover, we also had to check whether an actor would actually send a reply when it was expected of it. While being very interesting properties to verify, we would rather rely on the actual type system to catch any mistakes directly when writing the implementation.

As we have unfortunately not found a way to provide even just a typed API for our model, and do not expect to find a solution within the scope of this project, we now turn our attention to simpler, synchronous systems involving only two parties communicating over a \textit{channel} with two endpoints, one for sending messages and one for receiving them. Such a system might be an ATM and a user willing to withdraw money communicating through a screen, or a browser and a web server attempting to initialise a secure connection through a TCP socket. The protocols governing such systems that we are going to study in this chapter are called \textit{biparty communication protocols}. Such protocols have the interesting property that the description of the protocol from the viewpoint of one party is enough to deduce the protocol that must be followed from the viewpoint of the other party. The dialogue between two parties is commonly referred to as a \textit{session}.\\

As a running example for the next sections, we will consider a very simple protocol involving two parties Alice and Bob, and four messages \stt{Greet}, \stt{Hello}, \stt{Bye}, and \stt{Quit}.
From the viewpoint of Alice, the protocol is informally described as follows: Alice must send Bob either the message \stt{Quit} or \stt{Greet}. In the first case the sessions then ends, otherwise she can expect to receive either the message \stt{Bye}, ending the session, or the message \stt{Hello}, after which the session continues from the start.\\

It is important to note that, for the an implementation of such protocols to be correct, assuming an underlying reliable delivery channel, each party must both send the correct message when it is expected of them, and handle all possible messages that they can expect to receive at some point. A implementation of a party which fails to do so is deemed incorrect in that framework.

\subsection{Session Types}

Session types \cite{Honda:1998:LPT:645392.651876} provide a way to encode such protocols at the type level, thus guiding the programmer during the implementation while also guarding against mistakes such as not handling a certain message type or failing to reply to a message. Their syntax is shown in \RefFig{fig:sess-syntax}.

\begin{figure}
\begin{align*}
T\quad::=&\quad 	S
   \quad|\quad \texttt{Int}
   \quad|\quad \texttt{Boolean}
   \quad|\quad \texttt{String}
   \quad|\quad \ldots \tag*{payload}
\\
S\quad::=&\quad 	\,\&\,\{\,l_i: S_i\,\}_{i\in I}			\tag*{branching}\\
        |&\quad 	\oplus\{\,l_i: S_i\,\}_{i\in I}			\tag*{selection}\\
		|&\quad 	?T.\, S									\tag*{receive}\\
		|&\quad 	!T.\, S									\tag*{send}\\
        |&\quad		\mu_X.\, S								\tag*{recursion}\\
        |&\quad 	X  										\tag*{variable}\\
        |&\quad 	\epsilon								\tag*{termination}\\
\end{align*}
\vspace{-20pt}
\caption{Syntax of session types \label{fig:sess-syntax}}
\end{figure}

We show below the session types $S_A$ and $S_B$ corresponding to the protocol we defined in \RefSec{sess-mot}, from the viewpoint of Alice and Bob, respectively.
\begin{align*}
S_A &= \mu\alpha.\,\bigg(!\stt{Greet}.\,\Big(?\stt{Hello}.\,\alpha\ \&\ ?\stt{Bye}.\, \epsilon \Big)\ \oplus\ !\stt{Quit}.\,\epsilon \bigg)\\
S_B &= \mu\alpha.\,\bigg(?\stt{Greet}.\,\Big(!\stt{Hello}.\,\alpha\ \oplus\ !\stt{Bye}.\, \epsilon \Big)\ \&\ ?\stt{Quit}.\,\epsilon \bigg)\\
\end{align*}
\vspace{-30pt}

We draw the reader's attention to the similarity between the two types, and note that the $S_B$ reads the same as $S_A$ if one substitutes $!$ for $?$, $\oplus$ for $\&$, and vice-versa. Each type is in fact the \textit{dual} of the other, a property we formalize in \RefFig{fig:dual}.\\

\begin{figure}
{\large
\begin{align*}
\overline{\overline{S}}\qquad&::=\qquad S\\
\overline{\&\{\,l_1: S_1, \ldots, l_n: S_n\,\}}\qquad&::=\qquad\oplus\{\,l_1: \overline{S_1}, \ldots, l_n: \overline{S_n}\,\}\\
\overline{?T.\, S} \qquad&::=\qquad !T.\, \overline{S}\\
\overline{\mu\alpha.\, S} \qquad&::=\qquad \mu\alpha.\, \overline{S[\overline{\alpha}/\alpha]}\\
\overline{X} \qquad&::=\qquad X\\
\overline{\epsilon} \qquad&::=\qquad \epsilon
\end{align*}
}%
\vspace{-20pt}
\caption{Duality of session types \label{fig:dual}}
\end{figure}

\subsection{Session Types and Linearity}

Although session types were originally meant to be implemented as a separate syntactic category of types and terms to be added to the $\pi$-calculus, it has been shown that it possible to encode them directly in a calculus or language with both \textit{linear types} and \textit{variants} \cite{Wadler:2012:PS:2364527.2364568, Dardha:2012:STR:2370776.2370794}.\\

While there are many ways to perform such an encoding and provide a collection of combinators to build values of such types while enforcing the associated safety properties, the existing approaches \cite{st_lin_haskell, Jespersen:2015:STR:2808098.2808100} either rely on more expressive type systems than the one provided by Stainless, eg. \textit{substructural type systems} or ones which provide \textit{path families}, \textit{higher-kinded types} and \textit{indexed monads}, or \textit{path-dependent types}. In the next section we look at a solution to this problem which only require minimal and orthogonal modifications to Stainless's type system.

\subsection{Value-Level Sessions Encoding}

The \textit{lchannels} Scala library \cite{lchannels} provides a lightweight, term-level encoding of sessions which does not rely on advanced type system features. This encoding essentially corresponds to the \textit{continuation-passing-style} transformation of session types. In their library, the two endpoints (one for receiving, one for sending) of the communication channel between two parties are represented as values of the two types \stt{In} and \stt{Out}, respectively. These types are parametrized by the type of value that they accept or produce, and provide methods to send or receive such messages. \RefCode{lst:lchannels} shows a subset the API provided by the library, and \RefCode{lst:lchannels-hello} shows the encoding of the protocol we have been working with so far with this framework.

\begin{Code}{PureScala}{lst:lchannels}{\textit{lchannels} library interface}
abstract class In[+A] {
  // Blocks until a message is received through the channel and returns it.
  def receive(implicit d: Duration): A
  
  // Map over the next message received and returns the result.
  def ?[B](f: A => B)(implicit d: Duration): B = {
    f(receive)
  }
}

abstract class Out[-A] {
  // Sends a message through the channel.
  def !(msg: A): Unit

  // Sends a message which will trigger a reply, and returns the
  // endpoint to receive the reply from.
  // Expects the provided function to embed the given
  // output endpoint into the message before returning it.
  // and returns an endpoint for receiving it.
  def !![B](h: Out[B] => A): In[B] = {
    val (in, out) = create[B]()
    this ! h(out)
    in
  }
  
  // Sends a message after which another message must be sent as well.
  def !![B](h: In[B] => A): Out[B]

  // Creates a new channel and return its two endpoints.
  def create[B](): (In[B], Out[B])
}
\end{Code}

\begin{Code}{PureScala}{lst:lchannels-hello}{\textit{lchannels} implementation of a simple protocol}
abstract class AliceBob
case class Quit()                     extends AliceBob
case class Greet(cont: Out[Response]) extends AliceBob

abstract class Response
case class Hello(cont: Out[AliceBob]) extends Response
case class Bye()                      extends Response\
\end{Code}

\subsection{Linear Types in Stainless}

\newcommand{\lin}[1]{\stt{Linear[#1]}}

In this section, we discuss our implementation\footnote{\url{https://github.com/romac/stainless/tree/linear}} of linear types in Stainless, which consists of about 750 lines of code. Because the PureScala AST we are working with in Stainless is already typed, there is no need to write a full-fledged type checker. We will hence rather describe a \textit{linearity checker} for PureScala programs.

\subsubsection{Introducing Linear Types}

First of all, we need a way to introduce to mark some types as \textit{linear}. To this end, we define a covariant type constructor \stt{Linear}, which simply holds a value of type \stt{A}. This type provides a \stt{!} method to consume the linear term and return the underlying value. This enables the user to call a method of the underlying type in a concise way. As the astute reader might have noticed, this effectively adds weakening to the linear type system, and, as we will see, some care will be needed to handle such conversions properly. For example, if one had a value \stt{foo} of type \stt{Linear[Option[A]]}, one could call the \stt{isEmpty} method on the underlying value by writing \stt{foo!.isEmpty}. While making the consumption of a linear value explicit in this way is good for reasoning about one's code, there is still a bit of clutter associated with it, we also introduce an opt-in implicit conversion \stt{delinearize} from any \stt{Linear[A]} to \stt{A}. At last, because converting a non-linear value of type \stt{A} to a linear value of type \stt{Linear[A]} is always safe, we provide a such an implicit conversion by default, \stt{linearize}. \RefCode{lst:lineardef} shows the full definitions. Because those will be extracted in a specific way, they are marked \stt{@ignore}.

\begin{Code}{PureScala}{lst:lineardef}{Linear wrapper for Scala types and values}
package stainless

import stainless.lang._
import stainless.annotation._

package object linear {

  @ignore
  class Linear[+A](_value: A) {
    def ! = _value
  }
  
  @ignore
  implicit def linearize[A](value: A): Linear[A] = new Linear(value)
  
  object implicits {
    @ignore
    implicit def delinearize[A](lin: Linear[A]): A = lin!
  }
}
\end{Code}

\subsubsection{Preventing Weakening}

We now describe what it means for a linear term to be \textit{consumed}: a term \stt{t} of type \stt{Linear[A]}, for any type \stt{A}, is deemed \stt{consumed} in an expression $e$ when any of the following propositions is true:

\begin{itemize}
\item The underlying value of type \stt{A} is extracted, via the \stt{!} method, eg. $e = \stt{t!}$.
\item The term is assigned to a variable, eg. \stt{val s:\,Linear[A] = t}.
\item The term is supplied as an argument to function, eg. given \stt{def f(x:\,Linear[A]):\,B}, we have $e = \stt{f(t)}$.
\item The term is supplied as an argument to a method, eg. given a class \stt{C} with a method \stt{def m(x:\,Linear[A]):\,B}, a value $v:\, C$, we have $e = \stt{v.m(t)}$.
\item The term is supplied as an argument to a lambda, eg. given \stt{val l:\,Linear[A] => B}, we have $e = \stt{l(t)}$.
\item The term is supplied as an argument to a constructor, eg. given \stt{case class C(x: Linear[A])}, we have $e = \stt{C(t)}$.
\end{itemize}

\textit{Note: Method calls are subsumed by the first rule, as linear terms must first be delinearized with the \stt{!}\,operator before one can call methods on the underlying values.}\\

We now must ensure that no linear term is \textit{consumed} more than once. To this end, we must recursively walk down the AST, while keeping track of terms that have been consumed in a \textit{usage context}, in order to disallow subsequent uses of those terms. We will denote this context by $\Delta$. \TODO{\RefFig{fig:lintypesrules} presents the type-checking rules used to reject invalid programs.}\\

The astute reader will have noticed that the presence of the \stt{!}\,operator, if not handled carefully, would actually allow weakening. For example, given a value \stt{a:\,Linear[A]}, one could write \stt{val b:\, A = a.!}, and thus obtain a non-linear reference to the underlying value. To counter this, the linearity checker treats any expression of the form \stt{$e$.!}, with \stt{$e$:\,Linear[A]}, as having type \stt{Linear[A]} instead of \stt{A}.

\subsubsection{Preventing Contraction}

Because linear logic does not allow contraction, we must also ensure that no linear term is \textit{dropped}, that is to say, that it is \textit{consumed} at least once. To this end, we first collect all linear variables being introduced in a function definition, for example as a parameter to the function, in a variable binding, or within a pattern in a \texttt{clause} (even as a wildcard). Then, after having ran the type-checking algorithm described in the previous section, we can make use of the resulting \textit{usage context} $\Delta$ to check whether each and every of those variable has indeed been \textit{consumed} at some point, and reject the program otherwise.

\subsubsection{Linear Terms in Contracts}

It is important to note that, when running the linearity checker over a function with pre- and/or post-conditions, these are ignored for the following reason: a user might want to constrain either a linear parameter of some function, or its return value. If we ran the linearity checker on such contracts, then one would not be able to re-use the linear variable that is being constrained in the precondition, or would not be able to reference any linear parameter in the postcondition. \RefCode{lst:prepostlinear} shows such a use-case.

\begin{Code}{PureScala}{lst:prepostlinear}{Usage of a linear variable in a function's precondition}
def foo(x: Linear[Option[BigInt]]): BigInt = {
  require(!x.isEmpty && x.get > 0)
  x.get * 2
} ensuring { _ > 0 }
\end{Code}

Fortunately for us, because a function's contract will be statically verified by Stainless, there is no point to check it at runtime. Hence, in Stainless's library, both the \stt{require} function and the \stt{ensuring} method discard their body. For this reason, we can safely ignore linearity constraints in a function's contract.\\

\subsubsection{Linear Data Types}

Because data types can contain linear fields, one must be careful as to when to allow values of such types to be introduced. Indeed, if one were to define a data type \stt{case class A(x:\,Linear[B])}, one should not be allowed to construct a non-linear term of type \stt{A}. That is because doing so would permit the user to have more than one (indirect) reference to the linear \stt{x} field, which is forbidden because of the No-Weakening rule. We must thus ensure that values such types are only introduced linearly, ie. as values of type \stt{Linear[A]}, whether it is as a function parameter, as a variable binding, or as field of another data type. \RefCode{lst:linearadt} features a few examples of this rule in action.

\begin{Code}{PureScala}{lst:linearadt}{Linear data types in action}
case class A(x: Linear[BigInt])

case class B(a: A)          // error
case class C(b: Linear[A])  // ok

def f(x: A): A = { // error
  x
}

def g(x: Linear[A]): Linear[A] = { // ok
  x
}

def h(x: C): Linear[A] = c match {
  case C(b) => b // ok
}

def i(x: BigInt): A = c match { // error
  A(x)
}

def j(x: BigInt): Linear[A] = c match {
  A(x) // ok
}

def k(x: BigInt): Linear[BigInt] = c match {
  A(x) match {
    case A(y) => y // error
  }
}
\end{Code}

\subsubsection{Marking the Current Object as Linear}

Another issue arise when dealing with data types meant to be introduced linearly if these have associated methods. To understand why, let's look at an example. \RefCode{lst:linfile} shows a very simple API which allows to open a file, read its content line-by-line, or read all its content at once. We would like to make sure that, once a user opens a \stt{File} and receives the associated \stt{FileHandler}, the latter must be closed. Unfortunately, when implementing the \stt{contents} method, nothing prevents the programmer to call \stt{readLine} twice on the current object. That is because, Within \stt{contents}, \stt{this} has type \stt{FileHandler}, and calling any method on it will thus not consume it. As it is not possible in Scala to constrain the type of the current object, even with self-annotations, we introduce a method annotation \stt{@linear} which signals to the linearity checker that, within an annotated method of a class \stt{C}, \stt{this} should be considered to have type \stt{Linear[C]}. As methods inherit the annotations of their enclosing class, it is here enough to annotate the \stt{FileHandler} class with \stt{@linear}.

\begin{Code}{PureScala}{lst:linfile}{Linear File API}
class File {
  def open: Linear[FileHandler] = /* ... */
}

class FileHandler {
  def readLine: (Option[String], Linear[FileHandler]) = /* ... */
  def close: Unit = /* ... */
  
  def contents: String = {
    val (res, h) = this.readLine
    doSomething(this.readLine) // should be disallowed
    res match {
      case Some(line) =>
        line + h!.contents

      case None() =>
        h!.close
        ""
    }
  }
}
\end{Code}

\subsubsection{Higher-Order Linear Functions}

\RefCode{lst:hlf} shows the syntactic sugar provided by our implementation, which allow to refer to the type a linear lambda, ie. a lambda which consumes its argument, by \InlineS{A -*> B} instead \InlineS{Linear[A] => B}. The library also provides an implicit conversion from function of \InlineS{Linear[A] => B} to a \InlineS{A -*> B}. In \RefCode{lst}, we show the definition of a linear list, along with its \stt{map} method, which accepts a linear lambda.

\begin{Code}{PureSCala}{lst:hlf}{Syntactic sugar for linear lambdas}
case class -*>[A, B](f: Linear[A] => B) {
  def apply(x: Linear[A]): B = f(x)
}

implicit def toLin[A, B](f: Linear[A] => B): A -*> B = -*>(f)
\end{Code}

\begin{Code}{PureSCala}{lst:hlf}{Linear list}
@linear
sealed abstract class LList[A] {
  def map[B](f: A -*> B): Linear[LList[B]] = this match {
    case LNil()      => LNil[B]()
    case LCons(h, t) => LCons(f(h), t.map(f))
  }
}

case class LNil[A]() extends LList[A]
case class LCons[A](head: Linear[A], tail: Linear[LList[A]]) extends LList[A]

def ok(xs: Linear[LList[Int]]): Linear[LList[Int]] = {
  xs.map((x: Linear[Int]) => x + 1)
}

def bad(xs: Linear[LList[Int]]): Linear[LList[Int]] = {
  xs.map((x: Linear[Int]) => x + x + 1) // err: linear term `x` has already been used
}
\end{Code}

%\begin{landscape}
%\begin{figure}[htb]
%\begin{framed}
% 
%\begin{equation}
%\dfrac{
%  \Delta \vdash t:\,\lin{A}
%}{
%  \Delta \cup t \vdash t! : A
%}
%\end{equation}
%
%\begin{equation}
%\dfrac{
%  \Delta \vdash t:\,\lin{A} \qquad \Delta \cup t \vdash b:\,B
%}{
%  \Delta \cup t \vdash \stt{val x:\,\lin{A} = $t$; $b$} : B
%}
%\end{equation}
%
%\begin{equation}
%\dfrac{
%  \Delta \vdash f :\,(T_1, \ldots, \lin{$T_i$}, \ldots, T_n) \to S
%  \quad \Delta \vdash t_i : \lin{$T_i$} \\
%  \quad \Delta \vdash (t_1, \ldots, t_{i-1}) :\, (T_1, \ldots, T_{i-1})
%  \quad \Delta \cup t \vdash (t_{i+1}, \ldots, t_{i-1}) :\, (T_1, \ldots, T_{i-1})
%}{
%  \Delta \cup t \vdash f(t_1, \ldots, t_i \ldots, t_n) : S
%}
%\end{equation}
%
%\end{framed}
%\vspace{-10pt}
%\caption{Typing rules \label{fig:lintypesrules}}
%\end{figure}
%\begin{landscape}

\subsection{Sessions Library in PureScala}
\label{sessions_lib}

\RefCode{lst:sessions} shows a PureScala implementation of the \textit{lchannels} library. For the purpose of verification, we do not need a full-fledged implementation of the channels, but only declarations mirroring the Scala library. This way, one could run their implementation with the original library by simply linking against both it and the Stainless library, without relying on our library.

\begin{Code}{PureScala}{lst:sessions}{Sessions library in PureScala}
type In[A]  = Linear[InChan[A]]
type Out[A] = Linear[OutChan[A]]

@linear @library
class InChan[A] {

  @extern
  def receive(implicit d: Duration): Linear[A] = {
    ???
  }

  def ?[B](f: Linear[A] => B)(implicit d: Duration): B = {
    f(receive)
  }
}

@linear @library
class OutChan[A] {

  @extern
  def send(msg: A): Unit = {
    ???
  }

  def !(msg: A): Unit = {
    send(msg)
  }

  @extern
  def !![B](h: Out[B] => A): In[B] = {
    ???
  }

  @extern
  def create[B](): (In[B], Out[B]) = {
    ???
  }
}
\end{Code}

\subsection{Case Study: ATM}

Let's consider a protocol involving an ATM and its user, which we informally describe below:

\begin{enumerate}[label=\Alph*]
\item The user authenticates herself by sending the ATMÂ both her card number and PIN.
\item If the authentication succeeds, the ATM displays a menu to the user, who can then choose to:
\begin{enumerate}
\item Abort the process altogether.
\item Ask for her account's balance, in which case the server will reply with the balance, and displays the menu again.
\end{enumerate}
\item If the authentication fails, the ATM notifies the user of the failure, and the process is aborted.
\end{enumerate}

\RefCode{lst:atm_desc} shows the encoding of such a specification using the library described in \RefSec{sessions_lib}. \RefCode{lst:atm_impl} shows the corresponding valid implementation. At last, \RefCode{lst:atmmistake} shows an incorrect implementation of the protocol that would still verify without the linearity checker. We discuss the three use cases below:

\begin{enumerate}
\item If we provide an empty body for the \stt{atm} function, we would then be greeted with the following error:

\begin{ShortCode}{PureScala}
$\texttt{\textbf{\textcolor{Red}{Error}}}$: linear variable `c` of type `Linear[In[Authenticate]]` is never used:
                 def atm(c: Linear[In[Authenticate]]): Unit = {
                         $\texttt{\textbf{\textcolor{Red}{\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum}}}$
\end{ShortCode}

Re-using the same channel twice would also give rise to an error:

\begin{ShortCode}{PureScala}
$\texttt{\textbf{\textcolor{Red}{Error}}}$: linear term `cont` has already been used: doSomething(cont)
                               $\texttt{\textbf{\textcolor{Red}{\textasciicircum\textasciicircum\textasciicircum\textasciicircum}}}$
$\texttt{\textbf{\textcolor{Blue}{Info}}}$: term used here: cont !! Balance(balance(card))(_) ? menu(card)
                                                            $\texttt{\textbf{\textcolor{Red}{\textasciicircum\textasciicircum\textasciicircum\textasciicircum}}}$
\end{ShortCode}

\item In case we forget to send back a failure notification when the authentication fails. The linearity checker will realise that the linear \stt{cont} is not consumed in every branch of the pattern match, and will pinpoint its introduction:

\begin{ShortCode}{PureScala}
$\texttt{\textbf{\textcolor{Red}{Error}}}$: linear variable `cont` of $\texttt{type}$ `Linear[OutChan[Response]]` is never used:
                 case Authenticate(_, _, cont) =>
                                         $\texttt{\textbf{\textcolor{Red}{\textasciicircum\textasciicircum\textasciicircum\textasciicircum}}}$
\end{ShortCode}

\item
At last, let's see what happens if we do not handle the reply to the \stt{Success} message sent in case the authentication succeeds. Because the expression \stt{cont !! Success(\_)} has type \stt{In[Menu]}, one could expect the Scala compiler to raise a type error, as the \stt{atm} function has return type \stt{Unit}. Unfortunately, the Scala compiler will happily convert any value to \stt{Unit} if it occurs at the end of a block. But because \stt{In[Menu]} is a linear type, the linearity checker will notice that the corresponding value is being discarded, and will raise an error:

\begin{ShortCode}{PureScala}
$\texttt{\textbf{\textcolor{Red}{Error}}}$: linear term cannot be discarded: cont !! Success(_)
                                        $\texttt{\textbf{\textcolor{Red}{\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum}}}$
\end{ShortCode}
\end{enumerate}

\begin{Code}{PureScala}{lst:atm_desc}{ATM protocol description}
// Authentication request from the user
case class Authenticate(card: String, pin: String, cont: Out[Response])

// Authentication response from the ATM
sealed abstract class Response
case class Failure()                extends Response
case class Success(cont: Out[Menu]) extends Response

// Choices available to authenticated user
sealed abstract class Menu
case class CheckBalance(cont: Out[Balance]) extends Menu
case class Quit()                           extends Menu

// User account balance
case class Balance(amount: BigInt)(cont: Out[Menu]) {
  require(amount >= 0)
}
\end{Code}

\begin{Code}{PureScala}{lst:atm_impl}{Correct ATM protocol implementation}
def atm(c: In[Authenticate]): Unit = {
  c ? { auth => auth! match {  
    case Authenticate(card, pin, cont) if authenticated(card, pin) =>
      cont !! Success(_) ? menu(card)
  
    case Authenticate(_, _, cont)  =>
      cont ! Failure()
  } }
}

def menu(card: String)(menu: Linear[Menu]) = {
  menu! match {
    case CheckBalance(cont) =>
      cont !! Balance(balance(card))(_) ? menu(card)

    case Quit() => ()
  }
}

def authenticated(card: String, pin: String): Boolean = {
  /* ... */
}

def balance(card: String): BigInt = {
  /* ... */
} ensuring { _ >= 0 }
\end{Code}

\begin{Code}{PureScala}{lst:atm_user}{Correct user protocol implementation}
def getAmount(c: Out[Authenticate], card: String, pin: String): Option[BigInt] = {
  c !! Authenticate(card, pin, _) ? { res =>
    res! match {
      case Failure() => None()
      case Success(cont) => cont !! CheckBalance(_) ? {
        case Balance(amount)(cont) =>
          cont ! Quit()
          Some(amount)
      }
    }
  }
} ensuring { _ >= 0 }
\end{Code}

\begin{Code}{PureScala}{lst:atmmistake}{Incorrect implementation of the ATM protocol}
def atm(c: In[Authenticate]): Unit = {
  c ? { auth => auth! match {  
    case Authenticate(card, pin, cont) if authenticated(card, pin) =>
      // 3. do not wait for a reply to `Success` message
      cont !! Success(_)
  
    case Authenticate(_, _, cont) =>
      // 1. does not send back a Failure message

  } }
}

def menu(card: String)(menu: Linear[Menu]): Unit = {
  menu! match {
    case CheckBalance(cont) =>
      cont !! Balance(balance(card))(_) ? menu(card)
      
      // 2. `cont` has already been used
      doSomething(cont)

    case Quit() => ()
  }
}
\end{Code}

%\subsubsection{TLS 1.2 Handshake}
%
%\footnote{The Transport Layer Security (TLS) Protocol - Version 1.2: \url{https://www.ietf.org/rfc/rfc5246.txt}}

\subsection{Conclusion}

\TODO{Conclusion}

\subsection{Further Work}

\subsubsection*{Term-level Multiparty Session Types for Actor Systems}

We believe that it would be worth investigating the interplay between linear types, sessions types and the actor model developed in \RefSec{actors}, provided that we manage to enrich the model with a typed API. It is of course already possible to mark actor references as linear within our model, effectively requiring the holder of such a reference to send it a message. But without a typed API, it is current not possible to model a session within this framework. On top of that, more work is probably needed to properly encode the resulting so-called \textit{multiparty session types}\cite{DBLP:journals/corr/NeykovaY16} at the term level.

\subsubsection*{Affine Types and Borrow Checker}

In the early days of this project, we implemented a very basic borrow checker within Stainless\footnote{\url{https://github.com/romac/stainless/tree/borrow-checker}}. While the results were encouraging, such a mechanism is not enough to implement linear channels, as it corresponds to an enriched affine type system. We nonetheless believe that this could also be an interesting addition to Stainless. This because one could implement a pass within Stainless which would insert the appropriate invocations for allocating and freeing the memory associated with an affine term which could then be linked and compiled with the Scala Native project\footnote{\url{https://github.com/scala-native/scala-native}}, thus effectively allowing one to opt out of garbage collection for the parts of a program requiring a high memory throughput. It is worth noting that this technique could alsoÂ apply to Leon's C code generator \cite{genc1, genc2} but as a way to safely introduce dynamic memory allocations in the generator, which currently only support statically allocated memory.

\clearpage
\section{Conclusion}
\label{conclusion}

\TODO{Conclusion}

\clearpage

\appendix

%\begin{landscape}
%\section{Scala Implementation of Sessions Types}
%\label{full-sessions}
%\lstinputlisting[language=PureScala, style=LongCode]{code/full-sessions.scala}
%\end{landscape}

\clearpage

%\nocite{*}
\bibliographystyle{ieeetr}
\bibliography{report}



\end{document}
