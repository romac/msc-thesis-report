\documentclass[a4paper,twoside]{article}
\usepackage[a4paper]{geometry}

% \usepackage[a4paper,showframe]{geometry} % add showframe for debug
% \usepackage{titleps}

\usepackage[pagestyles]{titlesec}
\usepackage[all]{nowidow} % avoid orphan lines

% Extra colours; need to be first
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}

% Basic packages
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

% Landscape mode
\usepackage{pdflscape}

% Additional font
\usepackage{FiraMono}

% Bibtex+cite
\usepackage{cite}
\usepackage{url}
\usepackage[nottoc,numbib]{tocbibind}

% URL
\usepackage[
  colorlinks=true,
  urlcolor=blue,
  citecolor=black,
  linkcolor=.
]{hyperref}

% Lists
\usepackage{scrextend}
\addtokomafont{labelinglabel}{\sffamily}
\usepackage[inline]{enumitem} % for enumerate* environment.

% Maths & symbols
\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{pifont}
\usepackage{framed}
\usepackage{stmaryrd}
\newcommand{\lb}[2]{\llbracket\, #1\,;\, #2\, \rrbracket}

% Mono font
\usepackage[scaled]{beramono}

% Spacing
\usepackage{xspace}

% Graphics
\usepackage{graphicx}

% Table
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{multirow}

% Floating placement
\usepackage{placeins}
% use \FloatBarrier before a \section to ensure all floating are displayed
% before the new section

% Caption styling
\usepackage[justification=centering]{caption}

% Additional colours
\definecolor{c1}{HTML}{006C71}
\definecolor{c2}{HTML}{005155}
\definecolor{c3}{HTML}{FF8928}
\definecolor{c4}{HTML}{E86900}
\colorlet{ImportantCode}{ForestGreen}
\colorlet{ImportantCode2}{RubineRed}
\colorlet{ImportantCode3}{RedOrange}

% TIKZ & related packages/settings
\usepackage{tikz}
\usepackage{pgfplots}
\usetikzlibrary{shapes,fit,backgrounds,arrows,positioning,chains,patterns}
% \pgfplotsset{compat = 1.14}

% for caching tikz pictures
% \usetikzlibrary{external}
% \tikzexternalize[prefix=tikz-figures/]
% \pgfrealjobname{tikz}

% Layout
\usepackage{chngpage}
\usepackage{rotating}

% Listings
\usepackage{listings,multicol}
\usepackage{lstscala}


\lstdefinelanguage{PureScala}{ % Using `Scala` result in a infinite recursion
  style=scala-color,
  morekeywords={[2]Unit,Boolean,Byte,Int,BigInt,String,Char,Option,List,true,false},
  %keywordstyle={[2]\color{blue!30!darkgray}\bfseries}
}

\newcommand{\Inline}[1]{\lstinline[basicstyle=\small\ttfamily,columns=fixed]|#1|}
\newcommand{\InlineS}[1]{\lstinline[language=PureScala,basicstyle=\small\ttfamily,columns=fixed]|#1|}
% %\newcommand{\inlineScala}[1]{\lstinline[language=MyScala,breaklines=true,breakatwhitespace=true]|#1|}

% Use code in description item, Based on http://tex.stackexchange.com/a/181325/77356
\newcommand*{\lstitem}[1]{
  \setbox0\hbox{\textbf{\Inline{#1}}}
  \item[\usebox0]
}

% %\lstset{aboveskip=5pt,belowskip=10pt}
% \lstset{captionpos=b,abovecaptionskip=1em}

% For long listings
\lstdefinestyle{LongCode}{
  %aboveskip=1ex,
  basicstyle=\small\ttfamily,
  % basicstyle=\scriptsize\ttfamily,
  % basicstyle=\tiny\ttfamily,
  %belowskip=1ex,
  breaklines=true,
  postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow}},
  breakautoindent=false,
  %breakatwhitespace=false,
  %columns=fullflexible,
  multicols=2,
  framerule=0pt,
  framexrightmargin=0em,
  framexleftmargin=0em,
  % numbers=left,
  % numberstyle=\footnotesize\sffamily,
  tabsize=2
}


% Env for short code: no label, no caption and "inlined" with a box
\lstnewenvironment{ShortCode}[1]
    {
      \lstset{
        language=#1,
        basicstyle=\small\ttfamily,
        frame=trBL % box the frame & double line on bottom and left side
      }
    }
    {
    }

% Env for longer code: label, caption and "floating" with a box
\lstnewenvironment{Code}[3]
    {
      \lstset{
        language=#1,
        basicstyle=\small\ttfamily,
        label={#2},
        caption=#3,
        captionpos=b, % bottom
        float=!h,     % "here"
        frame=trBL,   % box the frame & double line on bottom and left side
        % frameround=tttt
      }
    }
    {
      % DEBUG:
      % 1: #1 \\
      % 2: #2 \\
      % 3: #3
    }



% Tables
% \newcommand{\heading}[1]{\multicolumn{1}{c}{\textbf{#1}}}
% \newcommand{\vheading}[1]{\rotatebox[origin=c]{90}{~\textbf{#1}~}}


% To centre table too wide
% credit: http://tex.stackexchange.com/a/27099/77356
\makeatletter
\newcommand*{\centerfloat}{%
  \parindent \z@
  \leftskip \z@ \@plus 1fil \@minus \textwidth
  \rightskip\leftskip
  \parfillskip \z@skip}
\makeatother

% General styling
%\let\oldsection\section
%\renewcommand\section{\cleardoublepage\oldsection}

% For some reason page margin are swapped when having a title page with a
% different geometry. We fix that manually by 1) swapping the margin and
% 2) swapping the page number position (page style)
% credit: http://tex.stackexchange.com/a/36016/77356
\makeatletter
\newcommand*{\flipmargins}{%
  \clearpage
  \setlength{\@tempdima}{\oddsidemargin}%
  \setlength{\oddsidemargin}{\evensidemargin}%
  \setlength{\evensidemargin}{\@tempdima}%
  \if@reversemargin
    \normalmarginpar
  \else
    \reversemarginpar
  \fi
}
\makeatother

\newpagestyle{mystyle_no_header}{
  \setfoot[\thepage][][]{}{}{\thepage}
}

\newpagestyle{mystyle}{
  % \sethead[][][\firsttitlemarks\ifthesubsection{\thesubsection~\subsectiontitle}{\thesection~\sectiontitle}]{\firsttitlemarks\ifthesubsection{\thesubsection~\subsectiontitle}{\thesection~\sectiontitle}}{}{}
  \sethead[\thesection~\sectiontitle][][]{}{}{\thesection~\sectiontitle}
  % \setfoot[][][\thepage]{\thepage}{}{}
  \setfoot[\thepage][][]{}{}{\thepage}
}

% Additional macros
\newcommand{\TODO}[1]{\textcolor{YellowOrange}{(TODO: #1)}} % for inline TODO
%\newcommand{\TODO}[1]{\textcolor{YellowOrange}{(TODO)}} % for inline TODO
% \newcommand{\TODO}[1]{\underline{(#1)}} % for inline TODO, PRINTING
\newcommand{\URL}[2]{#2:\xspace\href{#1}{#1}}
\newcommand{\RefSec}[1]{Section~\ref{#1}}
\newcommand{\RefTable}[1]{Table~\ref{#1}}
\newcommand{\RefApp}[1]{Appendix~\ref{#1}}
\newcommand{\RefFig}[1]{Figure~\ref{#1}}
\newcommand{\RefCode}[1]{Listing~\ref{#1}}
\newcommand{\BigO}[1]{\mathcal{O}(#1)}
\newcommand{\ActorRef}{\InlineS{ActorRef}\ }
\newcommand{\stt}[1]{\texttt{\small{#1}}}


%%%

\title{Experiments in Program Verification with Stainless}

\date{
%  {\small Version 0.6}\\
  {\small (Draft)}\\
  January 2018
}

\author{Romain Ruetschi}

\begin{document}

\newgeometry{centering}
\pagenumbering{gobble}
\maketitle

\vfill

\begin{abstract}

\TODO{Abstract}

\end{abstract}

\vfill

\begin{center}
    Master Thesis Project under the supervision of \\
    Prof. Viktor Kuncak \& Dr. Jad Hamza \\
    Lab for Automated Reasoning and Analysis LARA - EPFL
\end{center}

\begin{center}
    \includegraphics[width = 40mm]{res/epfl-logo}
\end{center}

\clearpage\null\newpage

\restoregeometry              %% restore the layout
\flipmargins
\pagestyle{mystyle_no_header}
\pagenumbering{arabic}

\tableofcontents
% \lstlistoflistings

\clearpage
\pagestyle{mystyle}

% ===========================================================================================
% ===========================================================================================

\section{Introduction}

\TODO{Introduction}

\clearpage

\section{Program Verification with Stainless}
\label{verif}

\TODO{Describe Stainless/Inox pipeline}

\clearpage
\section{Symbolic Evaluation of Inox Programs}
\label{symbolic}

\subsection{Motivation}

Consider the following program, which inserts a known list of key-value pairs in a map that is kept abstract:

\begin{ShortCode}{PureScala}
def foldLeft[A, B](list: List[A], z: B)(f: (B, A) => B): B = list match {
  case Nil() => z
  case Cons(x, xs) => foldLeft(xs, f(z, x))(f)
}

def insert[A, B](kvs: List[(A, B)], map: Map[A, B]) = {
  foldLeft(kvs, map) {
    case (acc, (k, v)) => acc.updated(k, v)
  }
}

def test(map: Map[String, Int]): Boolean = {
  val xs = List("a" -> 1, "b" -> 2, "c" -> 3, "d" -> 4)
  val res = insert(xs, map)
  res("b") == 2
}.holds
\end{ShortCode}

For the sake of simplicity, let us assume that Stainless is unable to automatically prove the verification condition corresponding to \stt{test}'s postcondition (we will look at an actual test case in \RefSec{symcases}).\\

So, how would one go about to help Stainless prove this program correct? We could for example break up the problem, by adding appropriate postconditions to both \stt{foldLeft} and \stt{insert}, and provide the necessary lemmas, assertions, or annotations in order to get these to verify.\\

While this is a reasonable way of going at the problem, we feel that for this specific program, there is another way of tackling the problem. Indeed, while the \stt{map} variable is kept abstract, the list of values \stt{xs} we want to insert is not, and it should thus be possible to simplify the initial program by unfolding some definitions, and simplifying the resulting expressions, yielding a much simpler verification condition.\\

If we manually unfold \stt{insert} once, then unfold \stt{foldLeft} "as much as possible" in the program above, we end up with the following definition for the \stt{test} function, which is both much smaller and simpler than the original definition. We could then expect Stainless to have an easier time proving this theorem.

\begin{ShortCode}{PureScala}
def test(map: Map[String, Int]): Boolean = {
  val res = map.updated("a", 1).updated("b", 2).updated("c", 3).updated("d", 4)
  res("b") == 2
}.holds
\end{ShortCode}

We believe that it is unreasonable to expect users to manually perform such a transformation, especially with large programs. We have hence implemented an automatic transformation as part of the verification pipeline, by extending the current simplification procedure found in Inox.

\subsection{Symbolic Evaluation}

The process of simplifying a program by evaluating it as much as possible, even in the presence of unknown inputs is often referred to as \textit{symbolic evaluation}. The idea is to execute the program over symbolic inputs values while maintaining a \textit{path condition}, ie. a quantifier-free formula in conjunctive normal form that represents the constraints over the inputs we have discovered so far, as well as the branching decisions made. The actual implementation also keeps track of bound variables in a specific way for performance.

\RefCode{lst:PC} shows a simple program annotated with the current path condition are various points of execution. When evaluating such a program symbolically, the path condition enables the evaluator to pick the "else" branch of the "if-then-else" expression, because, under the current path condition, the formula \stt{x <= 0}, \stt{x > 0} is unsatisfiable. As a result of the symbolic evaluation, the resulting program is now equivalent to the code featured in \RefCode{lst:PCres}.

\begin{Code}{PureScala}{lst:PC}{Initial program with path condition}
// 1. PC = true
assume(x <= 0)
// 2. PC = x <= 0
val y = if (x > 0) {
  // 2. PC = x <= 0 && x > 0
  x
} else {
  // 3. PC = x <= 0
  -x
}
// 4. PC = y == -x && x <= 0
\end{Code}

\begin{Code}{PureScala}{lst:PCres}{Simplified program}
assume(x <= 0)
val y = -x
// PC = x <= 0 && y == -x
\end{Code}

\subsubsection{Example}

Here is how the \textit{PureScala} program above is expressed in Inox's input language, formatted in \textit{PureScala} syntax:

\begin{ShortCode}{PureScala}
def foldLeft[A](list: List[A], z: B, f: (B, A) => B): B =
  if (list.isInstanceOf[Nil[A]]) {
    z
  } else {
    val x  = list.asInstanceOf[Cons[A]].head
    val xs = list.asInstanceOf[Cons[A]].tail
    foldLeft(xs, f(z, x), f)
  }
}

def insert[A, B](values: List[(A, B)], map: Map[A, B]) = {
  foldLeft(xs, map, (acc, kv) => acc.updated(kv._1, kv._2))
}

def test(map: Map[String, Int]): Boolean = {
  val xs = List("a" -> 1, "b" -> 2, "c" -> 3, "d" -> 4)
  val res = insert(xs, map)
  res("b") == 2
}.holds
\end{ShortCode}

Let's only focus on the first two lines of the \stt{test} function, and go through the steps followed by the symbolic evaluator when ran on it. 

\begin{ShortCode}{PureScala}
val xs = List("a" -> 1, "b" -> 2, "c" -> 3, "d" -> 4)
val res = insert(xs, map)
\end{ShortCode}

\begin{enumerate}

\item We start by substituting the first binding into the subsequent statement:

\begin{ShortCode}{PureScala}
val res = insert(
  Cons("a" -> 1, Cons("b" -> 2, Cons("c" -> 3, Cons("d" -> 4, Nil()),
  map
)
\end{ShortCode}

\item Because \stt{insert} is non-recursive function, we can unfold it straight away:

\begin{ShortCode}{PureScala}
val res = foldLeft(
  Cons("a" -> 1, Cons("b" -> 2, Cons("c" -> 3, Cons("d" -> 4, Nil()),
  map,
  (acc, kv) => acc.updated(kv._1, kv._2)
)
\end{ShortCode}

\item \stt{foldLeft} is a recursive function, and some care is thus needed here. We look at its body and find a toplevel "if-else" statement. We now ask ourselves whether or not its condition can be reduced to a boolean literal under the current path condition, ie. whether \stt{list.isInstanceOf[Nil]} evaluates to \stt{true} or \stt{false} given that \stt{list = Cons("a" -> 1, ...)}. It is clear here that this expression reduces to \stt{false}, and we can thus unfold \stt{foldLeft}'s definition and continue:

\begin{ShortCode}{PureScala}
val res = if (Cons("a" -> 1, Cons("b" -> 2, ...)).isInstanceOf[Nil[A]]) {
  map
} else {
  val x  = Cons("a" -> 1, Cons("b" -> 2, ...)).asInstanceOf[Cons[A]].head
  val xs = Cons("a" -> 1, Cons("b" -> 2, ...)).asInstanceOf[Cons[A]].tail
  foldLeft(xs, ((acc, kv) => ...)(z, x), (acc, kv) => ...)
}
\end{ShortCode}

\item Once again, we see that the condition evaluates to \stt{false}, and we thus replace the "if-else" statement by its "else" branch (note: our implementation actually performs this step and the previous one in go for performance):

\begin{ShortCode}{PureScala}
val res = {
  val x  = Cons("a" -> 1, Cons("b" -> 2, ...)).asInstanceOf[Cons[A]].head
  val xs = Cons("a" -> 1, Cons("b" -> 2, ...)).asInstanceOf[Cons[A]].tail
  foldLeft(xs, ((acc, kv) => ...)(map, x), (acc, kv) => ...)
}
\end{ShortCode}

\item Here we can evaluate the bound value of \stt{x} (note: we evaluate both bindings in one go here for brevity):

\begin{ShortCode}{PureScala}
val res = {
  val x  = "a" -> 1
  val xs = Cons("b" -> 2, ...)
  foldLeft(xs, ((acc, kv) => ...)(map, x), (acc, kv) => ...)
}
\end{ShortCode}

\item We now inline both bindings:

\begin{ShortCode}{PureScala}
val res = {
  foldLeft(
    Cons("b" -> 2, ...),
    ((acc, kv) => ...)(map, "a" -> 1),
    (acc, kv) => ...
  )
}
\end{ShortCode}

\item And we now evaluate the arguments supplied to \stt{foldLeft}, giving us:

\begin{ShortCode}{PureScala}
val res = {
  foldLeft(
    Cons("b" -> 2, ...),
    map.updated("a", 1),
    (acc, kv) => ...
  )
}
\end{ShortCode}

\item We now repeat steps 3 to 7 until we have traversed the entire list, leaving us with:

\begin{ShortCode}{PureScala}
val res = {
  foldLeft(
    Nil(),
    map.updated("a", 1).updated("b", 2).updated("c", 3).updated("d", 4),
    (acc, kv) => ...
  )
}
\end{ShortCode}

\item We once again look ahead and see that, this time, the condition will evaluate to \stt{true}, and can thus unfold \stt{foldLeft} once again, getting us to:

\begin{ShortCode}{PureScala}
val res = if (Nil().isInstanceOf[Nil[A]]) {
  map.updated("a", 1).updated("b", 2).updated("c", 3).updated("d", 4)
} else {
  val x  = Nil().asInstanceOf[Cons[A]].head
  val xs = Nil().asInstanceOf[Cons[A]].tail
  foldLeft(xs, ((acc, kv) => ...)(z, x), (acc, kv) => ...)
}
\end{ShortCode}

\item This time we pick the "then" branch, and end up the following expression, which we cannot reduce further, as \stt{map} is abstract and \stt{updated} is a special language construct which can only be evaluated when applied to a concrete, finite map:

\begin{ShortCode}{PureScala}
val res = map.updated("a", 1).updated("b", 2).updated("c", 3).updated("d", 4)
\end{ShortCode}

\end{enumerate}

This whole process leaves us with the very same definition we would have obtained by equational reasoning, which is admittedly much simpler, and easier to reason about for Inox.

\begin{ShortCode}{PureScala}
def test(map: Map[String, Int]): Boolean = {
  val res = map.updated("a", 1).updated("b", 2).updated("c", 3).updated("d", 4)
  res("b") == 2
}.holds
\end{ShortCode}

\subsection{Semantics}

We subsequently denote the path condition by $\Delta$, and a formula $e$ that is satisfiable under $\Delta$ by $e \in \Delta$. We will not delve into the details of how to decide whether a given condition is satisfiable under some path condition, but a reasonable although much too simplistic approximation would be to maintain a set of expressions and simply testing for membership. The actual implementation found in Inox (which predates our work) is much more complex and powerful implementation of this very idea. Moreover, we denote the fact that an expression $e$ evaluates to an expression $e'$ under a path condition $\Delta$ by $\lb{e}{\Delta} \longrightarrow e'$. Given $c, v$ two expressions, and \stt{x} a variable, we note $\Delta \cup c$ the addition of $c$ to the path condition $\Delta$, and $\Delta \uplus x \mapsto v$ the addition of the binding \stt{val x = $v$}. At last, the fact that an expression $e$ can be simplified to a boolean value under a path condition $\Delta$ is captured by $\stt{e} \Downarrow \Delta$. \RefFig{fig:symbolicsem} shows the operation semantics followed by our implementation, expressed in those terms.

%\begin{itemize}
%\item \textbf{Rule 1.} 
%\end{itemize}

\begin{figure}[htb]
\begin{framed}
 
\begin{equation}
\dfrac{
  e \in \Delta
}{
  \lb{e}{\Delta} \longrightarrow \stt{true}
}
\end{equation}

\begin{equation}
\dfrac{
  \neg e \in \Delta
}{
  \lb{e}{\Delta} \longrightarrow \stt{false}
}
\end{equation}

\begin{equation}
\dfrac{
  \empty
}{
  \lb{\lambda x_1, \ldots, x_n.\, e}{\Delta} \longrightarrow \lambda \lb{x_1}{\Delta}, \ldots, \lb{x_n}{\Delta}.\, \lb{e}{\Delta}
}
\end{equation}

\begin{equation}
\dfrac{
  \empty
}{
  \lb{\stt{$l$ ==> $r$}}{\Delta} \longrightarrow \lb{\neg l \stt{ || } r}{\Delta}
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{e_1}{\Delta} \longrightarrow \stt{false}
}{
  \lb{\stt{$e_1$ \&\&\,\ldots\,\&\& $e_n$}}{\Delta} \longrightarrow \stt{false}
}
\end{equation}

\begin{equation}
\dfrac{
	\lb{e_1}{\Delta} \longrightarrow e_1'
}{
  \lb{\stt{$e_1$ \&\&\,\ldots\,\&\& $e_n$}}{\Delta} \longrightarrow \stt{$e_1'$ \&\& } \lb{\stt{$e_2$ \&\&\,\ldots\,\&\& $e_n$}}{\Delta}
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{e_1}{\Delta} \longrightarrow \stt{true}
}{
  \lb{\stt{$e_1$ ||\,\ldots\,|| $e_n$}}{\Delta} \longrightarrow \stt{true}
}
\end{equation}

\begin{equation}
\dfrac{
	\lb{e_1}{\Delta} \longrightarrow e_1'
}{
  \lb{\stt{$e_1$ ||,\ldots\,|| $e_n$}}{\Delta} \longrightarrow \stt{$e_1'$ || } \lb{\stt{$e_2$ ||,\ldots\,|| $e_n$}}{\Delta}
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{c}{\Delta} \longrightarrow \stt{true}
}{
  \lb{\stt{if ($c$) $t$ else $e$}}{\Delta} \longrightarrow \lb{t}{\Delta \cup c}
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{c}{\Delta} \longrightarrow \stt{false}
}{
  \lb{\stt{if ($c$) $t$ else $e$}}{\Delta} \longrightarrow \lb{e}{\Delta \cup c}
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{c}{\Delta} \longrightarrow c' \qquad
  \lb{t}{\Delta \cup c'} \longrightarrow t' \qquad
  \lb{e}{\Delta \cup \neg c'} \longrightarrow e' \qquad
  t' = e'
}{
  \lb{\stt{if ($c$) $t$ else $e$}}{\Delta} \longrightarrow t'
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{c}{\Delta} \longrightarrow c' \qquad
  \lb{t}{\Delta \cup c'} \longrightarrow t' \qquad
  \lb{e}{\Delta \cup \neg c'} \longrightarrow e' \qquad
  t' \neg= e'
}{
  \lb{\stt{if ($c$) $t$ else $e$}}{\Delta} \longrightarrow \stt{if ($c'$) $t'$ else $e'$}
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{p}{\Delta} \longrightarrow \stt{true}
}{
  \lb{\stt{assume($p$, $e$)}}{\Delta} \longrightarrow \lb{e}{\Delta}
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{p}{\Delta} \longrightarrow \stt{false}
}{
  \lb{\stt{assume($p$, $e$)}}{\Delta} \longrightarrow
  \stt{assume(false, $\lb{e}{\Delta}$}
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{p}{\Delta} \longrightarrow p'
}{
  \lb{\stt{assume($p$, $e$)}}{\Delta} \longrightarrow
  \stt{assume($p'$, $\lb{e}{\Delta \cup p'}$)}
}
\end{equation}

\begin{equation}
\dfrac{
  \stt{T$_2$:\,ADTType} \qquad
  \neg \stt{isSort(T$_2$)}
}{
  \lb{\stt{C(T$_1$, $a_1, \ldots, a_n$).isInstanceOf[T$_2$]}}{\Delta}
  \longrightarrow \stt{T$_1$.id == T$_2$.id}
}
\end{equation}

\begin{equation}
\dfrac{
  \stt{T:\,ADTType} \qquad
  \stt{isSort(T)}
}{
  \lb{\stt{$e$.isInstanceOf[T]}}{\Delta} \longrightarrow \stt{true}
}
\end{equation}

\begin{equation}
\dfrac{
  \stt{T:\,ADTType} \qquad
  \lb{e}{\Delta} \longrightarrow e' \qquad
  \stt{isInstanceOf(e', T, $\Delta$) == Some($b$)}
}{
  \lb{\stt{$e$.isInstanceOf[T]}}{\Delta} \longrightarrow b
}
\end{equation}

\begin{equation}
\dfrac{
  \stt{T:\,ADTType} \qquad
  \lb{e}{\Delta} \longrightarrow e' \qquad
  \stt{isInstanceOf($e'$, T, $\Delta$) == None}
}{
  \lb{\stt{$e$.isInstanceOf[T]}}{\Delta} \longrightarrow \stt{$e'$.isInstanceOf[T]}
}
\end{equation}

\end{framed}
\vspace{-10pt}
\caption{Operational semantics of the symbolic evaluator \label{fig:symbolicsem}}
\end{figure}

%------------------------------------------------------------------------

\begin{landscape}
\begin{figure}[htb]\ContinuedFloat
\centering
%\begin{adjustwidth}{-1mm}{-1cm}
\begin{framed}

\begin{equation}
\dfrac{
  \stt{T:\,ADTType}
}{
  \lb{\stt{$e$.asInstanceOf[T]}}{\Delta} \longrightarrow \stt{$\lb{e}{\Delta}$.asInstanceOf[T]}
}
\end{equation}

\begin{equation}
\dfrac{
%  \text{\TODO{This is overly simplistic}}
}{
  \lb{\stt{let x:\,T = $v$ in $e$}}{\Delta} \longrightarrow
  \lb{e[\stt{x}/\stt{$v$}]}{\Delta}
}
\end{equation}

%\begin{equation}
%\dfrac{
%  e = \stt{let x:\,T = if ($c_1$) $t_1$ else $e_1$ in if ($c_2$) $t_2$ else $e_2$}
%  \qquad c_ 1 = c_2
%}{
%  \lb{e}{\Delta} \longrightarrow
%  \lb{\stt{if ($c_1$) let x:\,T = $t_1$ in $t_2$ else let x:\,T = $e_1$ in $e_2$}}{\Delta}
%}
%\end{equation}

\begin{equation}
\dfrac{
  \lb{f}{\Delta} \longrightarrow \lambda \stt{x$_1$:\,T$_1$,\ldots,x$_n$:\,T$_n$.\,$b$}
  \qquad
  \lb{e_i}{\Delta} \longrightarrow e_i',\, i \in \{1 \ldots n\}
}{
  \lb{f(e_1,\ldots,e_n)}{\Delta} \longrightarrow
  \lb{b[\stt{x}_1/e_1',\ldots,\stt{x}_n/e_n']}{\Delta}
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{f}{\Delta} \longrightarrow f' \qquad
  \lb{e_i}{\Delta} \longrightarrow e_i',\, i \in \{1 \ldots n\}
}{
  \lb{f(e_1,\ldots,e_n)}{\Delta} \longrightarrow
  f'(e_1', \ldots, e_n')
}
\end{equation}

% TODO: Application(Assume)?

\begin{equation}
\dfrac{
 \neg\,\stt{isRecursive(id)} \quad
 \stt{id.params} = \langle \stt{x}_1, \ldots, \stt{x}_n \rangle \quad
 \lb{e_i}{\Delta} \longrightarrow e_i',\, i \in \{1 \ldots n\}
}{
  \lb{\stt{id}(e_1,\ldots,e_n)}{\Delta} \longrightarrow
  \lb{\stt{id.body}[\stt{x}_1/e_1',\ldots,\stt{x}_n/e_n']}{\Delta}
}
\label{fig:symbolicsem:fi1}
\end{equation}

\begin{equation}
\dfrac{
 \stt{id.body} \Downarrow \Delta \uplus \{\,\stt{x}_i \mapsto e_i'\,|\, 1 \leq i \leq n\,\}
 \quad
 \stt{id.params} = \langle \stt{x}_1, \ldots, \stt{x}_n \rangle
 \quad
 \lb{e_i}{\Delta} \longrightarrow e_i',\  i \in \{1 \ldots n\}
}{
  \lb{\stt{id}(e_1,\ldots,e_n)}{\Delta} \longrightarrow
  \lb{\stt{id.body}[\stt{x}_1/e_1',\ldots,\stt{x}_n/e_n']}{\Delta}
}
\label{fig:symbolicsem:fi2}
\end{equation}

\begin{equation}
\dfrac{
 \lb{e_i}{\Delta} \longrightarrow e_i',\, i \in \{1 \ldots n\}
}{
  \lb{\stt{id}(e_1,\ldots,e_n)}{\Delta} \longrightarrow
  \stt{id}(e_1',\ldots,e_n')
}
\label{fig:symbolicsem:fi3}
\end{equation}

\begin{equation}
\dfrac{
 e = \stt{if ($c$) $t_1$ else $t_2$} \quad
 \lb{c}{\Delta} \longrightarrow r \quad
 r \in \{\stt{true}, \stt{false}\}
}{
  \stt{e} \Downarrow \Delta
}
\end{equation}

\begin{equation}
\dfrac{
  (\stt{cons}, (e_1, \ldots, e_n)) = \stt{deconstruct(e)} \quad
  \lb{e_i}{\Delta} \longrightarrow e_i',\, i \in \{1 \ldots n\}
}{
  \lb{e}{\Delta} \longrightarrow \stt{cons}(e_1', \ldots, e_2')
}
\end{equation}

\end{framed}
\vspace{-10pt}
\caption{Operational semantics of the symbolic evaluator \label{fig:symbolicsem}}
\end{figure}
\end{landscape}

\subsection{Implementation}

We have implemented the symbolic evaluator described above as a new, optional, simplification pass within Inox' existing simplification pipeline. This pass can be enabled by specifying the \texttt{---sym-eval} flag on the command-line, or by setting to corresponding option using the Inox API. The code can be found on GitHub\footnote{\url{https://github.com/romac/inox/tree/sym-eval}}.

\subsection{Case Study: Key-value store}
\label{symcases}

\RefCode{lst:symkvstore} shows the implementation of a domain-specific language to manipulate a key-value store, along with a tracing interpreter over a Scala \stt{Map}. An simple program which makes use of this DSL to insert a list of concrete values into the store is shown in \RefCode{lst:symkvstoreinv}.

\begin{Code}{PureScala}{lst:symkvstoreinv}{Example program}
def insert(kvs: List[(String, String)])(after: Op): Op = kvs match {
  case Nil() => after
  case Cons((k, v), rest) => put(k, v) { () => insert(rest)(after) }
}

val xs = List("foo" -> "bar", "toto" -> "tata")
val program = insert(xs) {
  get("foo") { foo =>
    pure(foo)
  }
}

def lemma(map: Map[String, String], init: List[Label]) = {
  val (res, trace) = interpret(program)(map, init)

  res == Some("bar") &&
  trace.take(3).reverse == List(
    Label.Put("foo", "bar"),
    Label.Put("toto", "tata"),
    Label.Get("foo")
  )
} holds
\end{Code}

While Inox is unable to prove the verification condition associated with \stt{lemma}'s postcondition, turning on the symbolic evaluator yields the following VC, which it is then able to promptly prove is \texttt{UNSAT}, thus showing the property correct:

\begin{ShortCode}{PureScala}
val x = (
  map.updated("foo", "bar").updated("toto", "tata").get("foo"),
  Get("foo") :: Put("toto", "tata") :: Put("foo", "bar") :: trace
)

x._1 != Some("bar") || {
  init.take(0).reverse :+ Put("foo", "bar") :+ Put("toto", "tata") :+ Get("foo")
  !=
  Put("foo", "bar") :: Put("toto", "tata") :: Get("foo") :: Nil
}
\end{ShortCode}

%\begin{ShortCode}{PureScala}
%[  Info  ] val x$3: (Option[String], List[Label]) = (map.updated("foo", Some[String]("bar")).updated("toto", Some[String]("tata"))("foo"), Cons[Label](Get("foo"), Cons[Label](Put("toto", "tata"), Cons[Label](Put("foo", "bar"), trace))))
%[  Info  ] x$3._1 ≠ Some[String]("bar") || reverse[Label](take[Label](x$3._2, 3)) ≠ Cons[Label](Put("foo", "bar"), Cons[Label](Put("toto", "tata"), Cons[Label](Get("foo"), Nil[Label]())))
%\end{ShortCode}

\begin{Code}{PureScala}{lst:symkvstore}{Key-value store implementation}
sealed abstract class Label
object Label {
  case class Get(key: String) extends Label
  case class Put(key: String, value: String) extends Label
}

sealed abstract class Op
case class Pure(value: Option[String]) extends Op
case class Get(key: String, next: Option[String] => Op) extends Op
case class Put(key: String, value: String, next: () => Op) extends Op

def get(key: String)(next: Option[String] => Op): Op = Get(key, next)
def put(key: String, value: String)(next: () => Op): Op = Put(key, value, next)
def pure(value: Option[String]): Op = Pure(value)

def interpret(op: Op)(kv: Map[String, String], trace: List[Label]) = op match {
  case Get(key, next) =>
  	interpret(next(kv.get(key)))(kv, Label.Get(key) :: trace)
  case Put(key, value, next) =>
  	interpret(next())(kv.updated(key, value), Label.Put(key, value) :: trace)
  case Pure(value) =>
  	(value, trace)
}
\end{Code}

\subsection{Conclusion}

\TODO{Conclusion}

\subsection{Further Work}

\subsubsection*{Function Annotations}

Let's look at an interesting application of symbolic evaluation

\begin{enumerate}
\item Implement an interpreter $I(program, inputs)$ for a programming language $L$ in a host language $H$
\item Write a program $p$ in language $L$
\item Symbolically execute the interpreter $I$ over this program $p$ while keeping  $inputs$ abstract, ie. symbolically evaluate $I(p, inputs)$.
\item They would end up with a "compiled" version of this program, represented as a program in the host language $H$. This resulting program could then be compiled to a lower-level language, and would have good chances of running much faster than the original program.

This technique of partially evaluating an interpreter over a known program is known as the \textit{1st Futamura projection}, and can theoretically be applied to the symbolic evaluator itself, as per the 2nd and 3rd projections. \cite{futamura}

It would thus be interesting to enable users to ask Stainless to symbolically evaluate a given function by annotating it with an annotation, and then either print the resulting PureScala program or just substitute it for the function's original body. We show below a simple example involving an interpreter for arithmetic expressions, as well as the result yielded by a preliminary experiment.

\begin{ShortCode}{PureScala}
sealed trait Expr
case class Var(name: String)     extends Expr
case class Num(value: Int)       extends Expr
case class Add(l: Expr, r: Expr) extends Expr
case class Mul(l: Expr, r: Expr) extends Expr

def interpret(expr: Expr, ctx: Map[String, Int]): Int = expr match {
  case Num(value) => value
  case Var(name)  => ctx(name)
  case Add(l, r)  => interpret(l, ctx) + interpret(r, ctx)
  case Mul(l, r)  => interpret(l, ctx) * interpret(r, ctx)
}

val program: Expr = Mul(Num(10), Add(Var("x"), Num(2)))

@symeval
def compiled(ctx: Map[String, Int]): Int = {
  interpret(program, ctx) // ==> 10 * (ctx("x") + 2)
}
\end{ShortCode}

%------------------------------------------------------------------------

\clearpage
\section{Verifiying Actor Systems}
\label{actors}

\subsection{Motivation}

\TODO{Motivation}

\subsection{The Actor Model}

\subsubsection{Introduction}

\TODO{Actor Model}

\subsubsection{Akka}

\TODO{Akka}

\subsection{A Simple Actor Model for Verification}

\subsubsection{Differences with Akka}

The most notable difference between our model and the one implemented in Akka\footnote{Akka Documentation: Message Delivery Reliability - \url{https://doc.akka.io/docs/akka/current/general/message-delivery-reliability.html} (archive: \url{http://archive.is/XU8if})}, is that we rely on \textit{exactly-once} delivery of messages. We experimented with a weaker model that only relied on \textit{at-most-once} delivery but it quickly became clear that the amount of work needed to verify the very same systems we describe below would be too much in the context of this project.

\subsubsection{Implementation}

\subsubsection*{Message}

In our framework, messages are modelled as constructors of the \InlineS{Msg} abstract class.

\begin{ShortCode}{PureScala}
abstract class Msg
case class Hello(name: String) extends Msg
\end{ShortCode}

\vspace{-15pt}
\subsubsection*{Actor Reference}

Each actor is associated with a unique and persistent reference, modelled as an instance of the \ActorRef abstract class.

\begin{ShortCode}{PureScala}
abstract class ActorRef
case class Primary() extends ActorRef
\end{ShortCode}

\vspace{-15pt}
\subsubsection*{In-flight Messages}

In-flight messages are represented as a product of the \ActorRef of the destination actor, and the message itself.

\begin{ShortCode}{PureScala}
case class Packet(dest: ActorRef, payload: Msg)
\end{ShortCode}

\vspace{-15pt}
\subsubsection*{Actor Context}

When a message is delivered to an actor, the latter is provided with a context,
which holds a reference to itself, and a mutable list of \InlineS{Packet}s to send.

\begin{ShortCode}{PureScala}
case class ActorContext(
  self: ActorRef,
  var toSend: List[Packet]
)
\end{ShortCode}

\vspace{-15pt}
\subsubsection*{Behavior}

A behavior specifies both the current state of an actor, and how this one should 
process the next incoming message. In our framework, these are modelled as a subclass 
of the abstract class \InlineS{Behavior}, which defines a single abstract method 
\InlineS{processMsg}, to be overriden for each defined behavior.

Using the provided \InlineS{ActorContext}, the implementation of the \InlineS{processMsg}
method can both access its own reference, and register messages to be sent after the
execution of the method is complete. It is also required to return a new \InlineS{Behavior}

\begin{ShortCode}{PureScala}
abstract class Behavior {
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior
}
\end{ShortCode}

%\subsubsection*{Transition}
%
%Whenever a message is processed, we record the transition between the previous 
%state of the system and the one after the message has been been processed. We keep 
%track of this information as an instance of the \InlineS{Transition} class, which 
%holds: the \InlineS{Msg} that has been delivered, its sender and receiver, the new 
%behavior of the destination actor, and the list of \InlineS{Packet}s the destination 
%actor wants to send.
%
%\begin{ShortCode}{PureScala}
%case class Transition(
%  from: ActorRef,
%  to: ActorRef,
%  msg: Msg,
%  newBehavior: Behavior,
%  toSend: List[Packet]
%)
%\end{ShortCode}

\vspace{-15pt}
\subsubsection*{Actor System}

The state of the Actor system at a given point in time is modelled as a case class, 
holding the behavior associated with each actor reference, and the list of in-flight messages between any two actors.

% as well as a trace of the execution up to that point, modelled as a list of \InlineS{Transition}s.

\begin{ShortCode}{PureScala}
case class ActorSystem(
  behaviors: CMap[ActorRef, Behavior],
  inboxes: CMap[(ActorRef, ActorRef), List[Msg]]
)
\end{ShortCode}
% trace: List[Transition]

The \InlineS{ActorSystem} class is equipped with a \InlineS{step} method, which takes 
a pair of \ActorRef as arguments, and is in charge of delivering the oldest message 
found in the corresponding inbox, and which returns the new state of the system after 
the aforementioned message has been processed.

\begin{ShortCode}{PureScala}
def step(from: ActorRef, to: ActorRef): ActorSystem
\end{ShortCode}

\subsection{Operational Semantics}
\label{semantics}

We formulate the small-step operational semantics of our Actor model in 
\RefFig{fig:opsem}, where $s: \stt{ActorSystem}$ is an Actor system,
$m: \stt{Msg}$ is a message,
$n, n_{to}, n_{from}: \stt{ActorRef}$ are references,
$b, b': \stt{Behavior}$ are behaviors,
$ps: \stt{List[Packet]}$ a list of packets to send,
% $t: \stt{Transition}$ is a transition,
$c: \stt{ActorContext}$ is a context,
and $\emptyset_n: \stt{ActorContext}$ is the empty context for an actor whose
self-reference is $n$, defined as $\emptyset_n := \stt{ActorContext}(n, \stt{Nil})$.

\begin{figure}[!h]
\begin{framed}
 
\begin{equation}
\dfrac{
  \not\exists m \in \stt{$s$.inboxes}(n_{from}, n_{to})
}{
  \stt{$s$.step}(n_{from}, n_{to}) \leadsto \stt{s}
}
\tag{STEP-NOMSG}
\end{equation}

\vspace{10pt}
\begin{equation}
\dfrac{
  \exists m \in \stt{$s$.inboxes}(n_{from}, n_{to}) \qquad
  \stt{$s$.deliverMsg}(n_{to}, n_{from}, m) \leadsto (b, ps, t)
}{
  \stt{$s$.step}(n_{from}, n_{to}) \leadsto s \uplus (n_{to} \mapsto b, \ldots, t)
}
\tag{STEP}
\end{equation}

\vspace{10pt}
\begin{equation}
\dfrac{
  \stt{$s$.behaviors($n_{to}$).processMsg}(m, \emptyset_{n_{to}}) \leadsto (b, c) 
}{
  \stt{$s$.deliverMsg}(n_{to}, n_{from}, m) \leadsto (b, \stt{$c$.toSend}, t)
}
\tag{DELIVER-MSG}
\end{equation}

\vspace{10pt}
\begin{equation}
\dfrac{
  \stt{$b$.processMsg}(m, \emptyset_{n_{to}}) = i_1 ::\, \ldots ::\,i_n ::\, b' ::\,\stt{Nil} \qquad
  \langle i_1 ::\, \ldots ::\,i_n ::\,\stt{Nil}, \emptyset_{n_{to}} \rangle \longrightarrow c
}{
   \stt{$b$.processMsg}(m, \emptyset_{n_{to}}) \leadsto (b', c)
}
\tag{PROCESS-MSG}
\end{equation}

\vspace{10pt}
\begin{equation}
\dfrac{\empty}{
   \langle \stt{Nil}, c \rangle \longrightarrow c
}
\tag{I-NIL}
\end{equation}

\vspace{10pt}
\begin{equation}
\dfrac{
  \langle i, c \rangle \longrightarrow c'
}{
  \langle \stt{$i ::\,is$}, c \rangle \Rightarrow \langle is, c' \rangle
}
\tag{I-CONS}
\end{equation}

\vspace{10pt}
\begin{equation}
\dfrac{
  \empty
}{
  \langle n\ \stt{!}\ m, c \rangle \longrightarrow (b',\ \stt{$c$.copy(toSend $\mapsto$ ($n$, $m$) $::$ $c$.toSend)})
}
\tag{I-SEND}
\end{equation}

\end{framed}
\vspace{-10pt}
\caption{Operational semantics\label{fig:opsem}}
\end{figure}

\subsection{Proving Invariants}
\label{invariants}

After having defined an Actor system with our framework, one might want to verify that this 
system preserves some invariant between each step of its execution. That is to say, 
for an \InlineS{ActorSystem} $s$, any two \ActorRef $n, m$,
and an invariant \InlineS{inv: ActorSystem $\ \to\ $ Boolean}, if $\texttt{inv}(s)$ holds, 
then $\texttt{inv}(s\texttt{.step}(n, m))$ should hold as well. We express this 
property more formally in \RefFig{fig:stepinvariant}. This property can be easily expressed in PureScala, as shown in \RefCode{lst:preserveInv}.

\begin{figure}[!h]
$$\forall s: \stt{ActorSystem},\, n: \stt{ActorRef},\, m: \stt{ActorRef}.\ \stt{inv($s$)} \implies \stt{inv($s$.step($n, m$))}$$
\vspace{-20pt}
\caption{Invariant preservation property\label{fig:stepinvariant}}
\end{figure}

\begin{Code}{PureScala}{lst:preserveInv}{Invariant preservation theorem in PureScala}
def inv(s: ActorSystem): Boolean = {
  /* ... */
}

def preserveInv(s: ActorSystem, n: ActorRef, m: ActorRef): Boolean = {
  require(inv(s))
  inv(s.step(n, m))
} holds
\end{Code}

When encoutering such a definition, Stainless will generate a verification condition 
equivalent to \RefFig{fig:stepinvariant}, which will then be discharged to Inox and the underlying SMT solver.

%\subsection{Reasoning About Traces}
%\label{traces}
%
%\TODO{Traces}

\subsection{Case studies}
\label{casestudies}

\subsubsection{Increment-based Replicated Counter}
\label{repcounterinc}

As a first and very simple case study, we will study an Actor system which models a
replicated counter, which can only be incremented by one unit. This system is 
composed of two actors, a primary counter whose reference is \stt{Primary()},
and a backup counter whose reference is \stt{Backup()}.
Each of these reference is associated with a behavior: the primary counter reference with
an instance of \stt{PrimaryB}, and the backup counter reference with an instance 
of \stt{BackupB}, both of which hold a positive integer, representing the value of the
counter. Whenever the primary actor receives a message \stt{Inc()}, it forwards that
message to the backup actor, and returns a new instance of \stt{PrimaryB} with the
counter incremented by one. When the backup actor receives an \stt{Inc()} message,
it just returns a new instance of \stt{BackupB} with the counter incremented by one. 
The corresponding PureScala implementation can be found
in \RefCode{lst:ReplicatedCounterInc}.

\begin{Code}{PureScala}{lst:ReplicatedCounterInc}{Increment-based replicated counter implementation}
case class Primary() extends ActorRef
case class Backup()  extends ActorRef

case class Inc() extends Msg

case class PrimaryB(counter: BigInt) extends Behavior {
  require(counter >= 0)

  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case Inc() =>
      Backup() ! Inc()
      PrimaryB(counter + 1)
  }
}

case class BackupB(counter: BigInt) extends Behavior {
  require(counter >= 0)

  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case Inc() => BackupB(counter + 1)
  }
}
\end{Code}

Given such a system, one might want to prove that the following invariant is 
preserved between each step of its execution:

\begin{Code}{PureScala}{lst:repcounterincinv}{Increment-based replicated counter invariant}
def invariant(s: ActorSystem): Boolean = {
  s.inboxes((Backup(), Backup())).isEmpty && {
    (s.behaviors(Primary()), s.behaviors(Backup())) match {
      case (PrimaryB(p), BackupB(b)) =>
        p.value == b.value + s.inboxes(Primary() -> Backup()).length
      case _ => false
    }	
  }
}
\end{Code}

This invariant specifies that the \stt{Backup()} actor does not send itself any messages, that both actors have the proper corresponding behavior, and that, last but not least, the value of the primary counter is equal to the value of the backup counter added to the number of messages that are yet to be delivered to the backup actor.\\

We can now define the actual theorem we want Stainless to prove for us:

\begin{Code}{PureScala}{lst:repcounterincthm}{Replicated counter theorem (increment)}
def preserveInv(s: ActorSystem, n: ActorRef, m: ActorRef): Boolean = {
  require(invariant(s))
  invariant(s.step(n, m))
} holds
\end{Code}

\subsubsection{Delivery-based Replicated Counter}

\RefCode{lst:ReplicatedCounterDel} shows a variant of the previous case study, where instead of having the primary actor forward the \stt{Inc()} message to the backup actor, the former instead sends the latter the new value.

\begin{Code}{PureScala}{lst:ReplicatedCounterDel}{Delivery-based Replicated counter implementation}
case class Primary() extends ActorRef
case class Backup()  extends ActorRef

case class Inc() extends Msg
case class Deliver(c: BigInt) extends Msg

case class PrimaryB(counter: BigInt) extends Behavior {
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case Inc() =>
      Backup() ! Deliver(counter + 1)
      PrimaryB(counter + 1)

    case _ => Behavior.same
  }
}

case class BackupB(counter: BigInt) extends Behavior {
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case Deliver(c) => BackupB(c)
    case _          => Behavior.same
  }
}
\end{Code}

The invariant now reads slightly differently, as can be seen in \RefCode{lst:ReplicatedCounterDelInv}.

\begin{Code}{PureScala}{lst:ReplicatedCounterDelInv}{Delivery-based replicated counter invariant}
def invariant(s: ActorSystem): Boolean = {
  validBehaviors(s)                           &&
  noMsgsToSelf(Primary()).isEmpty             &&
  noMsgsToSelf(Backup()).isEmpty              &&
  noMsgsToSelf(Backup() -> Primary()).isEmpty && {
    val PrimBehav(p) = s.behaviors(Primary())
    val BackBehav(b) = s.behaviors(Backup())
    val bInbox       = s.inboxes(Primary() -> Backup())

    p.value >= b.value && isSorted(bInbox) && bInbox.forall {
      case Deliver(Counter(i)) => p.value >= i
      case _                   => true
    }
  }
}
\end{Code}

\subsubsection{Lock Service}

\RefCode{lst:LockService} shows the implementation of a lock service using our framework. In this case study, an actor acts as a server holding a lock on some resource, while a number of other actors (the "agents") act as clients of the lock service, each potentially trying to acquire the lock on the resource. To model a variable number of actors with the same implementation, we define their reference as a case class parametrized by a \TODO{unique} identifier.

An obvious property we might want to prove is that, at any time, at most one of those agents thinks that it holds the lock. Additionally, we'd like to ensure that such an agent is actually the same one that the server granted the lock too. We express this property in \RefCode{lst:LockServiceInv}.

\begin{Code}{PureScala}{lst:LockService}{Lock service implementation}
case class Server() extends ActorRef
object Server {
  case class Lock(agent: ActorRef) extends Msg
  case class Unlock(agent: ActorRef) extends Msg
}

case class Agent(id: Int) extends ActorRef
object Agent {
  case object Lock   extends Msg
  case object Unlock extends Msg
  case object Grant  extends Msg
}

// The head of `agents` holds the lock, the tail are waiting for the lock
case class ServerB(agents: List[ActorRef]) extends Behavior {
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case Server.Lock(agent) if agents.isEmpty =>
      agent ! Agent.Grant
      ServerB(List(agent))

    case Server.Lock(agent) =>
      ServerB(agents :+ agent)

    case Server.Unlock(agent) if agents.nonEmpty =>
      val newAgents = agents.tail
      if (newAgents.nonEmpty) newAgents.head ! Agent.Grant
      ServerB(newAgents)

    case _ =>
      Behavior.same
  }
}

case class AgentB(holdsLock: Boolean) extends Behavior {
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case Agent.Lock =>
      Server() ! Server.Lock(ctx.self)
      Behavior.same

    case Agent.Unlock if holdsLock =>
      Server() ! Server.Unlock(ctx.self)
      AgentB(false)

    case Agent.Grant =>
      AgentB(true)

    case _ =>
      Behavior.same
  }
}
\end{Code}

\begin{Code}{PureScala}{lst:LockServiceInv}{Lock service invariant}
def hasLock(s: ActorSystem, a: ActorRef): Boolean = {
  s.behaviors(a) match {
    case AgentB(hasLock) => hasLock
    case _ => false
  }
}

def mutex(s: ActorSystem): Boolean = forall { (a: ActorRef, b: ActorRef) =>
  (a != b) ==> !(hasLock(s, a) && hasLock(s, b))
}

def hasLockThenHead(s: ActorSystem): Boolean = forall { (ref: ActorRef) =>
  hasLock(s, ref) ==> {
    s.behaviors(Server()) match {
      case ServerB(Cons(head, _)) => head == ref
      case _ => false
    }
  }
}

def invariant(s: ActorSystem): Boolean = {
  mutex(s) && hasLockThenHead(s)
}
\end{Code}

\TODO{Lock service invariant proof}

%\subsubsection*{Leader Election}
%
%\TODO{Leader election}

%\subsubsection*{Key-value store}
%
%\TODO{KV store}

\subsection{Spawning Actors}
\label{spawn}

\TODO{Name Uniqueness}

Up until now, our framework has only been able to model Actor systems with a static topology, ie. systems where no new actors besides the ones that are statically defined can be spawned. Let's now attempt to enrich our model to account for dynamic topologies.

To this end, we modify the \ActorRef definition to include both a name and an optional field holding a reference to its parent \ActorRef if any. We also add a new constructor of the \ActorRef data type, which will be assigned to actors spawned from another actor.

\begin{ShortCode}{PureScala}
abstract class ActorRef(
  name: String,
  parent: Option[ActorRef]
)

case class Child(name: String, getParent: ActorRef)
  extends ActorRef(name, Some(getParent))
\end{ShortCode}

In order for actors to spawn other actors, by specifying their name and associated 
initial behavior, we modify the \stt{ActorContext} class as follows:

\begin{ShortCode}{PureScala}
case class ActorContext(
  self: ActorRef,
  var toSend: List[Packet],
  var toSpawn: List[(ActorRef, Behavior)]
) {
  def spawn(behavior: Behavior, name: String): ActorRef = {
    val id: ActorRef = Child(name, self)
    toSpawn = toSpawn :+ (id, behavior)
    id
  }
  /* ... */
}
\end{ShortCode}

As can be seen in the listing above, the context now keeps track of the names and 
behaviors of the actors to be spawned, and provides a \stt{spawn} method which is in  charge of constructing the \ActorRef of the spawned actor, storing it along with the  behavior within the context, and returning the newly generated reference.\\

Let's now update the case study in \RefCode{lst:ReplicatedCounterInc} to accommodate 
these changes, while noting that we are not making use of this new feature yet. Only 
the two \ActorRef definitions need to be touched, becoming:

\begin{ShortCode}{PureScala}
case class Primary() extends ActorRef("primary", None())
case class Backup()  extends ActorRef("backup", None())
\end{ShortCode}

Unfortunately, when we now feed the updated benchmark to Stainless, the latter is be 
unable to prove the very same theorem it previously had no issue whatsoever with.
All is not lost though, as turning on the symbolic evaluator described in
\RefSec{symbolic} enables Stainless to verify the program in less than 10 seconds.\\

\RefCode{lst:spawncode} defines a simple system with a dynamic topology, where one actor, deemed \stt{Primary}, waits for a \stt{Spawn} message to spawn a child actor, and change its behavior from \stt{BeforeB} to \stt{AfterB} in order to keep track of the reference to the child. The invariant we would to verify holds here, states that, if the \stt{Primary} actor has behavior \stt{BeforeB()}, then the behavior associated with the \ActorRef of its child actor must be \stt{Stopped}. On the other hand, if the \stt{Primary} actor has behavior \stt{AfterB(child)}, then the behavior associated with \stt{child} must be \stt{ChildB}. This test case verifies promptly, provided the symbolic evaluator is enabled.

\begin{Code}{PureScala}{lst:spawncode}{}
case object Primary extends ActorRef("primary")
case object Spawn extends Msg

case class BeforeB() extends Behavior {
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case Spawn =>
      val child = ctx.spawn(ChildB(), "child")
      AfterB(child)
  }
}

case class AfterB(child: ActorRef) extends Behavior {
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case _ => Behavior.same
  }
}

case class ChildB() extends Behavior {
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case _ => Behavior.same
  }
}

def invariant(s: ActorSystem): Boolean = {
  s.behaviors(Primary) match {
    case BeforeB() =>
      s.isStopped(Child("child", Primary()))
    case AfterB(child) =>
      s.behaviors(child) == ChildB()

    case _ => false
  }
}

def theorem(s: ActorSystem, from: ActorRef, to: ActorRef): Boolean = {
  require(invariant(s))
  invariant(s.step(from, to))
} holds
\end{Code}

\subsection{Running an Actor System on Akka}
\label{akka}

While the verification of Actor systems is in itself an interesting endeavour, it is not of much use unless one is able to run these systems, potentially in a distributed environment. In the Scala ecosystem, the most widely used real-world Actor system is Akka \TODO{REF}. \RefCode{lst:akkashim} shows a shallow shim which allows to run an Actor system developed with our framework within Akka, with only a few alterations to the original program.

\begin{Code}{PureScala}{lst:akkashim}{Akka shim for our Actor system framework}
import akka.actor

type ActorRef = actor.ActorRef

case class ActorContext(self: actor.ActorRef, ctx: actor.ActorContext)

class Wrapper(var behavior: Behavior)
  extends actor.Actor with actor.ActorLogging {

  implicit val ctx = ActorContext(self, context)

  def receive = {
    case msg: Msg =>
      log.info(s"$\$${behavior}: $\$${msg}")
      behavior = behavior.processMsg(msg)

    case _ => ()
  }
}

abstract class ActorSystem(val name: String) {
  lazy val system = actor.ActorSystem(name)

  def spawn(behavior: Behavior, name: String): actor.ActorRef = {
    system.actorOf(actor.Props(new Wrapper(behavior)), name = name)
  }

  def run(): Unit
}
\end{Code}

\TODO{Explain shim}

To this end, one must define a subclass of \stt{ActorSystem}, and provide an implementation of its \stt{run} method. Within this method, one can spawn new top-level actors, get a reference to those, and send them messages. \RefCode{lst:akkashimex} shows such an implementation for the replicated counter described in \RefSec{repcounterinc}. 

\begin{Code}{PureScala}{lst:akkashimex}{Akka shim for our Actor system framework}
@extern
object System extends ActorSystem("rep-counter-sys") {
  def run(): Unit = {
    val backup  = spawn(BackupB(0), "backup")
    val primary = spawn(PrimaryB(0, backup), "primary")

    primary ! Inc()
  }
}

@extern
def main(args: Array[String]): Unit = {
  System.run()
}
\end{Code}

\subsection{Conclusion}

\TODO{Conclusion}

\subsection{Further Work}

\TODO{Further work}

%\clearpage
%\section{Verification of Conflict-Free Replicated Data Types}
%\label{crdt}
%
%\textbf{\textcolor{Red}{Will only be included if time allows}}
%
%\subsection{Motivation}
%
%Because both faults and network partitions are a common occurrence in distributed systems, these often make use of data replication in order to improve reliability \TODO{citation}, which itself can lead to  consistency issues. One increasingly popular way to mitigate this problem is to model the replicated data using \textit{Conflict-free Replicated Data Types} (CRDTs) \cite{crdt} \cite{crdtstudy}. These data types come in two flavours: \textit{Commutative Replicated Data Types} (CmRDTs, or \textit{Op-based CRDTs}) and \textit{Commutative Replicated Data Types} (CvRDTs, or \textit{State-based CDRTs}).
%
%\TODO{Explain eventual consistency + both models + choice of CvRDTs}
%
%\subsection{Verifying CRDTs Implementations}
%
%\subsubsection{GCounter}
%\subsubsection{PNCounter}
%\subsubsection{GSet}
%\subsubsection{TwoPSet}
%\subsubsection{ORSet}
%
%\subsection{Conclusion}
%
%\TODO{Conclusion}

\clearpage
\section{Biparty Communication Protocols}
\label{biparty}

\subsection{Motivation}

\subsubsection{Session Types}
\TODO{Session Types}

\subsubsection{Value-level Encoding of Sessions}
\TODO{Value-level Encoding of Sessions}

\subsection{Linear Types in Stainless}

\newcommand{\lin}[1]{\stt{Linear[#1]}}

We now discuss our implementation of linear types in Stainless. One thing to note is that because the AST we are working with within Stainless is already typed, there is no need to write a full-fledged type checker. We will hence rather describe a \textit{linearity checker} for PureScala programs.

\subsubsection*{Introducing Linear Types}

We introduce a way to mark some types as \textit{linear}. To this end, we define a covariant type constructor \stt{Linear}, which simply holds a value of type \stt{A}. This type provides a \stt{!} method to consume the linear term and return the underlying value. This enables the user to call a method of the underlying type in a concise way. As the astute reader might have noticed, this effectively adds weakening to the linear type system, and, as we will see, some care will be needed to handle such conversions properly. For example, if one had a value \stt{foo} of type \stt{Linear[Option[A]]}, one could call the \stt{isEmpty} method on the underlying value by writing \stt{foo!.isEmpty}. While making the consumption of a linear value explicit in this way is good for reasoning about one's code, there is still a bit of clutter associated with it, we also introduce an opt-in implicit conversion \stt{delinearize} from any \stt{Linear[A]} to \stt{A}. At last, because converting a non-linear value of type \stt{A} to a linear value of type \stt{Linear[A]} is always safe, we provide a such an implicit conversion by default, \stt{linearize}. \RefCode{lst:lineardef} shows the full definitions. Because those will be extracted in a specific way, they are marked \stt{@ignore}.

\begin{Code}{PureScala}{lst:lineardef}{Linear wrapper for Scala types and values}
package stainless

import stainless.lang._
import stainless.annotation._

package object linear {

  @ignore
  class Linear[+A](_value: A) {
    def ! = _value
  }
  
  @ignore
  implicit def linearize[A](value: A): Linear[A] = new Linear(value)
  
  object implicits {
    @ignore
    implicit def delinearize[A](lin: Linear[A]): A = lin!
  }
}
\end{Code}

\subsubsection*{Preventing Weakening}

We now describe what it means for a linear term to be \textit{consumed}: a term \stt{t} of type \stt{Linear[A]}, for any type \stt{A}, is deemed \stt{consumed} in an expression $e$ when any of the following propositions is true:

\begin{itemize}
\item The underlying value of type \stt{A} is extracted, via the \stt{!} method, eg. $e = \stt{t!}$.
\item The term is assigned to a variable, eg. \stt{val s:\,Linear[A] = t}.
\item The term is supplied as an argument to function, eg. given \stt{def f(x:\,Linear[A]):\,B}, we have $e = \stt{f(t)}$.
\item The term is supplied as an argument to a method, eg. given a class \stt{C} with a method \stt{def m(x:\,Linear[A]):\,B}, a value $v:\, C$, we have $e = \stt{v.m(t)}$.
\item The term is supplied as an argument to a lambda, eg. given \stt{val l:\,Linear[A] => B}, we have $e = \stt{l(t)}$.
\item The term is supplied as an argument to a constructor, eg. given \stt{case class C(x: Linear[A])}, we have $e = \stt{C(t)}$.
\end{itemize}

\textit{Note: Method calls are subsumed by the first rule, as a linear value must first be delinearized with the \stt{!}\,operator before one can call a method on the underlying value.}\\

We now must ensure that no linear term is \textit{consumed} more than once. To this end, we must recursively walk down the AST, while keeping track of terms that have been consumed in a \textit{usage context}, in order to disallow subsequent uses of those terms. We will denote this context by $\Delta$. \TODO{\RefFig{fig:lintypesrules} presents the type-checking rules used to reject invalid programs.}\\

The astute reader will have noticed that the presence of the \stt{!}\,operator, if not handled carefully, would actually allow weakening. For example, given a value \stt{a:\,Linear[A]}, one could write \stt{val b:\, A = a.!}, and thus obtain a non-linear reference to the underlying value. To counter this, the linearity checker treats any expression of the form \stt{$e$.!}, with \stt{$e$:\,Linear[A]}, as having type \stt{Linear[A]} instead of \stt{A}.

\subsubsection*{Preventing Contraction}

Because linear logic does not allow contraction, we must also ensure that no linear term is \textit{dropped}, that is to say, that it is \textit{consumed} at least once. To this end, we first collect all linear variables being introduced in a function definition, for example as a parameter to the function, in a variable binding, or within a pattern in a \texttt{clause} (even as a wildcard). Then, after having ran the type-checking algorithm described in the previous section, we can make use of the resulting \textit{usage context} $\Delta$ to check whether each and every of those variable has indeed been \textit{consumed} at some point, and reject the program otherwise.

\subsubsection*{Linear Terms in Contracts}

It is important to note that, when running the linearity checker over a function with pre- and/or post-conditions, these are ignored for the following reason: a user might want to constrain either a linear parameter of some function, or its return value. If we ran the linearity checker on such contracts, then one would not be able to re-use the linear variable that is being constrained in the precondition, or would not be able to reference any linear parameter in the postcondition. \RefCode{lst:prepostlinear} shows such a use-case.

\begin{Code}{PureScala}{lst:prepostlinear}{Usage of a linear variable in a function's precondition}
def foo(x: Linear[Option[BigInt]]): BigInt = {
  require(!x.isEmpty && x.get > 0)
  x.get * 2
} ensuring { _ > 0 }
\end{Code}

Fortunately for us, because a function's contract will be statically verified by Stainless, there is no point to check it at runtime. Hence, in Stainless' library, both the \stt{require} function and the \stt{ensuring} method discard their body. For this reason, we can safely ignore linearity constraints in a function's contract.\\

\subsubsection*{Linear Data Types}

Because data types can contain linear fields, one must be careful as to when to allow values of such types to be introduced. Indeed, if one were to define a data type \stt{case class A(x:\,Linear[B])}, one should not be allowed to construct a non-linear term of type \stt{A}. That is because doing so would permit the user to have more than one (indirect) reference to the linear \stt{x} field, which is forbidden because of the No-Weakening rule. We must thus ensure that values such types are only introduced linearly, ie. as values of type \stt{Linear[A]}, whether it is as a function parameter, as a variable binding, or as field of another data type. \RefCode{lst:linearadt} features a few examples of this rule in action.

\begin{Code}{PureScala}{lst:linearadt}{Linear data types in action}
case class A(x: Linear[BigInt])

case class B(a: A)          // error
case class C(b: Linear[A])  // ok

def f(x: A): A = { // error
  x
}

def g(x: Linear[A]): Linear[A] = { // ok
  x
}

def h(x: C): Linear[A] = c match {
  case C(b) => b // ok
}

def i(x: BigInt): A = c match { // error
  A(x)
}

def j(x: BigInt): Linear[A] = c match {
  A(x) // ok
}

def k(x: BigInt): Linear[BigInt] = c match {
  A(x) match {
    case A(y) => y // error
  }
}
\end{Code}

\subsubsection*{Marking the Current Object as Linear}

Another issue arise when dealing with data types meant to be introduced linearly if these have associated methods. To understand why, let's look at an example. \RefCode{lst:linfile} shows a very simple API which allows to open a file, read its content line-by-line, or read all its content at once. We would like to make sure that, once a user opens a \stt{File} and receives the associated \stt{FileHandler}, the latter must be closed. Unfortunately, when implementing the \stt{contents} method, nothing prevents the programmer to call \stt{readLine} twice on the current object. That is because, Within \stt{contents}, \stt{this} has type \stt{FileHandler}, and calling any method on it will thus not consume it. As it is not possible in Scala to constrain the type of the current object, even with self-annotations, we introduce a method annotation \stt{@linear} which signals to the linearity checker that, within an annotated method of a class \stt{C}, \stt{this} should be considered to have type \stt{Linear[C]}. As methods inherit the annotations of their enclosing class, it is here enough to annotate the \stt{FileHandler} class with \stt{@linear}.

\begin{Code}{PureScala}{lst:linfile}{Linear File API}
class File {
  def open: Linear[FileHandler] = /* ... */
}

class FileHandler {
  def readLine: (Option[String], Linear[FileHandler]) = /* ... */
  def close: Unit = /* ... */
  
  def contents: String = {
    val (res, h) = this.readLine
    doSomething(this.readLine) // should be disallowed
    res match {
      case Some(line) =>
        line + h!.contents

      case None() =>
        h!.close
        ""
    }
  }
}
\end{Code}

\subsubsection*{Higher-Order Linear Functions}

\TODO{Discuss syntax for linear lambdas}

%\begin{landscape}
%\begin{figure}[htb]
%\begin{framed}
% 
%\begin{equation}
%\dfrac{
%  \Delta \vdash t:\,\lin{A}
%}{
%  \Delta \cup t \vdash t! : A
%}
%\end{equation}
%
%\begin{equation}
%\dfrac{
%  \Delta \vdash t:\,\lin{A} \qquad \Delta \cup t \vdash b:\,B
%}{
%  \Delta \cup t \vdash \stt{val x:\,\lin{A} = $t$; $b$} : B
%}
%\end{equation}
%
%\begin{equation}
%\dfrac{
%  \Delta \vdash f :\,(T_1, \ldots, \lin{$T_i$}, \ldots, T_n) \to S
%  \quad \Delta \vdash t_i : \lin{$T_i$} \\
%  \quad \Delta \vdash (t_1, \ldots, t_{i-1}) :\, (T_1, \ldots, T_{i-1})
%  \quad \Delta \cup t \vdash (t_{i+1}, \ldots, t_{i-1}) :\, (T_1, \ldots, T_{i-1})
%}{
%  \Delta \cup t \vdash f(t_1, \ldots, t_i \ldots, t_n) : S
%}
%\end{equation}
%
%\end{framed}
%\vspace{-10pt}
%\caption{Typing rules \label{fig:lintypesrules}}
%\end{figure}
%\begin{landscape}

\subsection{Sessions Library in PureScala}
\label{sessions_lib}

\RefCode{lst:sessions} shows the PureScala implementation of the \textit{lchannels} library. For the purpose of verification, we do not need a full-fledged implementation, but only declarations mirroring the Scala library. This way, one could run their implementation with the original library by simply linking against both it and the Stainless library, without our implementation.

\begin{Code}{PureScala}{lst:sessions}{Sessions library in PureScala}
type In[A]  = Linear[InChan[A]]
type Out[A] = Linear[OutChan[A]]

@linear @library
class InChan[A] {

  @extern
  def receive(implicit d: Duration): Linear[A] = {
    ???
  }

  def ?[B](f: Linear[A] => B)(implicit d: Duration): B = {
    f(receive)
  }
}

@linear @library
class OutChan[A] {

  @extern
  def send(msg: A): Unit = {
    ???
  }

  def !(msg: A): Unit = {
    send(msg)
  }

  @extern
  def !![B](h: Out[B] => A): In[B] = {
    ???
  }

  @extern
  def create[B](): (In[B], Out[B]) = {
    ???
  }
}
\end{Code}

\subsection{Case Studies}

\subsubsection{ATM Protocol}

Let's consider a protocol involving an ATM and its user.

\begin{enumerate}
\item The user authenticates herself by sending the ATM both her card number and PIN.
\item If the authentication succeeds, the ATM displays a menu to the user, who can then choose to:
\begin{enumerate}
\item Abort the process altogether.
\item Ask for her account's balance, in which case the server will reply with the balance, and displays the menu again.
\item If the authentication fails, the ATM notifies the user of the failure, and the process is aborted.
\end{enumerate}
\end{enumerate}

\RefCode{lst:atm_desc} shows the encoding of such a specification using the library described in \RefSec{sessions_lib}. \RefCode{lst:atm_impl} shows the corresponding valid implementation. At last, \RefCode{lst:atmmistake} shows an invalid implementation of the protocol that would still verify without the linearity checker. The three mistakes are discussed below.

\begin{Code}{PureScala}{lst:atm_desc}{ATM protocol description}
//Authentication request from the user
case class Authenticate(card: String, pin: String, cont: Out[Response])

// Authentication response from the ATM
sealed abstract class Response
case class Failure()                extends Response
case class Success(cont: Out[Menu]) extends Response

// Choices available to authenticated user
sealed abstract class Menu
case class CheckBalance(cont: Out[Balance]) extends Menu
case class Quit()                           extends Menu

// User account balance
case class Balance(amount: BigInt)(cont: Out[Menu])
\end{Code}

\begin{Code}{PureScala}{lst:atm_impl}{ATM protocol implemenation}
def atm(c: In[Authenticate]) = {
  c ? { auth => auth! match {  
    case Authenticate(card, pin, cont) if authenticated(card, pin) =>
      cont !! Success(_) ? menu(card)
  
    case Authenticate(_, _, cont)  =>
      cont ! Failure()
  } }
}

def menu(card: String)(menu: Linear[Menu]) = {
  menu! match {
    case CheckBalance(cont) =>
      cont !! Balance(balance(card))(_) ? menu(card)

    case Quit() => ()
  }
}

@extern
def authenticated(card: String, pin: String): Boolean = {
  /* ... */
}

@extern
def balance(card: String): BigInt = {
  /* ... */
}
\end{Code}

\begin{enumerate}
\item
If we make a terrible mistake while implemented the \stt{atm} function by not doing anything with its linear parameter \stt{c}, eg. just left its body empty, we would be greeted with the following error:

\begin{ShortCode}{PureScala}
$\texttt{\textbf{\textcolor{Red}{Error}}}$: linear variable `c` of type `Linear[In[Authenticate]]` is never used:
                 def atm(c: Linear[In[Authenticate]]): Unit = {
                         $\texttt{\textbf{\textcolor{Red}{\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum}}}$
\end{ShortCode}

Re-using the same channel twice would also give rise to an error:

\begin{ShortCode}{PureScala}
$\texttt{\textbf{\textcolor{Red}{Error}}}$: linear term `cont` has already been used: doSomething(cont)
                               $\texttt{\textbf{\textcolor{Red}{\textasciicircum\textasciicircum\textasciicircum\textasciicircum}}}$
$\texttt{\textbf{\textcolor{Blue}{Info}}}$: term used here: cont !! Balance(balance(card))(_) ? menu(card)
                                                            $\texttt{\textbf{\textcolor{Red}{\textasciicircum\textasciicircum\textasciicircum\textasciicircum}}}$
\end{ShortCode}

\item
In case we forget to send back a failure notification when the authentication fails. The linearity checker will realize that the linear \stt{cont} is not consumed in every branch of the pattern match, and will pinpoint its introduction:

\begin{ShortCode}{PureScala}
$\texttt{\textbf{\textcolor{Red}{Error}}}$: linear variable `cont` of $\texttt{type}$ `Linear[OutChan[Response]]` is never used:
                 case Authenticate(_, _, cont) =>
                                         $\texttt{\textbf{\textcolor{Red}{\textasciicircum\textasciicircum\textasciicircum\textasciicircum}}}$
\end{ShortCode}

\item
At last, let's see what happens if we do not handle the reply to the \stt{Success} message sent in case the authentication succeeds. Because the expression \stt{cont !! Success(\_)} has type \stt{In[Menu]}, one could expect the Scala compiler to raise a type error, as the \stt{atm} function has return type \stt{Unit}. Unfortunately, the Scala compiler will happily convert any value to \stt{Unit} if it occurs at the end of a block. But because \stt{In[Menu]} is a linear type, the linearity checker will notice that the corresponding value is being discarded, and will raise an error:

\begin{ShortCode}{PureScala}
$\texttt{\textbf{\textcolor{Red}{Error}}}$: linear term cannot be discarded: cont !! Success(_)
                                        $\texttt{\textbf{\textcolor{Red}{\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum}}}$
\end{ShortCode}
\end{enumerate}

\begin{Code}{PureScala}{lst:atmmistake}{Wrong implementation of the ATM protocol}
def atm(c: In[Authenticate]): Unit = {
  c ? { auth => auth! match {  
    case Authenticate(card, pin, cont) if authenticated(card, pin) =>
      // 3. do not wait for a reply to `Success` message
      cont !! Success(_)
  
    case Authenticate(_, _, cont) =>
      // 1. does not send back a Failure message

  } }
}

def menu(card: String)(menu: Linear[Menu]): Unit = {
  menu! match {
    case CheckBalance(cont) =>
      cont !! Balance(balance(card))(_) ? menu(card)
      
      // 2. `cont` has already been used
      doSomething(cont)

    case Quit() => ()
  }
}
\end{Code}

\subsubsection{TLS 1.2 Handshake}

\TODO{TLS 1.2 Handshake}

\subsection{Conclusion}

\TODO{Conclusion}

\subsection{Further Work}

\TODO{Further Work}

\clearpage
\section{Conclusion}
\label{conclusion}

\TODO{Conclusion}

\appendix

\clearpage

\nocite{*}
\bibliographystyle{ieeetr}
\bibliography{report}

\end{document}
