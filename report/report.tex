\documentclass[a4paper,twoside]{article}
\usepackage[a4paper]{geometry}

% \usepackage[a4paper,showframe]{geometry} % add showframe for debug
% \usepackage{titleps}

\usepackage[pagestyles]{titlesec}
\usepackage[all]{nowidow} % avoid orphan lines

% Extra colours; need to be first
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}

% Basic packages
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

% Landscape mode
\usepackage{pdflscape}

% Additional font
\usepackage{FiraMono}

% Bibtex+cite
\usepackage{cite}
\usepackage{url}
\usepackage[nottoc,numbib]{tocbibind}

% URL
\usepackage[
  colorlinks=true,
  urlcolor=blue,
  citecolor=black,
  linkcolor=.
]{hyperref}

% Lists
\usepackage{scrextend}
\addtokomafont{labelinglabel}{\sffamily}
\usepackage[inline]{enumitem} % for enumerate* environment.

% Maths & symbols
\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{pifont}
\usepackage{framed}
\usepackage{stmaryrd}
\newcommand{\lb}[2]{\llbracket\, #1\,;\, #2\, \rrbracket}

% Mono font
\usepackage[scaled]{beramono}

% Spacing
\usepackage{xspace}

% Graphics
\usepackage{graphicx}

% Table
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{multirow}

% Floating placement
\usepackage{placeins}
% use \FloatBarrier before a \section to ensure all floating are displayed
% before the new section

% Caption styling
\usepackage[justification=centering]{caption}

% Additional colours
\definecolor{c1}{HTML}{006C71}
\definecolor{c2}{HTML}{005155}
\definecolor{c3}{HTML}{FF8928}
\definecolor{c4}{HTML}{E86900}
\colorlet{ImportantCode}{ForestGreen}
\colorlet{ImportantCode2}{RubineRed}
\colorlet{ImportantCode3}{RedOrange}

% TIKZ & related packages/settings
\usepackage{tikz}
\usepackage{pgfplots}
\usetikzlibrary{shapes,fit,backgrounds,arrows,positioning,chains,patterns}
% \pgfplotsset{compat = 1.14}

% for caching tikz pictures
% \usetikzlibrary{external}
% \tikzexternalize[prefix=tikz-figures/]
% \pgfrealjobname{tikz}

% Layout
\usepackage{chngpage}
\usepackage{rotating}

% Line spacing
\linespread{1.1}

% Listings
\usepackage{listings,multicol}
\usepackage{lstscala}

\lstdefinelanguage{PureScala}{ % Using `Scala` result in a infinite recursion
  style=scala-color,
  morekeywords={[2]Unit,Boolean,Byte,Int,BigInt,String,Char,Option,List,true,false},
  %keywordstyle={[2]\color{blue!30!darkgray}\bfseries}
}

\newcommand{\Inline}[1]{\lstinline[basicstyle=\small\ttfamily,columns=fixed]|#1|}
\newcommand{\InlineS}[1]{\lstinline[language=PureScala,basicstyle=\small\ttfamily,columns=fixed]|#1|}
% %\newcommand{\inlineScala}[1]{\lstinline[language=MyScala,breaklines=true,breakatwhitespace=true]|#1|}

% Use code in description item, Based on http://tex.stackexchange.com/a/181325/77356
\newcommand*{\lstitem}[1]{
  \setbox0\hbox{\textbf{\Inline{#1}}}
  \item[\usebox0]
}

% %\lstset{aboveskip=5pt,belowskip=10pt}
% \lstset{captionpos=b,abovecaptionskip=1em}

% For long listings
\lstdefinestyle{LongCode}{
  %aboveskip=1ex,
  basicstyle=\small\ttfamily,
  % basicstyle=\scriptsize\ttfamily,
  % basicstyle=\tiny\ttfamily,
  %belowskip=1ex,
  breaklines=true,
  postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow}},
  breakautoindent=false,
  %breakatwhitespace=false,
  %columns=fullflexible,
  multicols=2,
  framerule=0pt,
  framexrightmargin=0em,
  framexleftmargin=0em,
  % numbers=left,
  % numberstyle=\footnotesize\sffamily,
  tabsize=2
}


% Env for short code: no label, no caption and "inlined" with a box
\lstnewenvironment{ShortCode}[1]
    {
      \lstset{
        language=#1,
        basicstyle=\small\ttfamily,
        frame=trBL % box the frame & double line on bottom and left side
      }
    }
    {
    }

% Env for longer code: label, caption and "floating" with a box
\lstnewenvironment{Code}[3]
    {
      \lstset{
        language=#1,
        basicstyle=\small\ttfamily,
        label={#2},
        caption=#3,
        captionpos=b, % bottom
        float=!h,     % "here"
        frame=trBL,   % box the frame & double line on bottom and left side
        % frameround=tttt
      }
    }
    {
      % DEBUG:
      % 1: #1 \\
      % 2: #2 \\
      % 3: #3
    }



% Tables
% \newcommand{\heading}[1]{\multicolumn{1}{c}{\textbf{#1}}}
% \newcommand{\vheading}[1]{\rotatebox[origin=c]{90}{~\textbf{#1}~}}


% To centre table too wide
% credit: http://tex.stackexchange.com/a/27099/77356
\makeatletter
\newcommand*{\centerfloat}{%
  \parindent \z@
  \leftskip \z@ \@plus 1fil \@minus \textwidth
  \rightskip\leftskip
  \parfillskip \z@skip}
\makeatother

% General styling
%\let\oldsection\section
%\renewcommand\section{\cleardoublepage\oldsection}

% For some reason page margin are swapped when having a title page with a
% different geometry. We fix that manually by 1) swapping the margin and
% 2) swapping the page number position (page style)
% credit: http://tex.stackexchange.com/a/36016/77356
\makeatletter
\newcommand*{\flipmargins}{%
  \clearpage
  \setlength{\@tempdima}{\oddsidemargin}%
  \setlength{\oddsidemargin}{\evensidemargin}%
  \setlength{\evensidemargin}{\@tempdima}%
  \if@reversemargin
    \normalmarginpar
  \else
    \reversemarginpar
  \fi
}
\makeatother

\newpagestyle{mystyle_no_header}{
  \setfoot[\thepage][][]{}{}{\thepage}
}

\newpagestyle{mystyle}{
  % \sethead[][][\firsttitlemarks\ifthesubsection{\thesubsection~\subsectiontitle}{\thesection~\sectiontitle}]{\firsttitlemarks\ifthesubsection{\thesubsection~\subsectiontitle}{\thesection~\sectiontitle}}{}{}
  \sethead[\thesection~\sectiontitle][][]{}{}{\thesection~\sectiontitle}
  % \setfoot[][][\thepage]{\thepage}{}{}
  \setfoot[\thepage][][]{}{}{\thepage}
}

% Additional macros
\newcommand{\TODO}[1]{\textcolor{YellowOrange}{(TODO: #1)}} % for inline TODO
%\newcommand{\TODO}[1]{\textcolor{YellowOrange}{(TODO)}} % for inline TODO
% \newcommand{\TODO}[1]{\underline{(#1)}} % for inline TODO, PRINTING
\newcommand{\URL}[2]{#2:\xspace\href{#1}{#1}}
\newcommand{\RefSec}[1]{Section~\ref{#1}}
\newcommand{\RefTable}[1]{Table~\ref{#1}}
\newcommand{\RefApp}[1]{Appendix~\ref{#1}}
\newcommand{\RefFig}[1]{Figure~\ref{#1}}
\newcommand{\RefCode}[1]{Listing~\ref{#1}}
\newcommand{\BigO}[1]{\mathcal{O}(#1)}
\newcommand{\ActorRef}{\InlineS{ActorRef}\ }
\newcommand{\stt}[1]{\texttt{\small{#1}}}
%\newcommand{\stt}[1]{\InlineS{#1}}

%%%

\title{Systems Modeling With Stainless}

\date{
%  {\small Version 0.6}\\
  {\small (Draft)}\\
  January 2018
}

\author{Romain Ruetschi}

\begin{document}

\newgeometry{centering}
\pagenumbering{gobble}
\maketitle

\vfill

\begin{abstract}

\TODO{Abstract}

\end{abstract}

\vfill

\begin{center}
    Master Thesis Project under the supervision of \\
    Prof. Viktor Kuncak \& Dr. Jad Hamza \\
    Lab for Automated Reasoning and Analysis LARA - EPFL
\end{center}

\begin{center}
    \includegraphics[width = 40mm]{res/epfl-logo}
\end{center}

\clearpage\null\newpage

\restoregeometry              %% restore the layout
\flipmargins
\pagestyle{mystyle_no_header}
\pagenumbering{arabic}

\tableofcontents
% \lstlistoflistings

\clearpage
\pagestyle{mystyle}

% ===========================================================================================
% ===========================================================================================

\section{Introduction}

\TODO{Introduction}

\clearpage

\section{Program Verification with Stainless}
\label{verif}

\TODO{Describe Stainless/Inox pipeline}

\clearpage
\section{Symbolic Partial Evaluation of PureScala Programs}
\label{symbolic}

\subsection{Motivation}
\label{symbolic-motivation}

\TODO{Rewrite}

Consider the following program, which inserts a known list of key-value pairs in a map that is kept abstract:

\begin{ShortCode}{PureScala}
def foldLeft[A, B](list: List[A], z: B)(f: (B, A) => B): B = list match {
  case Nil() => z
  case Cons(x, xs) => foldLeft(xs, f(z, x))(f)
}

def insert[A, B](kvs: List[(A, B)], map: Map[A, B]) = {
  foldLeft(kvs, map) {
    case (acc, (k, v)) => acc.updated(k, v)
  }
}

def test(map: Map[String, Int]): Boolean = {
  val xs = List("a" -> 1, "b" -> 2, "c" -> 3, "d" -> 4)
  val res = insert(xs, map)
  res("b") == 2
}.holds
\end{ShortCode}

For the sake of simplicity, let us assume that Stainless is unable to automatically prove the verification condition corresponding to \stt{test}'s postcondition (we will look at an actual test case in \RefSec{symcases}).\\

So, how would one go about to help Stainless prove this program correct? We could for example break up the problem, by adding appropriate postconditions to both \stt{foldLeft} and \stt{insert}, and provide the necessary lemmas, assertions, or annotations in order to get these to verify.\\

While this is a reasonable way of going at the problem, we feel that for this specific program, there is another way of tackling the problem. Indeed, while the \stt{map} variable is kept abstract, the list of values \stt{xs} we want to insert is not, and it should thus be possible to simplify the initial program by unfolding some definitions, and simplifying the resulting expressions, yielding a much simpler verification condition.\\

If we manually unfold \stt{insert} once, then unfold \stt{foldLeft} "as much as possible" in the program above, we end up with the following definition for the \stt{test} function, which is both much smaller and simpler than the original definition. We could then expect Stainless to have an easier time proving this theorem.

\begin{ShortCode}{PureScala}
def test(map: Map[String, Int]): Boolean = {
  val res = map.updated("a", 1).updated("b", 2).updated("c", 3).updated("d", 4)
  res("b") == 2
}.holds
\end{ShortCode}

We believe that it is unreasonable to expect users to manually perform such a transformation, especially with large programs. In the next section, we propose a fully automatic solution to this problem.

\subsection{Symbolic Evaluation and Partial Evaluation}

\cite{partialsym} \TODO{Rewrite}

The process of executing a program in the presence of abstract inputs is known as \textit{partial evaluation}.

The idea is to partially evaluate a program with symbolic inputs values while also maintaining a \textit{path condition}: a quantifier-free formula in conjunctive normal form which encodes the knowledge we have gathered so far about the symbolic values we are dealing with, as well as the bindings in scope. When encountering a boolean expression, the evaluator can then make use of the path condition to determine the value of that expression.

When encountering a conditional expression $E = \stt{if ($c$) $t$ else $e$}$, under the current path condition, the result of which we will denote by $c'$. If $c'$ is a boolean literal, we then evaluate the appropriate branch, and continue from here. Otherwise, we check whether the  formula $p \implies c'$ is valid. If we are able to show that it is indeed valid, we recurse into the "then" branch of the conditional expression under new path condition $p \wedge c'$. Otherwise, we instead check whether the formula $p \implies \neg\,c'$ is valid, in which case we recurse into its "else" branch under the path condition $p \wedge \neg\,c'$. At last, if we are unable to show that either formula is valid, we evaluate both branches under their respective path conditions, and we denote the results respectively by $t'$ and $e'$. Finally, we return \stt{if ($c'$) $t'$ else $e'$}. \\

\RefCode{lst:PC} shows a simple program annotated with the current path condition at various points of execution. When evaluating such a program symbolically, the path condition enables the evaluator to pick the "else" branch of the "if-then-else" expression, because, under the path condition at step 2, the condition \stt{x > 0} evaluates to \stt{false}.

\begin{Code}{PureScala}{lst:PC}{Example program annotated with path condition}
// Expression before evaluation:
{
  // 1. PC = true
  assume(x <= 0)
  // 2. PC = x <= 0
  if (x > 0) {
    // 3. PC = x <= 0 && x > 0
    x
  } else {
    // 4. PC = x <= 0 && !(x > 0)
    -x
  }
}

// Resulting expression after evaluation:
{
  assume(x <= 0)
  bar(-x)
}
\end{Code}

\subsubsection{Example}

Here is how the program we introduced in \RefSec{symbolic-motivation} is expressed in Inox's input language, formatted in PureScala syntax:

\begin{ShortCode}{PureScala}
def foldLeft[A](list: List[A], z: B, f: (B, A) => B): B =
  if (list.isInstanceOf[Nil[A]]) {
    z
  } else {
    val x  = list.asInstanceOf[Cons[A]].head
    val xs = list.asInstanceOf[Cons[A]].tail
    foldLeft(xs, f(z, x), f)
  }
}

def insert[A, B](values: List[(A, B)], map: Map[A, B]) = {
  foldLeft(xs, map, (acc, kv) => acc.updated(kv._1, kv._2))
}

def test(map: Map[String, Int]): Boolean = {
  val xs = List("a" -> 1, "b" -> 2, "c" -> 3, "d" -> 4)
  val res = insert(xs, map)
  res("b") == 2
}.holds
\end{ShortCode}

Let's only focus on the first two lines of the \stt{test} function, and go through the steps followed by the evaluator when ran on it. 

\begin{ShortCode}{PureScala}
val xs = List("a" -> 1, "b" -> 2, "c" -> 3, "d" -> 4)
val res = insert(xs, map)
\end{ShortCode}

\begin{enumerate}

\item We start by substituting the first binding into the subsequent statement:

\begin{ShortCode}{PureScala}
val res = insert(
  Cons("a" -> 1, Cons("b" -> 2, Cons("c" -> 3, Cons("d" -> 4, Nil()),
  map
)
\end{ShortCode}

\item Because \stt{insert} is non-recursive function, we can unfold it straight away:

\begin{ShortCode}{PureScala}
val res = foldLeft(
  Cons("a" -> 1, Cons("b" -> 2, Cons("c" -> 3, Cons("d" -> 4, Nil()),
  map,
  (acc, kv) => acc.updated(kv._1, kv._2)
)
\end{ShortCode}

\item \stt{foldLeft} is a recursive function, and some care is thus needed in order to not end up unfolding it indefinitely.\\

The idea here is that a recursive function must contain a \textit{guarded} recursive call to be terminating, as it would otherwise call itself recursively indefinitely and thus not terminate (we discuss termination in more detail in \RefSec{termination}). We can thus look at the function's body, and see whether it contains a conditional expression whose condition can be reduced to a boolean literal under the current path condition. If that is not the case, we cannot safely unfold the function and we stop here. Otherwise, we can replace the conditional expression by the appropriate branch, and evaluate the resulting expression under the new path condition induced by the condition. As long as the function is terminating, this process will terminate as we are either going to end up with a branch that does not contain a recursive call, or we will not be able to evaluate the condition to a boolean value and will thus not proceed further.\\

In the case of \stt{foldLeft}, there is indeed such a conditional expression, and under the current path condition, we are able to evaluate \stt{list.isInstanceOf[Nil]} to \stt{false} given that the path condition contains \stt{list = Cons("a" -> 1, ...)}. We can thus unfold it, replace the "if-then-else" expression by its "else" branch, and continue:

\begin{ShortCode}{PureScala}
val res = {
  val x  = Cons("a" -> 1, Cons("b" -> 2, ...)).asInstanceOf[Cons[A]].head
  val xs = Cons("a" -> 1, Cons("b" -> 2, ...)).asInstanceOf[Cons[A]].tail
  foldLeft(xs, ((acc, kv) => ...)(map, x), (acc, kv) => ...)
}
\end{ShortCode}

\item Here we can evaluate the bound value of \stt{x} (note: we evaluate both bindings in one go here for brevity):

\begin{ShortCode}{PureScala}
val res = {
  val x  = "a" -> 1
  val xs = Cons("b" -> 2, ...)
  foldLeft(xs, ((acc, kv) => ...)(map, x), (acc, kv) => ...)
}
\end{ShortCode}

\item We now inline both bindings (again, in one go for the sake of brevity):

\begin{ShortCode}{PureScala}
val res = {
  foldLeft(
    Cons("b" -> 2, ...),
    ((acc, kv) => ...)(map, "a" -> 1),
    (acc, kv) => ...
  )
}
\end{ShortCode}

\item We can then evaluate the arguments supplied to \stt{foldLeft}, giving us:

\begin{ShortCode}{PureScala}
val res = {
  foldLeft(
    Cons("b" -> 2, ...),
    map.updated("a", 1),
    (acc, kv) => ...
  )
}
\end{ShortCode}

\item As we have encountered another call to a recursive function, we repeat steps 3 to 6 three times, at which point we are left with:

\begin{ShortCode}{PureScala}
val res = {
  foldLeft(
    Nil(),
    map.updated("a", 1).updated("b", 2).updated("c", 3).updated("d", 4),
    (acc, kv) => ...
  )
}
\end{ShortCode}

\item This time, in step 3, the condition evaluates to \stt{true}, and we thus pick the "then" branch which leaves us with the following expression:

\begin{ShortCode}{PureScala}
val res = map.updated("a", 1).updated("b", 2).updated("c", 3).updated("d", 4)
\end{ShortCode}

\item This expression cannot be reduced further, as \stt{map} is abstract and \stt{updated} is a special language construct which can only be evaluated when applied to a concrete, finite map. We thus stop here.

\end{enumerate}

This whole process leaves us with the very same definition we would have obtained by equational reasoning, which is admittedly much simpler, and easier to reason about for Inox.

\begin{ShortCode}{PureScala}
def test(map: Map[String, Int]): Boolean = {
  val res = map.updated("a", 1).updated("b", 2).updated("c", 3).updated("d", 4)
  res("b") == 2
}.holds
\end{ShortCode}

\subsection{Semantics}

We subsequently denote the path condition by $\Delta$, a formula $e$ that is satisfiable under $\Delta$ by $e \in \Delta$. and a variable $v$ that is bound to an expression $e$ under $\Delta$ by $v \mapsto_\Delta e$. We will not delve into the details of how to decide whether a given condition is satisfiable under some path condition, but a reasonable although much too simplistic approximation would be to maintain a set of expressions and simply testing for membership. The actual implementation found in Inox (which predates our work) is much more complex and powerful implementation of this very idea. Moreover, we denote the fact that an expression $e$ evaluates to an expression $e'$ under a path condition $\Delta$ by $\lb{e}{\Delta} \longrightarrow e'$. Given $c, v$ two expressions, and \stt{x} a variable, we note $\Delta \cup c$ the addition of $c$ as a conjunct to the path condition $\Delta$, and $\Delta \uplus x \mapsto v$ the addition of the binding \stt{val x = $v$}. At last, the fact that an expression $e$ can be simplified to a boolean value under a path condition $\Delta$ is captured by $\stt{e} \Downarrow \Delta$. \RefFig{fig:symbolicsem} shows the operation semantics followed by our implementation, expressed in those terms.

\TODO{Describe pattern matches, assume, and invoke}

\begin{figure}[htb]
\begin{framed}

\begin{equation}
\dfrac{
  v \mapsto_\Delta e
}{
  \lb{v}{\Delta} \longrightarrow e
}
\end{equation}
 
\begin{equation}
\dfrac{
  e \in \Delta
}{
  \lb{e}{\Delta} \longrightarrow \stt{true}
}
\end{equation}

\begin{equation}
\dfrac{
  \neg\, e \in \Delta
}{
  \lb{e}{\Delta} \longrightarrow \stt{false}
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{e}{\Delta} \longrightarrow e'
}{
  \lb{\lambda x_1, \ldots, x_n.\, e}{\Delta} \longrightarrow \lambda x_1, \ldots, x_n.\, e'
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{\neg\,l \stt{ || } r}{\Delta} \longrightarrow e'
}{
  \lb{\stt{$l$ ==> $r$}}{\Delta} \longrightarrow e'
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{e_1}{\Delta} \longrightarrow \stt{false}
}{
  \lb{\stt{$e_1$ \&\&\,\ldots\,\&\& $e_n$}}{\Delta} \longrightarrow \stt{false}
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{e_1}{\Delta} \longrightarrow e_1' \qquad
  \lb{\stt{$e_2$ \&\&\,\ldots\,\&\& $e_n$}}{\Delta} \longrightarrow e'
}{
  \lb{\stt{$e_1$ \&\&\,\ldots\,\&\& $e_n$}}{\Delta} \longrightarrow \stt{$e_1'$ \&\& } e' 
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{e_1}{\Delta} \longrightarrow \stt{true}
}{
  \lb{\stt{$e_1$ ||\,\ldots\,|| $e_n$}}{\Delta} \longrightarrow \stt{true}
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{e_1}{\Delta} \longrightarrow e_1' \qquad
  \lb{\stt{$e_2$ ||,\ldots\,|| $e_n$}}{\Delta} \longrightarrow e'
}{
  \lb{\stt{$e_1$ ||,\ldots\,|| $e_n$}}{\Delta} \longrightarrow \stt{$e_1'$ || } e'
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{c}{\Delta} \longrightarrow \stt{true}
}{
  \lb{\stt{if ($c$) $t$ else $e$}}{\Delta} \longrightarrow \lb{t}{\Delta \cup c}
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{c}{\Delta} \longrightarrow \stt{false}
}{
  \lb{\stt{if ($c$) $t$ else $e$}}{\Delta} \longrightarrow \lb{e}{\Delta \cup \neg \,c}
}
\end{equation}

%\begin{equation}
%\dfrac{
%  \lb{c}{\Delta} \longrightarrow c' \qquad
%  \lb{t}{\Delta \cup c'} \longrightarrow t' \qquad
%  \lb{e}{\Delta \cup \neg c'} \longrightarrow e' \qquad
%  t' = e'
%}{
%  \lb{\stt{if ($c$) $t$ else $e$}}{\Delta} \longrightarrow t'
%}
%\end{equation}

\begin{equation}
\dfrac{
  \lb{c}{\Delta} \longrightarrow c' \qquad
  \lb{t}{\Delta \cup c'} \longrightarrow t' \qquad
  \lb{e}{\Delta \cup \neg\, c'} \longrightarrow e' \qquad
%  t' \not= e'
}{
  \lb{\stt{if ($c$) $t$ else $e$}}{\Delta} \longrightarrow \stt{if ($c'$) $t'$ else $e'$}
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{p}{\Delta} \longrightarrow \stt{true} \qquad
  \lb{e}{\Delta} \longrightarrow e'
}{
  \lb{\stt{assume($p$); $e$}}{\Delta} \longrightarrow e'
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{p}{\Delta} \longrightarrow \stt{false} \qquad
  \lb{e}{\Delta} \longrightarrow e'
}{
  \lb{\stt{assume($p$); $e$}}{\Delta} \longrightarrow \stt{assume(false); $e'$}
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{p}{\Delta} \longrightarrow p' \qquad
  \lb{e}{\Delta \cup p'} \longrightarrow e'
}{
  \lb{\stt{assume($p$); $e$}}{\Delta} \longrightarrow
  \stt{assume($p'$); $e'$}
}
\end{equation}

\end{framed}
\vspace{-10pt}
\caption{Operational semantics of the symbolic partial evaluator \label{fig:symbolicsem}}
\end{figure}

\begin{figure}[htb]\ContinuedFloat
\centering
%\begin{adjustwidth}{-1mm}{-1cm}
\begin{framed}


\begin{equation}
\dfrac{
  \stt{T$_2$:\,ADTType} \qquad
  \neg \stt{isSort(T$_2$)}
}{
  \lb{\stt{C(T$_1$, $a_1, \ldots, a_n$).isInstanceOf[T$_2$]}}{\Delta}
  \longrightarrow \stt{T$_1$.id == T$_2$.id}
}
\end{equation}

\begin{equation}
\dfrac{
  \stt{T:\,ADTType} \qquad
  \stt{isSort(T)}
}{
  \lb{\stt{$e$.isInstanceOf[T]}}{\Delta} \longrightarrow \stt{true}
}
\end{equation}

\begin{equation}
\dfrac{
  \stt{T:\,ADTType} \qquad
  \lb{e}{\Delta} \longrightarrow e' \qquad
  \stt{isInstanceOf(e', T, $\Delta$) == Some($b$)}
}{
  \lb{\stt{$e$.isInstanceOf[T]}}{\Delta} \longrightarrow b
}
\end{equation}

\begin{equation}
\dfrac{
  \stt{T:\,ADTType} \qquad
  \lb{e}{\Delta} \longrightarrow e' \qquad
  \stt{isInstanceOf($e'$, T, $\Delta$) == None}
}{
  \lb{\stt{$e$.isInstanceOf[T]}}{\Delta} \longrightarrow \stt{$e'$.isInstanceOf[T]}
}
\end{equation}

\begin{equation}
\dfrac{
  \stt{T:\,ADTType}
}{
  \lb{\stt{$e$.asInstanceOf[T]}}{\Delta} \longrightarrow \stt{$\lb{e}{\Delta}$.asInstanceOf[T]}
}
\end{equation}

\begin{equation}
\dfrac{
  \stt{$e$.getType} = \stt{MatchExpr} \quad
  \lb{\stt{matchToIfThenElse($e$)}}{\Delta} \longrightarrow e'
}{
  \lb{e}{\Delta} \longrightarrow e'
}
\end{equation}

\end{framed}
\vspace{-10pt}
\caption{Operational semantics of the symbolic partial evaluator \label{fig:symbolicsem}}
\end{figure}

%------------------------------------------------------------------------

\begin{landscape}
\begin{figure}[htb]\ContinuedFloat
\centering
%\begin{adjustwidth}{-1mm}{-1cm}
\begin{framed}

\begin{equation}
\dfrac{
%  \text{\TODO{This is overly simplistic}}
}{
  \lb{\stt{let x:\,T = $v$ in $e$}}{\Delta} \longrightarrow
  \lb{e[\stt{x}/\stt{$v$}]}{\Delta}
}
\end{equation}

%\begin{equation}
%\dfrac{
%  e = \stt{let x:\,T = if ($c_1$) $t_1$ else $e_1$ in if ($c_2$) $t_2$ else $e_2$}
%  \qquad c_ 1 = c_2
%}{
%  \lb{e}{\Delta} \longrightarrow
%  \lb{\stt{if ($c_1$) let x:\,T = $t_1$ in $t_2$ else let x:\,T = $e_1$ in $e_2$}}{\Delta}
%}
%\end{equation}

\begin{equation}
\dfrac{
  \lb{f}{\Delta} \longrightarrow \lambda \stt{x$_1$:\,T$_1$,\ldots,x$_n$:\,T$_n$.\,$b$}
  \qquad
  \lb{e_i}{\Delta} \longrightarrow e_i',\, i \in \{1 \ldots n\}
}{
  \lb{f(e_1,\ldots,e_n)}{\Delta} \longrightarrow
  \lb{b[\stt{x}_1/e_1',\ldots,\stt{x}_n/e_n']}{\Delta}
}
\end{equation}

\begin{equation}
\dfrac{
  \lb{f}{\Delta} \longrightarrow f' \qquad
  \lb{e_i}{\Delta} \longrightarrow e_i',\, i \in \{1 \ldots n\}
}{
  \lb{f(e_1,\ldots,e_n)}{\Delta} \longrightarrow
  f'(e_1', \ldots, e_n')
}
\end{equation}

% TODO: Application(Assume)?

\begin{equation}
\dfrac{
 \neg\,\stt{f.isRecursive} \quad
 \stt{f.params} = \langle \stt{x}_1, \ldots, \stt{x}_n \rangle \quad
 \lb{e_i}{\Delta} \longrightarrow e_i',\, i \in \{1 \ldots n\} \quad
 \lb{\stt{f.pre($e_1',\ldots,e_n'$)}}{\Delta} \longrightarrow \stt{true}
}{
  \lb{\stt{f}(e_1,\ldots,e_n)}{\Delta} \longrightarrow
  \lb{\stt{f.body}[\stt{x}_1/e_1',\ldots,\stt{x}_n/e_n']}{\Delta}
}
\label{fig:symbolicsem:fi1}
\end{equation}

\begin{equation}
\dfrac{
 \stt{id.body} \Downarrow \Delta \uplus \{\,\stt{x}_i \mapsto e_i'\,|\, 1 \leq i \leq n\,\}
 \quad
 \stt{id.params} = \langle \stt{x}_1, \ldots, \stt{x}_n \rangle
 \quad
 \lb{e_i}{\Delta} \longrightarrow e_i',\  i \in \{1 \ldots n\}
 \quad
 \lb{\stt{f.pre($e_1',\ldots,e_n'$)}}{\Delta} \longrightarrow \stt{true}
}{
  \lb{\stt{id}(e_1,\ldots,e_n)}{\Delta} \longrightarrow
  \lb{\stt{id.body}[\stt{x}_1/e_1',\ldots,\stt{x}_n/e_n']}{\Delta}
}
\label{fig:symbolicsem:fi2}
\end{equation}

\begin{equation}
\dfrac{
 \lb{e_i}{\Delta} \longrightarrow e_i',\, i \in \{1 \ldots n\}
}{
  \lb{\stt{id}(e_1,\ldots,e_n)}{\Delta} \longrightarrow
  \stt{id}(e_1',\ldots,e_n')
}
\label{fig:symbolicsem:fi3}
\end{equation}

\begin{equation}
\dfrac{
  (\stt{cons}, (e_1, \ldots, e_n)) = \stt{deconstruct(e)} \quad
  \lb{e_i}{\Delta} \longrightarrow e_i',\, i \in \{1 \ldots n\}
}{
  \lb{e}{\Delta} \longrightarrow \stt{cons}(e_1', \ldots, e_n')
}
\end{equation}

\begin{equation}
\dfrac{
 e = \stt{if ($c$) $t_1$ else $t_2$} \quad
 \lb{c}{\Delta} \longrightarrow r \quad
 r \in \{\stt{true}, \stt{false}\}
}{
  \stt{e} \Downarrow \Delta
}
\end{equation}

\end{framed}
\vspace{-10pt}
\caption{Operational semantics of the symbolic partial evaluator \label{fig:symbolicsem}}
\end{figure}
\end{landscape}

\subsection{Implementation}

We have implemented the symbolic partial evaluator described above within Stainless\footnote{\url{https://github.com/romac/stainless/tree/stainless-sym}}.
In order to invoke the partial evaluator on a function definition, a user must supply the new \stt{--partial-eval} flag and annotate the function with the \stt{@partialEval} annotation. Any such function will then be partially evaluated,  and its body will be substituted by resulting expression. Enabling the \stt{partial-eval} debug section instructs Stainless to print the result of the evaluation. This effectively enable users to use Stainless as a symbolic partial evaluator for PureScala program.

\subsubsection{Path Condition}

Our initial implementation 

\subsection{Case Study: Key-value Store Algebra}
\label{symcases}

In \RefCode{lst:symkvstore}, we define a monadic domain-specific language to manipulate a key-value store, along with a tracing interpreter which maps the operations over a PureScala \stt{Map}. A simple program which makes use of this DSL to insert a list of concrete values into the store is shown in \RefCode{lst:symkvstoreinv}. Without additional lemmas, Stainless is unfortunately unable to verify the postcondition of the \stt{result} function. On the other hand, turning on the partial evaluator turns the associated verification condition into a much more concrete form, which in turns allow the verification to promptly go through. We will note that, although the exact amount of \textit{fuel} we give to the interpreter is unknown, the precondition of the \stt{result} function constrains it to be greater than 10. Because the program expressed in that DSL requires less than 10 steps to be fully interpreted, the evaluator is able to reduce it to normal form, something which would not be possible with a non-symbolic partial evaluator.

\begin{Code}{PureScala}{lst:kvvc}{Partially evaluated verification condition}
val (res, trace) = (
  map.updated("foo", "bar").updated("toto", "tata")("foo"),
  Get("foo") :: Put("toto", "tata") :: Put("foo", "bar") :: init
)

res == Some("bar") &&
trace.take(3) == Get("foo") :: Put("toto", "tata") :: Put("foo", "bar") :: Nil()
\end{Code}

\begin{Code}{PureScala}{lst:symkvstoreinv}{Example program}
def insert(kvs: List[(String, String)])(after: Op): Op = kvs match {
  case Nil() => after
  case Cons((k, v), rest) => put(k, v) { () => insert(rest)(after) }
}

val xs = List("foo" -> "bar", "toto" -> "tata")
val program = insert(xs) {
  get("foo") { foo =>
    pure(foo)
  }
}

@symeval
def result(map: Map[String, String], init: List[Label], fuel: BigInt) = {
  require(fuel > 10)
  interpret(program)(map, init, fuel)
} ensuring { case (res, trace) => prop(res, trace) }

@inline
def prop(res: Option[String], trace: List[Label]) = {
  res == Some("bar") &&
  trace.take(3) == List(
    Label.Get("foo"),
    Label.Put("toto", "tata"),
    Label.Put("foo", "bar")
  )
}
\end{Code}

\begin{landscape}
\begin{Code}{PureScala}{lst:symkvstore}{Key-value store implementation}
sealed abstract class Label
object Label {
  case class Get(key: String)                extends Label
  case class Put(key: String, value: String) extends Label
}

sealed abstract class Op
case class Pure(value: Option[String])                     extends Op
case class Get(key: String, next: Option[String] => Op)    extends Op
case class Put(key: String, value: String, next: () => Op) extends Op

def get(key: String)(next: Option[String] => Op): Op    = Get(key, next)
def put(key: String, value: String)(next: () => Op): Op = Put(key, value, next)
def pure(value: Option[String]): Op                     = Pure(value)

def interpret(op: Op)(kv: Map[String, String], trace: List[Label], fuel: BigInt): (Option[String], List[Label]) = {
  require(fuel >= 0)
  decreases(fuel)

  op match {
    case Pure(value) =>
      (value, trace)

    case Get(key, next) if fuel > 0 =>
      interpret(next(kv.get(key)))(kv, Label.Get(key) :: trace, fuel - 1)

    case Put(key, value, next) if fuel > 0 =>
      interpret(next())(kv.updated(key, value), Label.Put(key, value) :: trace, fuel - 1)

    case _ =>
      (None(), trace)
  }
}
\end{Code}
\end{landscape}

\subsection{1st Futamura Projection}

Let us consider the case where one were to define a language, implement an interpreter for it in PureScala, and then write a program in this language. One could then partially evaluate the interpreter applied to the program, while keeping the inputs and I/O operations abstract. The resulting expression could then be seen as a "compiled" version of the original program, represented as a PureScala program, which can be linked to a small runtime and compiled to a lower-level language using the infrastructure provided by the Scala language itself, PureScala being a strict subset of Scala.\\

The technique of partially evaluating an interpreter over a known program is known as the \textit{1st Futamura projection} \cite{futamura}, and can theoretically be applied to the partial evaluator itself, yielding a compiler (the 2nd projection) or even a converter from any interpreter to a compiler (3rd projection).\RefCode{lst:symevalex} features an example involving an interpreter for a simple language with variables, arithmetic expressions and an I/O operation.

\begin{Code}{PureScala}{lst:symevalex}{Implementation an interpreter for a simple language}
sealed trait Expr
case class Var(name: String)     extends Expr
case class Num(value: Int)       extends Expr
case class Add(l: Expr, r: Expr) extends Expr
case class Mul(l: Expr, r: Expr) extends Expr
case class Rand(max: Expr)       extends Expr

case class Context(bindings: List[(String, Expr)]) {
  def contains(name: String): Boolean =
  	apply(name).isDefined

  def apply(name: String): Option[Expr] =
    bindings.find(_._1 == name).map(_._2)
}

implicit val state = Random.newState

@extern
def random(max: Int): Int = {
  Random.nextInt(max)
}

case class Error(msg: String)
def interpret(expr: Expr, ctx: Context): Either[Error, Int] = {
  expr match {
    case Num(value) => Right(value)

    case Var(name)  => ctx(name) match { 
      case None()      => Left(Error("Unbound variable: " + name))
      case Some(value) => interpret(value, ctx)
    }

    case Add(l, r)  => for {
      le <- interpret(l, ctx)
      re <- interpret(r, ctx)
    } yield le + re

    case Mul(l, r)  => for {
      le <- interpret(l, ctx)
      re <- interpret(r, ctx)
    } yield le * re

    case Rand(max) =>
      interpret(max, ctx).map(random(_))
  }
}
\end{Code}

\begin{Code}{PureScala}{lst:symevalex}{"Compilation" of a simple program}
val program: Expr = Mul(Num(10), Add(Var("x"), Rand(Num(42))))

@symeval
def compiled(ctx: Context): Int = {
  require(ctx contains "x")
  interpret(program, ctx).get.            // 10 * (ctx("x") + random(42))
}

@symeval
def test(y: Int) = {
  val ctx = Context(Map("y" -> Num(y)))
  interpret(program, ctx)                 // Left(Error("Unbound variable: x"))
} ensuring { _.isLeft }
\end{Code}

\subsection{Termination}

As Stainless comes with a powerful termination checker, we suggest to only enable the partial evaluator on functions which have been proved terminating by Stainless. As an additional measure, we have bounded the maximum number of evaluation steps that can be performed. This ensure that, should one still run the evaluator on a non-termination function, Stainless will not hang or crash.\\

\begin{Code}{PureScala}{lst:nontermloop}{Example of non-terminating program}
def bar(xs: List[BigInt]): List[BigInt] = {
  if (xs.isEmpty) Nil() else bar(Cons(xs.head, xs))
}

@symeval
def test = {
  bar(List(1)) == Nil()
} holds
\end{Code}

Moreover, we argue that, when ran over a program that Stainless deems terminating, the  evaluator terminates as well. In the PureScala subset that we are working with at this point in the pipeline, the only source of non-termination are calls to recursive functions.

Because the evaluator will only unfold function invocations which satisfy the function's precondition, \\

\begin{Code}{PureScala}{lst:infloop}{Provably terminating program}
def sum(list: List[Int]): Int = list match {
  case Nil() => 0
  case Cons(x, xs) => x + sum(xs)
}

def bar(a: Boolean, n: BigInt): Boolean = {
  require(n > 0)

  if (n == 0)
    foo(a, -10)
  else
    a
}
\end{Code}

Regarding termination checking itself, we have ensured that the partial evaluator cannot be enabled when checking termination in Stainless, as doing so could prevent the termination checker to itself terminate, or even yield incorrect results.

\subsection{Conclusion}

\TODO{Conclusion}

\subsection{Further Work}
\label{sym-further}

\subsubsection*{Nondeterministic Evaluator}

The evaluator described in this chapter is \textit{deterministic}, in the sense that its evaluation function maps one expression to exactly one expression in a deterministic way. We believe that it could be worthwhile to investigate the potential use cases of a so-called \textit{non-deterministic} evaluator. That is to say, an evaluator which, when given a single expression, would return potentially multiple results. For example, when the evaluator would be applied to an expression \stt{$s$ = if ($c$) $t$ else $e$} whose condition $c$ it is not able to evaluate to a boolean literal, it would return all the possible expressions resulting from first evaluating the condition and both branches nondeterministically. We show some pseudo-code in \RefCode{lst:nondet}.\\

One potential use case of such an evaluator that we see, when combined with a way to trigger its application in user-land code, is for implementing a symbolic \textit{partial order reduction} algorithm. In a bit more detail, the evaluator could be used to compute the set of (potentially symbolic) transitions that results from taking a step at a given (potentially symbolic) state.

\begin{Code}{PureScala}{lst:nondet}{Pseudo-code of a non-deterministc evaluator}
def ndEval(expr: Expr, pc: PC): Stream[Expr] = {
 case IfExpr(c, t, e) =>

ndEval(e, pc) == for {
  cs <- eval(c, pc)
  ts = eval(t, pc withCond c)
  es = eval(e, pc withCond not(c))
} yield ts ++ es
\end{Code}

%------------------------------------------------------------------------

\clearpage
\section{Verifiying Actor Systems}
\label{actors}

\subsection{Motivation}

Over the last few decades, many different models of concurrent computation have been discovered, such as \textit{Petri Nets}, \textit{Communicating Sequential Processes} and the \textit{$\pi$-calculus} \cite{algebraicactors}. 

Moreover, because actors do not share memory and rely on asynchronous message passing, the Actor Model is well suited to model distributed systems as well.

\subsection{A Simple Actor Model for Verification}

\subsubsection{Introduction}

\subsubsection{Implementation}
\label{actor-impl}

We now below the PureScala implementation of the model 

\subsubsection*{Message}

In our framework, messages are modelled as constructors of the \InlineS{Msg} abstract class.

\begin{ShortCode}{PureScala}
abstract class Msg
case class Hello(name: String) extends Msg
\end{ShortCode}

\vspace{-15pt}
\subsubsection*{Actor Reference}

Each actor is associated with a unique and persistent reference, modelled as an instance of the \ActorRef abstract class.

\begin{ShortCode}{PureScala}
abstract class ActorRef
case class Primary() extends ActorRef
\end{ShortCode}

\vspace{-15pt}
\subsubsection*{In-flight Messages}

In-flight messages are represented as a product of the \ActorRef of the destination actor, and the message itself.

\begin{ShortCode}{PureScala}
case class Packet(dest: ActorRef, payload: Msg)
\end{ShortCode}

\vspace{-15pt}
\subsubsection*{Actor Context}

When a message is delivered to an actor, the latter is provided with a context,
which holds a reference to itself, and a mutable list of \InlineS{Packet}s to send.

\begin{ShortCode}{PureScala}
case class ActorContext(
  self: ActorRef,
  var toSend: List[Packet]
)
\end{ShortCode}

\vspace{-15pt}
\subsubsection*{Behavior}

A behavior specifies both the current state of an actor, and how this one should 
process the next incoming message. In our framework, these are modelled as a subclass 
of the abstract class \InlineS{Behavior}, which defines a single abstract method 
\InlineS{processMsg}, to be overriden for each defined behavior.

Using the provided \InlineS{ActorContext}, the implementation of the \InlineS{processMsg}
method can both access its own reference, and register messages to be sent after the
execution of the method is complete. It is also required to return a new \InlineS{Behavior}

\begin{ShortCode}{PureScala}
abstract class Behavior {
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior
}
\end{ShortCode}

\vspace{-15pt}
\subsubsection*{Actor System}

The state of the Actor system at a given point in time is modelled as a case class, 
holding the behavior associated with each actor reference, and the list of in-flight messages between any two actors.

\begin{ShortCode}{PureScala}
case class ActorSystem(
  behaviors: CMap[ActorRef, Behavior],
  inboxes: CMap[(ActorRef, ActorRef), List[Msg]]
)
\end{ShortCode}
% trace: List[Transition]

The \InlineS{ActorSystem} class is equipped with a \InlineS{step} method, which takes 
a pair of \ActorRef as arguments, and is in charge of delivering the oldest message 
found in the corresponding inbox, and which returns the new state of the system after 
the aforementioned message has been processed.

\begin{ShortCode}{PureScala}
def step(from: ActorRef, to: ActorRef): ActorSystem
\end{ShortCode}

\subsubsection{Comparison with Akka and Akka Typed}

\subsubsection*{Akka}

Akka is a powerful Scala implementation of the Actor model, suitable for both concurrent and distributed systems. 

\subsubsection*{Akka Typed}

\subsubsection*{Notable Differences}

While we initially set to mimic the API offered by the Akka Typed library\footnote{\url{https://doc.akka.io/docs/akka/2.5.4/scala/typed.html}}, we quickly ran into some limitations of Stainless's type system. Namely, the lack of an encoding for both existential types, and various issues with the encoding of co-/contravariant class hierarchies. While some of those issues got fixed over the last few months, we have been unable to provide a typed API similar in spirit to Akka Typed. For lack of time, we have decided to go with the untyped API described in \RefSec{actor-impl}.\\

Another notable difference between our model and both the one implemented in Akka\footnote{\url{https://doc.akka.io/docs/akka/current/general/message-delivery-reliability.html}}, is that we rely on \textit{exactly-once} delivery of messages. We experimented with a weaker model that only relied on \textit{at-most-once} delivery but it quickly became clear that the amount of work needed to verify the very same systems we describe below would be too much in the context of this project.

% (archive: \url{http://archive.is/XU8if})}

\subsection{Operational Semantics}
\label{semantics}

We formulate the small-step operational semantics of our Actor model in 
\RefFig{fig:opsem}, where $s: \stt{ActorSystem}$ is an Actor system,
$m: \stt{Msg}$ is a message,
$n, n_{to}, n_{from}: \stt{ActorRef}$ are references,
$b, b': \stt{Behavior}$ are behaviors,
$ps: \stt{List[Packet]}$ a list of packets to send,
% $t: \stt{Transition}$ is a transition,
$c: \stt{ActorContext}$ is a context,
and $\emptyset_n: \stt{ActorContext}$ is the empty context for an actor whose
self-reference is $n$, defined as $\emptyset_n := \stt{ActorContext}(n, \stt{Nil})$.

\begin{figure}[!h]
\begin{framed}
 
\begin{equation}
\dfrac{
  \not\exists m \in \stt{$s$.inboxes}(n_{from}, n_{to})
}{
  \stt{$s$.step}(n_{from}, n_{to}) \leadsto \stt{s}
}
\tag{STEP-NOMSG}
\end{equation}

\vspace{10pt}
\begin{equation}
\dfrac{
  \exists m \in \stt{$s$.inboxes}(n_{from}, n_{to}) \qquad
  \stt{$s$.deliverMsg}(n_{to}, n_{from}, m) \leadsto (b, ps, t)
}{
  \stt{$s$.step}(n_{from}, n_{to}) \leadsto s \uplus (n_{to} \mapsto b, \ldots, t)
}
\tag{STEP}
\end{equation}

\vspace{10pt}
\begin{equation}
\dfrac{
  \stt{$s$.behaviors($n_{to}$).processMsg}(m, \emptyset_{n_{to}}) \leadsto (b, c) 
}{
  \stt{$s$.deliverMsg}(n_{to}, n_{from}, m) \leadsto (b, \stt{$c$.toSend}, t)
}
\tag{DELIVER-MSG}
\end{equation}

\vspace{10pt}
\begin{equation}
\dfrac{
  \stt{$b$.processMsg}(m, \emptyset_{n_{to}}) = i_1 ::\, \ldots ::\,i_n ::\, b' ::\,\stt{Nil} \qquad
  \langle i_1 ::\, \ldots ::\,i_n ::\,\stt{Nil}, \emptyset_{n_{to}} \rangle \longrightarrow c
}{
   \stt{$b$.processMsg}(m, \emptyset_{n_{to}}) \leadsto (b', c)
}
\tag{PROCESS-MSG}
\end{equation}

\vspace{10pt}
\begin{equation}
\dfrac{\empty}{
   \langle \stt{Nil}, c \rangle \longrightarrow c
}
\tag{I-NIL}
\end{equation}

\vspace{10pt}
\begin{equation}
\dfrac{
  \langle i, c \rangle \longrightarrow c'
}{
  \langle \stt{$i ::\,is$}, c \rangle \Rightarrow \langle is, c' \rangle
}
\tag{I-CONS}
\end{equation}

\vspace{10pt}
\begin{equation}
\dfrac{
  \empty
}{
  \langle n\ \stt{!}\ m, c \rangle \longrightarrow (b',\ \stt{$c$.copy(toSend $\mapsto$ ($n$, $m$) $::$ $c$.toSend)})
}
\tag{I-SEND}
\end{equation}

\end{framed}
\vspace{-10pt}
\caption{Operational semantics\label{fig:opsem}}
\end{figure}

\subsection{Proving Invariants}
\label{invariants}

After having defined an Actor system with our framework, one might want to verify that this system preserves some invariant between each step of its execution. That is to say, for an \InlineS{ActorSystem} $s$, any two \ActorRef $n, m$, and an invariant \InlineS{inv: ActorSystem $\ \to\ $ Boolean}, if $\texttt{inv}(s)$ holds, then $\texttt{inv}(s\texttt{.step}(n, m))$ should hold as well. We express this property more formally in \RefFig{fig:stepinvariant}. Because we are essentially doing a proof by induction over execution steps here, one needs also to ensure the invariant holds for some initial system. These two properties can be easily expressed in PureScala, as shown in \RefCode{lst:preserveInv}.

\begin{figure}[!h]
$$\forall s: \stt{ActorSystem},\, n: \stt{ActorRef},\, m: \stt{ActorRef}.\ \stt{inv($s$)} \implies \stt{inv($s$.step($n, m$))}$$
\vspace{-20pt}
\caption{Invariant preservation property\label{fig:stepinvariant}}
\end{figure}

\begin{Code}{PureScala}{lst:preserveInv}{Invariant preservation theorem in PureScala}
def inv(s: ActorSystem): Boolean = {
  /* ... */
}

def preserveInv(s: ActorSystem, n: ActorRef, m: ActorRef): Boolean = {
  require(inv(s))
  inv(s.step(n, m))
} holds

def initial: ActorSystem = /* ... */

def initialInv: Boolean = {
  invariant(initial)
} holds
\end{Code}

\subsection{Case studies}
\label{casestudies}

\subsubsection{Increment-based Replicated Counter}
\label{repcounterinc}

As a first and very simple case study, we will study an Actor system which models a replicated counter, which can only be incremented by one unit. This system is composed of two actors, a primary counter whose reference is \stt{Primary()},and a backup counter whose reference is \stt{Backup()}. Each of these reference is associated with a behavior: the primary counter reference with an instance of \stt{PrimaryB}, and the backup counter reference with an instance of \stt{BackupB}, both of which hold a positive integer, representing the value of the counter. Whenever the primary actor receives the message \stt{Inc()}, it forwards that message to the backup actor, and returns a new instance of \stt{PrimaryB} with the counter value incremented by one. When the backup actor receives the \stt{Inc()} message, it too returns a new instance of \stt{BackupB} with the counter value incremented by one. The corresponding PureScala implementation can be found in \RefCode{lst:ReplicatedCounterInc}.//

We now want to verify that the following properties stay valid between at execution step: the \stt{Backup()} actor does not send itself any messages, both actors have the proper corresponding behavior, the value of the primary counter is equal to the value of the backup counter added to the number of \stt{Inc()} messages that are yet to be delivered to the backup actor. \RefCode{lst:repcounterincinv} presents the corresponding invariant, while \RefCode{lst:repcounterincthm} shows the invariant preservation theorem that we want to prove.

\begin{Code}{PureScala}{lst:ReplicatedCounterInc}{Increment-based replicated counter implementation}
case class Primary() extends ActorRef
case class Backup()  extends ActorRef

case class Inc() extends Msg

case class PrimaryB(counter: BigInt) extends Behavior {
  require(counter >= 0)

  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case Inc() =>
      Backup() ! Inc()
      PrimaryB(counter + 1)
  }
}

case class BackupB(counter: BigInt) extends Behavior {
  require(counter >= 0)

  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case Inc() => BackupB(counter + 1)
  }
}
\end{Code}

\begin{Code}{PureScala}{lst:repcounterincinv}{Increment-based replicated counter invariant}
def invariant(s: ActorSystem): Boolean = {
  s.inboxes((Backup(), Backup())).isEmpty && {
    (s.behaviors(Primary()), s.behaviors(Backup())) match {
      case (PrimaryB(p), BackupB(b)) =>
        p.value == b.value + s.inboxes(Primary() -> Backup()).length
      case _ => false
    }	
  }
}
\end{Code}

\begin{Code}{PureScala}{lst:repcounterincthm}{Replicated counter theorem (increment)}
def preserveInv(s: ActorSystem, n: ActorRef, m: ActorRef): Boolean = {
  require(invariant(s))
  invariant(s.step(n, m))
} holds
\end{Code}

\subsubsection{Delivery-based Replicated Counter}

\RefCode{lst:ReplicatedCounterDel} shows a variant of the previous case study, where instead of having the primary actor forward the \stt{Inc()} message to the backup actor, the former instead sends the latter the new value.

\begin{Code}{PureScala}{lst:ReplicatedCounterDel}{Delivery-based Replicated counter implementation}
case object Primary extends ActorRef
case object Backup  extends ActorRef

case object Inc extends Msg
case class Deliver(c: BigInt) extends Msg

case class PrimaryB(counter: BigInt) extends Behavior {
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case Inc =>
      Backup ! Deliver(counter + 1)
      PrimaryB(counter + 1)

    case _ => Behavior.same
  }
}

case class BackupB(counter: BigInt) extends Behavior {
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case Deliver(c) => BackupB(c)
    case _          => Behavior.same
  }
}
\end{Code}

The invariant now reads slightly differently, as can be seen in \RefCode{lst:ReplicatedCounterDelInv}.

\begin{Code}{PureScala}{lst:ReplicatedCounterDelInv}{Delivery-based replicated counter invariant}
def validBehaviors(s: ActorSystem): Boolean = {
  (s.behaviors(Primary), s.behaviors(Backup) match {
    case (p: PrimaryB, b: BackupB) => true
    case _                         => false
  }
}

def invariant(s: ActorSystem): Boolean = {
  validBehaviors(s)                       &&
  s.inboxes(Primary -> Primary).isEmpty   &&
  s.inboxes(Backup -> Backup).isEmpty     &&
  noMsgsToSelf(Backup -> Primary).isEmpty &&
  {
    val PrimaryB(p) = s.behaviors(Primary)
    val BackupB(b)  = s.behaviors(Backup)
    val bInbox      = s.inboxes(Primary -> Backup)

    p.value >= b.value && isSorted(bInbox) && bInbox.forall {
      case Deliver(Counter(i)) => p.value >= i
      case _                   => true
    }
  }
}
\end{Code}

\subsubsection{Lock Service}

\RefCode{lst:LockService} shows the implementation of a lock service using our framework. In this case study, an actor acts as a server holding a lock on some resource, while a number of other actors (the "agents") act as clients of the lock service, each potentially trying to acquire the lock on the resource. To model a variable number of actors with the same implementation, we define their reference as a case class parametrized by a \TODO{unique} identifier.

An obvious property we might want to prove is that, at any time, at most one of those agents thinks that it holds the lock. Additionally, we'd like to ensure that such an agent is actually the same one that the server granted the lock too. We express this property in \RefCode{lst:LockServiceInv}.

\begin{Code}{PureScala}{lst:LockService}{Lock service implementation}
case class Server() extends ActorRef
object Server {
  case class Lock(agent: ActorRef) extends Msg
  case class Unlock(agent: ActorRef) extends Msg
}

case class Agent(id: Int) extends ActorRef
object Agent {
  case object Lock   extends Msg
  case object Unlock extends Msg
  case object Grant  extends Msg
}

// The head of `agents` holds the lock, the tail are waiting for the lock
case class ServerB(agents: List[ActorRef]) extends Behavior {
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case Server.Lock(agent) if agents.isEmpty =>
      agent ! Agent.Grant
      ServerB(List(agent))

    case Server.Lock(agent) =>
      ServerB(agents :+ agent)

    case Server.Unlock(agent) if agents.nonEmpty =>
      val newAgents = agents.tail
      if (newAgents.nonEmpty) newAgents.head ! Agent.Grant
      ServerB(newAgents)

    case _ =>
      Behavior.same
  }
}

case class AgentB(holdsLock: Boolean) extends Behavior {
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case Agent.Lock =>
      Server() ! Server.Lock(ctx.self)
      Behavior.same

    case Agent.Unlock if holdsLock =>
      Server() ! Server.Unlock(ctx.self)
      AgentB(false)

    case Agent.Grant =>
      AgentB(true)

    case _ =>
      Behavior.same
  }
}
\end{Code}

\begin{Code}{PureScala}{lst:LockServiceInv}{Lock service invariant}
def hasLock(s: ActorSystem, a: ActorRef): Boolean = {
  s.behaviors(a) match {
    case AgentB(hasLock) => hasLock
    case _ => false
  }
}

def mutex(s: ActorSystem): Boolean = forall { (a: ActorRef, b: ActorRef) =>
  (a != b) ==> !(hasLock(s, a) && hasLock(s, b))
}

def hasLockThenHead(s: ActorSystem): Boolean = forall { (ref: ActorRef) =>
  hasLock(s, ref) ==> {
    s.behaviors(Server()) match {
      case ServerB(Cons(head, _)) => head == ref
      case _ => false
    }
  }
}

def invariant(s: ActorSystem): Boolean = {
  mutex(s) && hasLockThenHead(s)
}
\end{Code}

\TODO{Lock service invariant proof}

%\subsubsection*{Leader Election}
%
%\TODO{Leader election}

%\subsubsection*{Key-value store}
%
%\TODO{KV store}

\subsection{Spawning Actors}
\label{spawn}

\subsubsection{Updating The Model}

Up until now, our framework has only been able to model Actor systems with a static topology, ie. systems where no new actors besides the ones that are statically defined can be spawned. Let's now attempt to enrich our model to account for dynamic topologies.

To this end, we modify the \ActorRef definition to include both a name and an optional field holding a reference to its parent \ActorRef if any. We also add a new constructor of the \ActorRef data type, which will be assigned to actors spawned from another actor.

\begin{ShortCode}{PureScala}
abstract class ActorRef(
  name: String,
  parent: Option[ActorRef] = None()
)

case class Child(name: String, getParent: ActorRef)
  extends ActorRef(name, Some(getParent))
\end{ShortCode}

In order for actors to spawn other actors, by specifying their name and associated 
initial behavior, we modify the \stt{ActorContext} class as follows:

\begin{ShortCode}{PureScala}
case class ActorContext(
  self: ActorRef,
  var toSend: List[Packet],
  var toSpawn: List[(ActorRef, Behavior)]
) {
  def spawn(behavior: Behavior, name: String): ActorRef = {
    val id: ActorRef = Child(name, self)
    toSpawn = toSpawn :+ (id, behavior)
    id
  }
  /* ... */
}
\end{ShortCode}

As can be seen in the listing above, the context now keeps track of the names and 
behaviors of the actors to be spawned, and provides a \stt{spawn} method which is in  charge of constructing the \ActorRef of the spawned actor, storing it along with the  behavior within the context, and returning the newly generated reference.

\subsubsection{Case Study}

\RefCode{lst:spawncode} defines a simple system with a dynamic topology, where one actor named \stt{Primary} waits for a \stt{Spawn} message to spawn a child actor, and change its behavior from \stt{BeforeB} to \stt{AfterB} in order to keep track of the reference to the child. The invariant we would to verify holds here, states that, if the \stt{Primary} actor has behavior \stt{BeforeB()}, then the behavior associated with the \ActorRef of its child actor must be \stt{Stopped}. On the other hand, if the \stt{Primary} actor has behavior \stt{AfterB(child)}, then the behavior associated with \stt{child} must be \stt{ChildB}. This test case verifies promptly, provided that the partial evaluator is enabled.

\begin{Code}{PureScala}{lst:spawncode}{}
case object Primary extends ActorRef("primary")
case object Spawn extends Msg

case class BeforeB() extends Behavior {
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case Spawn =>
      val child = ctx.spawn(ChildB(), "child")
      AfterB(child)
  }
}

case class AfterB(child: ActorRef) extends Behavior {
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case _ => Behavior.same
  }
}

case class ChildB() extends Behavior {
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case _ => Behavior.same
  }
}

def invariant(s: ActorSystem): Boolean = {
  s.behaviors(Primary) match {
    case BeforeB() =>
      s.isStopped(Child("child", Primary()))
    case AfterB(child) =>
      s.behaviors(child) == ChildB()

    case _ => false
  }
}

def theorem(s: ActorSystem, from: ActorRef, to: ActorRef): Boolean = {
  require(invariant(s))
  invariant(s.step(from, to))
} holds
\end{Code}

\subsection{Running an Actor System on Akka}
\label{akka}

While the verification of Actor systems is in itself an interesting endeavour, it is not of much use unless one is able to run these systems, potentially in a distributed environment. Thanks to the shim presented in \RefCode{lst:akkashim}, it is effectively possible run an Actor system developed with our framework on top of Akka, with only a few alterations to the original program. With this shim, the \ActorRef type is mapped to Akka's \ActorRef, while the \stt{ActorContext} now only contains the actor's self-reference, as well as the underlying Akka context. The shim also defines an actual Akka actor, parametrized by an underlying \stt{Behavior}, to which all messages of type \stt{Msg} will be delegated. The \stt{ActorSystem} class becomes abstract, and concrete subclasses need to provide it with an actual Akka system, as well as provide an implementation of its \stt{run} method. Within this method, one can spawn new top-level actors, get a reference to those, and send them messages. \RefCode{lst:akkashimex} shows such an implementation for the replicated counter described in \RefSec{repcounterinc}.

\begin{Code}{PureScala}{lst:akkashim}{Akka shim for our Actor framework}
import akka.actor

type ActorRef = actor.ActorRef

case class ActorContext(self: actor.ActorRef, ctx: actor.ActorContext)

class AkkaWrapper(var behavior: Behavior)
  extends actor.Actor with actor.ActorLogging {

  implicit val ctx = ActorContext(self, context)

  def receive = {
    case msg: Msg =>
      log.info(s"$\$${behavior}: $\$${msg}")
      behavior = behavior.processMsg(msg)

    case _ => ()
  }
}

abstract class ActorSystem(val system: actor.ActorSystem) {
  def spawn(behavior: Behavior, name: String): actor.ActorRef = {
    system.actorOf(actor.Props(new AkkaWrapper(behavior)), name = name)
  }

  def run(): Unit
}
\end{Code}

\begin{Code}{PureScala}{lst:akkashimex}{Akka shim for our Actor system framework}
@extern
object System extends ActorSystem("rep-counter-sys") {
  def run(): Unit = {
    val backup  = spawn(BackupB(0), "backup")
    val primary = spawn(PrimaryB(0, backup), "primary")

    primary ! Inc()
  }
}

@extern
def main(args: Array[String]): Unit = {
  System.run()
}
\end{Code}

\subsection{Conclusion}

\TODO{Conclusion}

\subsection{Further Work}

\subsubsection*{Real-world Case Study}

\subsubsection*{Weaker Guarantees On Message Delivery}

\subsubsection*{Name Uniqueness}

It is important to note that, within this model, actor references are not guaranteed to be unique as a user could spawn two actors with the same name. \TODO{++}

\subsection{Reasoning About Traces}

\TODO{Traces}

%\clearpage
%\section{Verification of Conflict-Free Replicated Data Types}
%\label{crdt}
%
%\textbf{\textcolor{Red}{Will only be included if time allows}}
%
%\subsection{Motivation}
%
%Because both faults and network partitions are a common occurrence in distributed systems, these often make use of data replication in order to improve reliability \TODO{citation}, which itself can lead to  consistency issues. One increasingly popular way to mitigate this problem is to model the replicated data using \textit{Conflict-free Replicated Data Types} (CRDTs) \cite{crdt} \cite{crdtstudy}. These data types come in two flavours: \textit{Commutative Replicated Data Types} (CmRDTs, or \textit{Op-based CRDTs}) and \textit{Commutative Replicated Data Types} (CvRDTs, or \textit{State-based CDRTs}).
%
%\TODO{Explain eventual consistency + both models + choice of CvRDTs}
%
%\subsection{Verifying CRDTs Implementations}
%
%\subsubsection{GCounter}
%\subsubsection{PNCounter}
%\subsubsection{GSet}
%\subsubsection{TwoPSet}
%\subsubsection{ORSet}
%
%\subsection{Conclusion}
%
%\TODO{Conclusion}

\clearpage
\section{Biparty Communication Protocols}
\label{biparty}

\subsection{Motivation}
\label{sess-mot}

Most systems made of components exchanging messages between them, such as Actor systems, do so by following a \textit{communication protocol}. A protocol is a set of rules which the components must follow when receiving, processing, and replying to a message. While it is possible to verify that a system correctly implements a given protocol, doing so is usually not trivial and often requires a sizeable amount of work, depending of course on the model one is working with. In the case of the Actor model we developed in \RefSec{actors}, in which messages are \textit{unityped}, verifying that a system followed some kind of protocol often required encoding a small type system within the invariants, for example to ensure that a message sent by an actor was of the right type. Moreover, we also had to check whether an actor would actually send a reply when it was expected of it. While being very interesting properties to verify, we would rather rely on the actual type system to catch any mistakes directly when writing the implementation.

As we have unfortunately not found a way to provide even just a typed API for our model, and do not expect to find a solution within the scope of this project, we now turn our attention to simpler, synchronous systems involving only two parties communicating over a \textit{channel} with two endpoints, one for sending messages and one for receiving them. Such a system might be an ATM and a user willing to withdraw money communicating through a screen, or a browser and a web server attempting to initialise a secure connection through a TCP socket. The protocols governing such systems that we are going to study in this chapter are called \textit{biparty communication protocols}. Such protocols have the interesting property that the description of the protocol from the viewpoint of one party is enough to deduce the protocol that must be followed from the viewpoint of the other party. The dialogue between two parties is commonly referred to as a \textit{session}.\\

As a running example for the next sections, we will consider a very simple protocol involving two parties Alice and Bob, and four messages \stt{Greet}, \stt{Hello}, \stt{Bye}, and \stt{Quit}.
From the viewpoint of Alice, the protocol is informally described as follows: Alice must send Bob either the message \stt{Quit} or \stt{Greet}. In the first case the sessions then ends, otherwise she can expect to receive either the message \stt{Bye}, ending the session, or the message \stt{Hello}, after which the session continues from the start.\\

It is important to note that, for the an implementation of such protocols to be correct, assuming an underlying reliable delivery channel, each party must both send the correct message when it is expected of them, and handle all possible messages that they can expect to receive at some point. A implementation of a party which fails to do so is deemed incorrect in that framework.

\subsection{Session Types}

Session types \cite{Honda:1998:LPT:645392.651876} provide a way to encode such protocols at the type level, thus guiding the programmer during the implementation while also guarding against mistakes such as not handling a certain message type or failing to reply to a message. Their syntax is shown in \RefFig{fig:sess-syntax}.

\begin{figure}
\begin{align*}
T\quad::=&\quad 	S
   \quad|\quad \texttt{Int}
   \quad|\quad \texttt{Boolean}
   \quad|\quad \texttt{String}
   \quad|\quad \ldots \tag*{payload}
\\
S\quad::=&\quad 	\,\&\,\{\,l_i: S_i\,\}_{i\in I}			\tag*{branching}\\
        |&\quad 	\oplus\{\,l_i: S_i\,\}_{i\in I}			\tag*{selection}\\
		|&\quad 	?T.\, S									\tag*{receive}\\
		|&\quad 	!T.\, S									\tag*{send}\\
        |&\quad		\mu_X.\, S								\tag*{recursion}\\
        |&\quad 	X  										\tag*{variable}\\
        |&\quad 	\epsilon								\tag*{termination}\\
\end{align*}
\vspace{-20pt}
\caption{Syntax of session types \label{fig:sess-syntax}}
\end{figure}

We show below the session types $S_A$ and $S_B$ corresponding to the protocol we defined in \RefSec{sess-mot}, from the viewpoint of Alice and Bob, respectively.
\begin{align*}
S_A &= \mu\alpha.\,\bigg(!\stt{Greet}.\,\Big(?\stt{Hello}.\,\alpha\ \&\ ?\stt{Bye}.\, \epsilon \Big)\ \oplus\ !\stt{Quit}.\,\epsilon \bigg)\\
S_B &= \mu\alpha.\,\bigg(?\stt{Greet}.\,\Big(!\stt{Hello}.\,\alpha\ \oplus\ !\stt{Bye}.\, \epsilon \Big)\ \&\ ?\stt{Quit}.\,\epsilon \bigg)\\
\end{align*}
\vspace{-30pt}

We draw the reader's attention to the similarity between the two types, and note that the $S_B$ reads the same as $S_A$ if one substitutes $!$ for $?$, $\oplus$ for $\&$, and vice-versa. Each type is in fact the \textit{dual} of the other, a property we formalise in \RefFig{fig:dual}.\\

\begin{figure}
{\large
\begin{align*}
\overline{\overline{S}}\qquad&::=\qquad S\\
\overline{\&\{\,l_1: S_1, \ldots, l_n: S_n\,\}}\qquad&::=\qquad\oplus\{\,l_1: \overline{S_1}, \ldots, l_n: \overline{S_n}\,\}\\
\overline{?T.\, S} \qquad&::=\qquad !T.\, \overline{S}\\
\overline{\mu\alpha.\, S} \qquad&::=\qquad \mu\alpha.\, \overline{S[\overline{\alpha}/\alpha]}\\
\overline{X} \qquad&::=\qquad X\\
\overline{\epsilon} \qquad&::=\qquad \epsilon
\end{align*}
}%
\vspace{-20pt}
\caption{Duality of session types \label{fig:dual}}
\end{figure}

\subsection{Session Types and Linearity}

Although session types were originally meant to be implemented as a separate syntactic category of types and terms to be added to the $\pi$-calculus, it has been shown that it possible to encode them directly in a calculus or language with both \textit{linear types} and \textit{variants} \cite{Wadler:2012:PS:2364527.2364568, Dardha:2012:STR:2370776.2370794}.\\

While there are many ways to perform such an encoding and provide a collection of combinators to build values of such types while enforcing the associated safety properties, the existing approaches \cite{st_lin_haskell, Jespersen:2015:STR:2808098.2808100} either rely on more expressive type systems than the one provided by Stainless, eg. \textit{substructural type systems} or ones which provide \textit{path families}, \textit{higher-kinded types} and \textit{indexed monads}, or \textit{path-dependent types}. \TODO{\RefCode{full-sessions} presents such an implementation in Scala.} In the next section we look at a solution to this problem which only require minimal and orthogonal modifications to Stainless's type system.

\subsection{Value-Level Sessions Encoding}

The \textit{lchannels} Scala library \cite{lchannels} provides a lightweight, value-level encoding of sessions which does not rely on advanced type system features. This encoding essentially corresponds to the \textit{continuation-passing-style} transformation of session types. In their library, the two endpoints (one for receiving, one for sending) of the communication channel between two parties are represented as values of the two types \stt{In} and \stt{Out}, respectively. These types are parametrised by the type of value that they accept or produce, and provide methods to send or receive such messages. \RefCode{lst:lchannels} shows a subset the API provided by the library.

\begin{Code}{PureScala}{lst:lchannels}{\textit{lchannels} library interface}
abstract class In[+A] {
  // Blocks until a message is received through the channel and returns it.
  def receive(implicit d: Duration): A
  
  // Map over the next message received and returns the result.
  def ?[B](f: A => B)(implicit d: Duration): B = {
    f(receive)
  }
}

abstract class Out[-A] {
  // Sends a message through the channel.
  def !(msg: A): Unit

  // Sends a message which will trigger a reply, and returns the
  // endpoint to receive the reply from.
  // Expects the provided function to embed the given
  // output endpoint into the message before returning it.
  // and returns an endpoint for receiving it.
  def !![B](h: Out[B] => A): In[B] = {
    val (in, out) = create[B]()
    this ! h(out)
    in
  }
  
  // Sends a message after which another message must be sent as well.
  def !![B](h: In[B] => A): Out[B]

  // Creates a new channel and return its two endpoints.
  def create[B](): (In[B], Out[B])
}
\end{Code}

\RefCode{lst:lchannels-hello} shows the encoding of the protocol we have been working with so far with this framework.

\begin{Code}{PureScala}{lst:lchannels-hello}{\textit{lchannels} implementation of a simple protocol}
abstract class AliceBob
case class Quit()                     extends AliceBob
case class Greet(cont: Out[Response]) extends AliceBob

abstract class Response
case class Hello(cont: Out[AliceBob]) extends Response
case class Bye()                      extends Response\
\end{Code}

\subsection{Linear Types in Stainless}

\newcommand{\lin}[1]{\stt{Linear[#1]}}

In this section, we discuss our implementation of linear types in Stainless, and note that, because the PureScala AST we are working with in Stainless is already typed, there is no need to write a full-fledged type checker. We will hence rather describe a \textit{linearity checker} for PureScala programs.

\subsubsection{Introducing Linear Types}

First of all, we need a way to introduce to mark some types as \textit{linear}. To this end, we define a covariant type constructor \stt{Linear}, which simply holds a value of type \stt{A}. This type provides a \stt{!} method to consume the linear term and return the underlying value. This enables the user to call a method of the underlying type in a concise way. As the astute reader might have noticed, this effectively adds weakening to the linear type system, and, as we will see, some care will be needed to handle such conversions properly. For example, if one had a value \stt{foo} of type \stt{Linear[Option[A]]}, one could call the \stt{isEmpty} method on the underlying value by writing \stt{foo!.isEmpty}. While making the consumption of a linear value explicit in this way is good for reasoning about one's code, there is still a bit of clutter associated with it, we also introduce an opt-in implicit conversion \stt{delinearize} from any \stt{Linear[A]} to \stt{A}. At last, because converting a non-linear value of type \stt{A} to a linear value of type \stt{Linear[A]} is always safe, we provide a such an implicit conversion by default, \stt{linearize}. \RefCode{lst:lineardef} shows the full definitions. Because those will be extracted in a specific way, they are marked \stt{@ignore}.

\begin{Code}{PureScala}{lst:lineardef}{Linear wrapper for Scala types and values}
package stainless

import stainless.lang._
import stainless.annotation._

package object linear {

  @ignore
  class Linear[+A](_value: A) {
    def ! = _value
  }
  
  @ignore
  implicit def linearize[A](value: A): Linear[A] = new Linear(value)
  
  object implicits {
    @ignore
    implicit def delinearize[A](lin: Linear[A]): A = lin!
  }
}
\end{Code}

\subsubsection{Preventing Weakening}

We now describe what it means for a linear term to be \textit{consumed}: a term \stt{t} of type \stt{Linear[A]}, for any type \stt{A}, is deemed \stt{consumed} in an expression $e$ when any of the following propositions is true:

\begin{itemize}
\item The underlying value of type \stt{A} is extracted, via the \stt{!} method, eg. $e = \stt{t!}$.
\item The term is assigned to a variable, eg. \stt{val s:\,Linear[A] = t}.
\item The term is supplied as an argument to function, eg. given \stt{def f(x:\,Linear[A]):\,B}, we have $e = \stt{f(t)}$.
\item The term is supplied as an argument to a method, eg. given a class \stt{C} with a method \stt{def m(x:\,Linear[A]):\,B}, a value $v:\, C$, we have $e = \stt{v.m(t)}$.
\item The term is supplied as an argument to a lambda, eg. given \stt{val l:\,Linear[A] => B}, we have $e = \stt{l(t)}$.
\item The term is supplied as an argument to a constructor, eg. given \stt{case class C(x: Linear[A])}, we have $e = \stt{C(t)}$.
\end{itemize}

\textit{Note: Method calls are subsumed by the first rule, as a linear value must first be delinearized with the \stt{!}\,operator before one can call a method on the underlying value.}\\

We now must ensure that no linear term is \textit{consumed} more than once. To this end, we must recursively walk down the AST, while keeping track of terms that have been consumed in a \textit{usage context}, in order to disallow subsequent uses of those terms. We will denote this context by $\Delta$. \TODO{\RefFig{fig:lintypesrules} presents the type-checking rules used to reject invalid programs.}\\

The astute reader will have noticed that the presence of the \stt{!}\,operator, if not handled carefully, would actually allow weakening. For example, given a value \stt{a:\,Linear[A]}, one could write \stt{val b:\, A = a.!}, and thus obtain a non-linear reference to the underlying value. To counter this, the linearity checker treats any expression of the form \stt{$e$.!}, with \stt{$e$:\,Linear[A]}, as having type \stt{Linear[A]} instead of \stt{A}.

\subsubsection{Preventing Contraction}

Because linear logic does not allow contraction, we must also ensure that no linear term is \textit{dropped}, that is to say, that it is \textit{consumed} at least once. To this end, we first collect all linear variables being introduced in a function definition, for example as a parameter to the function, in a variable binding, or within a pattern in a \texttt{clause} (even as a wildcard). Then, after having ran the type-checking algorithm described in the previous section, we can make use of the resulting \textit{usage context} $\Delta$ to check whether each and every of those variable has indeed been \textit{consumed} at some point, and reject the program otherwise.

\subsubsection{Linear Terms in Contracts}

It is important to note that, when running the linearity checker over a function with pre- and/or post-conditions, these are ignored for the following reason: a user might want to constrain either a linear parameter of some function, or its return value. If we ran the linearity checker on such contracts, then one would not be able to re-use the linear variable that is being constrained in the precondition, or would not be able to reference any linear parameter in the postcondition. \RefCode{lst:prepostlinear} shows such a use-case.

\begin{Code}{PureScala}{lst:prepostlinear}{Usage of a linear variable in a function's precondition}
def foo(x: Linear[Option[BigInt]]): BigInt = {
  require(!x.isEmpty && x.get > 0)
  x.get * 2
} ensuring { _ > 0 }
\end{Code}

Fortunately for us, because a function's contract will be statically verified by Stainless, there is no point to check it at runtime. Hence, in Stainless's library, both the \stt{require} function and the \stt{ensuring} method discard their body. For this reason, we can safely ignore linearity constraints in a function's contract.\\

\subsubsection{Linear Data Types}

Because data types can contain linear fields, one must be careful as to when to allow values of such types to be introduced. Indeed, if one were to define a data type \stt{case class A(x:\,Linear[B])}, one should not be allowed to construct a non-linear term of type \stt{A}. That is because doing so would permit the user to have more than one (indirect) reference to the linear \stt{x} field, which is forbidden because of the No-Weakening rule. We must thus ensure that values such types are only introduced linearly, ie. as values of type \stt{Linear[A]}, whether it is as a function parameter, as a variable binding, or as field of another data type. \RefCode{lst:linearadt} features a few examples of this rule in action.

\begin{Code}{PureScala}{lst:linearadt}{Linear data types in action}
case class A(x: Linear[BigInt])

case class B(a: A)          // error
case class C(b: Linear[A])  // ok

def f(x: A): A = { // error
  x
}

def g(x: Linear[A]): Linear[A] = { // ok
  x
}

def h(x: C): Linear[A] = c match {
  case C(b) => b // ok
}

def i(x: BigInt): A = c match { // error
  A(x)
}

def j(x: BigInt): Linear[A] = c match {
  A(x) // ok
}

def k(x: BigInt): Linear[BigInt] = c match {
  A(x) match {
    case A(y) => y // error
  }
}
\end{Code}

\subsubsection{Marking the Current Object as Linear}

Another issue arise when dealing with data types meant to be introduced linearly if these have associated methods. To understand why, let's look at an example. \RefCode{lst:linfile} shows a very simple API which allows to open a file, read its content line-by-line, or read all its content at once. We would like to make sure that, once a user opens a \stt{File} and receives the associated \stt{FileHandler}, the latter must be closed. Unfortunately, when implementing the \stt{contents} method, nothing prevents the programmer to call \stt{readLine} twice on the current object. That is because, Within \stt{contents}, \stt{this} has type \stt{FileHandler}, and calling any method on it will thus not consume it. As it is not possible in Scala to constrain the type of the current object, even with self-annotations, we introduce a method annotation \stt{@linear} which signals to the linearity checker that, within an annotated method of a class \stt{C}, \stt{this} should be considered to have type \stt{Linear[C]}. As methods inherit the annotations of their enclosing class, it is here enough to annotate the \stt{FileHandler} class with \stt{@linear}.

\begin{Code}{PureScala}{lst:linfile}{Linear File API}
class File {
  def open: Linear[FileHandler] = /* ... */
}

class FileHandler {
  def readLine: (Option[String], Linear[FileHandler]) = /* ... */
  def close: Unit = /* ... */
  
  def contents: String = {
    val (res, h) = this.readLine
    doSomething(this.readLine) // should be disallowed
    res match {
      case Some(line) =>
        line + h!.contents

      case None() =>
        h!.close
        ""
    }
  }
}
\end{Code}

\subsubsection{Higher-Order Linear Functions}

\TODO{Discuss syntax for linear lambdas}

%\begin{landscape}
%\begin{figure}[htb]
%\begin{framed}
% 
%\begin{equation}
%\dfrac{
%  \Delta \vdash t:\,\lin{A}
%}{
%  \Delta \cup t \vdash t! : A
%}
%\end{equation}
%
%\begin{equation}
%\dfrac{
%  \Delta \vdash t:\,\lin{A} \qquad \Delta \cup t \vdash b:\,B
%}{
%  \Delta \cup t \vdash \stt{val x:\,\lin{A} = $t$; $b$} : B
%}
%\end{equation}
%
%\begin{equation}
%\dfrac{
%  \Delta \vdash f :\,(T_1, \ldots, \lin{$T_i$}, \ldots, T_n) \to S
%  \quad \Delta \vdash t_i : \lin{$T_i$} \\
%  \quad \Delta \vdash (t_1, \ldots, t_{i-1}) :\, (T_1, \ldots, T_{i-1})
%  \quad \Delta \cup t \vdash (t_{i+1}, \ldots, t_{i-1}) :\, (T_1, \ldots, T_{i-1})
%}{
%  \Delta \cup t \vdash f(t_1, \ldots, t_i \ldots, t_n) : S
%}
%\end{equation}
%
%\end{framed}
%\vspace{-10pt}
%\caption{Typing rules \label{fig:lintypesrules}}
%\end{figure}
%\begin{landscape}

\subsection{Sessions Library in PureScala}
\label{sessions_lib}

\RefCode{lst:sessions} shows a PureScala implementation of the \textit{lchannels} library. For the purpose of verification, we do not need a full-fledged implementation of the channels, but only declarations mirroring the Scala library. This way, one could run their implementation with the original library by simply linking against both it and the Stainless library, without relying on our library.

\begin{Code}{PureScala}{lst:sessions}{Sessions library in PureScala}
type In[A]  = Linear[InChan[A]]
type Out[A] = Linear[OutChan[A]]

@linear @library
class InChan[A] {

  @extern
  def receive(implicit d: Duration): Linear[A] = {
    ???
  }

  def ?[B](f: Linear[A] => B)(implicit d: Duration): B = {
    f(receive)
  }
}

@linear @library
class OutChan[A] {

  @extern
  def send(msg: A): Unit = {
    ???
  }

  def !(msg: A): Unit = {
    send(msg)
  }

  @extern
  def !![B](h: Out[B] => A): In[B] = {
    ???
  }

  @extern
  def create[B](): (In[B], Out[B]) = {
    ???
  }
}
\end{Code}

\subsection{Case Studies}

\subsubsection{ATM Protocol}

Let's consider a protocol involving an ATM and its user, which we informally describe below:

\begin{enumerate}[label=\Alph*]
\item The user authenticates herself by sending the ATM both her card number and PIN.
\item If the authentication succeeds, the ATM displays a menu to the user, who can then choose to:
\begin{enumerate}
\item Abort the process altogether.
\item Ask for her account's balance, in which case the server will reply with the balance, and displays the menu again.
\end{enumerate}
\item If the authentication fails, the ATM notifies the user of the failure, and the process is aborted.
\end{enumerate}

\RefCode{lst:atm_desc} shows the encoding of such a specification using the library described in \RefSec{sessions_lib}. \RefCode{lst:atm_impl} shows the corresponding valid implementation. At last, \RefCode{lst:atmmistake} shows an incorrect implementation of the protocol that would still verify without the linearity checker. We discuss the three use cases below:

\begin{enumerate}
\item If we provide an empty body for the \stt{atm} function, we would then be greeted with the following error:

\begin{ShortCode}{PureScala}
$\texttt{\textbf{\textcolor{Red}{Error}}}$: linear variable `c` of type `Linear[In[Authenticate]]` is never used:
                 def atm(c: Linear[In[Authenticate]]): Unit = {
                         $\texttt{\textbf{\textcolor{Red}{\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum}}}$
\end{ShortCode}

Re-using the same channel twice would also give rise to an error:

\begin{ShortCode}{PureScala}
$\texttt{\textbf{\textcolor{Red}{Error}}}$: linear term `cont` has already been used: doSomething(cont)
                               $\texttt{\textbf{\textcolor{Red}{\textasciicircum\textasciicircum\textasciicircum\textasciicircum}}}$
$\texttt{\textbf{\textcolor{Blue}{Info}}}$: term used here: cont !! Balance(balance(card))(_) ? menu(card)
                                                            $\texttt{\textbf{\textcolor{Red}{\textasciicircum\textasciicircum\textasciicircum\textasciicircum}}}$
\end{ShortCode}

\item In case we forget to send back a failure notification when the authentication fails. The linearity checker will realise that the linear \stt{cont} is not consumed in every branch of the pattern match, and will pinpoint its introduction:

\begin{ShortCode}{PureScala}
$\texttt{\textbf{\textcolor{Red}{Error}}}$: linear variable `cont` of $\texttt{type}$ `Linear[OutChan[Response]]` is never used:
                 case Authenticate(_, _, cont) =>
                                         $\texttt{\textbf{\textcolor{Red}{\textasciicircum\textasciicircum\textasciicircum\textasciicircum}}}$
\end{ShortCode}

\item
At last, let's see what happens if we do not handle the reply to the \stt{Success} message sent in case the authentication succeeds. Because the expression \stt{cont !! Success(\_)} has type \stt{In[Menu]}, one could expect the Scala compiler to raise a type error, as the \stt{atm} function has return type \stt{Unit}. Unfortunately, the Scala compiler will happily convert any value to \stt{Unit} if it occurs at the end of a block. But because \stt{In[Menu]} is a linear type, the linearity checker will notice that the corresponding value is being discarded, and will raise an error:

\begin{ShortCode}{PureScala}
$\texttt{\textbf{\textcolor{Red}{Error}}}$: linear term cannot be discarded: cont !! Success(_)
                                        $\texttt{\textbf{\textcolor{Red}{\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum\textasciicircum}}}$
\end{ShortCode}
\end{enumerate}

\begin{Code}{PureScala}{lst:atm_desc}{ATM protocol description}
// Authentication request from the user
case class Authenticate(card: String, pin: String, cont: Out[Response])

// Authentication response from the ATM
sealed abstract class Response
case class Failure()                extends Response
case class Success(cont: Out[Menu]) extends Response

// Choices available to authenticated user
sealed abstract class Menu
case class CheckBalance(cont: Out[Balance]) extends Menu
case class Quit()                           extends Menu

// User account balance
case class Balance(amount: BigInt)(cont: Out[Menu]) {
  require(amount >= 0)
}
\end{Code}

\begin{Code}{PureScala}{lst:atm_impl}{Correct ATM protocol implementation}
def atm(c: In[Authenticate]): Unit = {
  c ? { auth => auth! match {  
    case Authenticate(card, pin, cont) if authenticated(card, pin) =>
      cont !! Success(_) ? menu(card)
  
    case Authenticate(_, _, cont)  =>
      cont ! Failure()
  } }
}

def menu(card: String)(menu: Linear[Menu]) = {
  menu! match {
    case CheckBalance(cont) =>
      cont !! Balance(balance(card))(_) ? menu(card)

    case Quit() => ()
  }
}

def authenticated(card: String, pin: String): Boolean = {
  /* ... */
}

def balance(card: String): BigInt = {
  /* ... */
} ensuring { _ >= 0 }
\end{Code}

\begin{Code}{PureScala}{lst:atm_user}{Correct user protocol implementation}
def getAmount(c: Out[Authenticate], card: String, pin: String): Option[BigInt] = {
  c !! Authenticate(card, pin, _) ? { res =>
    res! match {
      case Failure() => None()
      case Success(cont) => cont !! CheckBalance(_) ? {
        case Balance(amount)(cont) =>
          cont ! Quit()
          Some(amount)
      }
    }
  }
} ensuring { _ >= 0 }
\end{Code}

\begin{Code}{PureScala}{lst:atmmistake}{Incorrect implementation of the ATM protocol}
def atm(c: In[Authenticate]): Unit = {
  c ? { auth => auth! match {  
    case Authenticate(card, pin, cont) if authenticated(card, pin) =>
      // 3. do not wait for a reply to `Success` message
      cont !! Success(_)
  
    case Authenticate(_, _, cont) =>
      // 1. does not send back a Failure message

  } }
}

def menu(card: String)(menu: Linear[Menu]): Unit = {
  menu! match {
    case CheckBalance(cont) =>
      cont !! Balance(balance(card))(_) ? menu(card)
      
      // 2. `cont` has already been used
      doSomething(cont)

    case Quit() => ()
  }
}
\end{Code}

\subsubsection{TLS 1.2 Handshake}

\TODO{TLS 1.2 Handshake}

\footnote{The Transport Layer Security (TLS) Protocol - Version 1.2: \url{https://www.ietf.org/rfc/rfc5246.txt}}

\subsection{Conclusion}

\TODO{Conclusion}

\subsection{Further Work}

\subsubsection*{Actor Systems with Linear References}

\TODO{Actor Systems with Linear References}

\subsubsection*{Multiparty Session Types for Actor Systems}

\cite{DBLP:journals/corr/NeykovaY16}

\subsubsection*{Affine Types and Borrow Checking}

After implementing a very basic borrow checker with static lifetimes within Stainless, \TODO{etc...}

\clearpage
\section{Conclusion}
\label{conclusion}

\TODO{Conclusion}

\clearpage

\appendix

\begin{landscape}
\section{Scala Implementation of Sessions Types}
\label{full-sessions}
\lstinputlisting[language=PureScala, style=LongCode]{code/full-sessions.scala}
\end{landscape}

\clearpage

%\nocite{*}
\bibliographystyle{ieeetr}
\bibliography{report}



\end{document}
