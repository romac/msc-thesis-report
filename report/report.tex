\include{header}

\clearpage
\pagestyle{mystyle}

\section{Introduction}

\TODO{Introduction}

\subsection*{Related Works}

\TODO{Related Works}

\section{Motivation}
\label{motivation}


\TODO{Motivation}

\clearpage
\section{Verifiying Actor Systems}
\label{actors}

\subsection{The Actor Model}

\TODO{Actor Model}

\cite{actario}

\subsubsection{Message}

In our framework, messages are modelled as instances of the \InlineS{Msg} trait.

\begin{ShortCode}{PureScala}
abstract class Msg
\end{ShortCode}

\subsubsection{Actor Reference}

Each actor is associated with a unique and persistent reference, modelled as an instance
of the \ActorRef trait.

\begin{ShortCode}{PureScala}
abstract class ActorRef
\end{ShortCode}

\subsubsection{In-flight Messages}

In-flight messages are represented as a product of the \ActorRef of the destination actor,
and the message itself.

\begin{ShortCode}{PureScala}
case class Packet(dest: ActorRef, payload: Msg)
\end{ShortCode}

\subsubsection{Actor Context}

When a message is delivered to an actor, the latter is provided with a context,
which holds a reference to itself, and a mutable list of \InlineS{Packet}s to send.

\begin{ShortCode}{PureScala}
case class ActorContext(
  self: ActorRef,
  var toSend: List[Packet]
)
\end{ShortCode}

\subsubsection{Behavior}

A behavior specifies both the current state of an actor, and how this one should 
process the next incoming message. In our framework, these are modelled as a subclass 
of the abstract class \InlineS{Behavior}, which defines a single abstract method 
\InlineS{processMsg}, to be overriden for each defined behavior.

Using the provided \InlineS{ActorContext}, the implementation of the \InlineS{processMsg}
method can both access its own reference, and register messages to be sent after the
execution of the method is complete. It is also required to return a new \InlineS{Behavior}

\begin{ShortCode}{PureScala}
abstract class Behavior {
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior
}
\end{ShortCode}

\subsubsection{Transition}

Whenever a message is processed, we record the transition between the previous 
state of the system and the one after the message has been been processed. We keep 
track of this information as an instance of the \InlineS{Transition} class, which 
holds: the \InlineS{Msg} that has been delivered, its sender and receiver, the new 
behavior of the destination actor, and the list of \InlineS{Packet}s the destination 
actor wants to send.

\begin{ShortCode}{PureScala}
case class Transition(
  from: ActorRef,
  to: ActorRef,
  msg: Msg,
  newBehavior: Behavior,
  toSend: List[Packet]
)
\end{ShortCode}

\subsubsection{Actor System}

The state of the Actor system at a given point in time is modelled as a case class, 
holding the behavior associated with each actor reference, the list of in-flight messages 
between any two actors, as well as a trace of the execution up to that point, 
modelled as a list of \InlineS{Transition}s.

\begin{ShortCode}{PureScala}
case class ActorSystem(
  behaviors: CMap[ActorRef, Behavior],
  inboxes: CMap[(ActorRef, ActorRef), List[Msg]],
  trace: List[Transition]
)
\end{ShortCode}

The \InlineS{ActorSystem} class is equipped with a \InlineS{step} method, which takes 
a pair of \ActorRef as arguments, and is in charge of delivering the oldest message 
found in the corresponding inbox, and which returns the new state of the system after 
the aforementioned message has been processed.

\begin{ShortCode}{PureScala}
def step(from: ActorRef, to: ActorRef): ActorSystem
\end{ShortCode}

\subsection{Operational Semantics}
\label{semantics}

We formulate the small-step operational semantics of our Actor model in \RefFig{fig:opsem}.

\TODO{Operational semantics}

\begin{figure}[!h]
\label{fig:opsem}
\begin{framed}
 
\begin{equation}
\dfrac{
  \not\exists m \in \stt{s.inboxes}(n_{from}, n_{to})
}{
  \langle \stt{s.step}(n_{from}, n_{to}) \rangle \longrightarrow \stt{s}
}
\tag{STEP-NOMSG}
\end{equation}
\vspace{10pt}
\begin{equation}
\dfrac{
  \exists m \in \stt{s.inboxes}(n_{from}, n_{to}) \qquad
  \langle \stt{s.deliverMsg}(n_{to}, n_{from}, m) \rangle \Rightarrow (b, ps, t)
}{
  \langle \stt{s.step}(n_{from}, n_{to}) \rangle \longrightarrow s \uplus (n_{to} \mapsto b, \ldots, t)
}
\tag{STEP}
\end{equation}
\vspace{10pt}
\begin{equation}
\dfrac{
  \langle \stt{s.behaviors($n_{to}$).processMsg}(m, \emptyset_{n_{to}}) \rangle \longrightarrow (b, c) 
}{
   \langle \stt{s.deliverMsg}(n_{to}, n_{from}, m) \rangle \longrightarrow (b, \stt{c.toSend}, t)
}
\tag{DELIVER-MSG}
\end{equation}
\vspace{10pt}
\begin{equation}
\dfrac{
  \langle \stt{s.behaviors($n_{to}$).processMsg}(m, \emptyset_{n_{to}}) \rangle \longrightarrow (b, c) 
}{
   \langle \stt{s.deliverMsg}(n_{to}, n_{from}, m) \rangle \longrightarrow (b, \stt{c.toSend}, t)
}
\tag{DELIVER-MSG}
\end{equation}
\vspace{10pt}
\begin{equation}
\dfrac{
  \stt{b.processMsg}(m, \emptyset_{n_{to}}) = [i_1, \ldots, i_n, b'] \qquad
  \emptyset_{n_{to}} \vdash \langle [i_1, \ldots, i_n] \rangle \Rightarrow c
}{
   \langle \stt{b.processMsg}(m, \emptyset_{n_{to}}) \rangle \longrightarrow (b', c)
}
\tag{PROCESS-MSG}
\end{equation}
\vspace{10pt}
\begin{equation}
\dfrac{\empty}{
   \langle Nil, c \rangle \Rightarrow c
}
\tag{I-NIL}
\end{equation}
\vspace{10pt}
\begin{equation}
\dfrac{
  \langle i, c \rangle \Rightarrow c'
}{
  \langle i :: is, c \rangle \Rightarrow \langle is, c' \rangle
}
\tag{I-CONS}
\end{equation}

\vspace{10pt}
\begin{equation}
\dfrac{
  \langle [i_1, \ldots, i_n], \emptyset_{n_{to}} \rangle \Rightarrow c
}{
   \langle \stt{n ! m}, c \rangle \Rightarrow (b',\ \stt{c.copy(toSend $\mapsto$ (n, m) :: c.toSend)})
}
\tag{I-SEND}
\end{equation}

\end{framed}
\vspace{-10pt}
\caption{Operational semantics}
\end{figure}

$$\emptyset_n := \stt{ActorContext}(n, \emptyset)$$

\subsection{Proving Invariants}
\label{invariants}

After defining an Actor system with our framework, one might want to verify that this 
system preserves some invariant between each step of its execution.

\subsection{Reasoning About Traces}
\label{traces}

\TODO{Traces}

\subsection{Executing an Actor System with Akka}
\label{traces}

\section{Strong Eventual Consistency with CRDTs}
\label{crdt}

\TODO{CRDTs}

\section{Biparty Communication Protocols}
\label{biparty}

\TODO{Bipart}

\section{Conclusion}
\label{conclusion}

\TODO{Conclusion}

\section{Future Work}
\label{futurework}

\appendix

\TODO{Future Work}

\clearpage

\bibliographystyle{ieeetr}
\bibliography{report}

\end{document}
