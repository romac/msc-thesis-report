\include{header}

\clearpage
\pagestyle{mystyle}

\section{Introduction}

\TODO{Introduction}

\subsection*{Related Works}

\TODO{Related Works}

\section{Motivation}
\label{motivation}


\TODO{Motivation}

\clearpage
\section{Verifiying Actor Systems}
\label{actors}

\subsection{The Actor Model}

\TODO{Actor Model}

\cite{actario}

\subsubsection{Message}

In our framework, messages are modelled as instances of the \InlineS{Msg} trait.

\begin{ShortCode}{PureScala}
abstract class Msg
\end{ShortCode}

\subsubsection{Actor Reference}

Each actor is associated with a unique and persistent reference, modelled as an instance
of the \ActorRef trait.

\begin{ShortCode}{PureScala}
abstract class ActorRef
\end{ShortCode}

\subsubsection{In-flight Messages}

In-flight messages are represented as a product of the \ActorRef of the destination actor,
and the message itself.

\begin{ShortCode}{PureScala}
case class Packet(dest: ActorRef, payload: Msg)
\end{ShortCode}

\subsubsection{Actor Context}

When a message is delivered to an actor, the latter is provided with a context,
which holds a reference to itself, and a mutable list of \InlineS{Packet}s to send.

\begin{ShortCode}{PureScala}
case class ActorContext(
  self: ActorRef,
  var toSend: List[Packet]
)
\end{ShortCode}

\subsubsection{Behavior}

A behavior specifies both the current state of an actor, and how this one should 
process the next incoming message. In our framework, these are modelled as a subclass 
of the abstract class \InlineS{Behavior}, which defines a single abstract method 
\InlineS{processMsg}, to be overriden for each defined behavior.

Using the provided \InlineS{ActorContext}, the implementation of the \InlineS{processMsg}
method can both access its own reference, and register messages to be sent after the
execution of the method is complete. It is also required to return a new \InlineS{Behavior}

\begin{ShortCode}{PureScala}
abstract class Behavior {
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior
}
\end{ShortCode}

\subsubsection{Transition}

Whenever a message is processed, we record the transition between the previous 
state of the system and the one after the message has been been processed. We keep 
track of this information as an instance of the \InlineS{Transition} class, which 
holds: the \InlineS{Msg} that has been delivered, its sender and receiver, the new 
behavior of the destination actor, and the list of \InlineS{Packet}s the destination 
actor wants to send.

\begin{ShortCode}{PureScala}
case class Transition(
  from: ActorRef,
  to: ActorRef,
  msg: Msg,
  newBehavior: Behavior,
  toSend: List[Packet]
)
\end{ShortCode}

\subsubsection{Actor System}

The state of the Actor system at a given point in time is modelled as a case class, 
holding the behavior associated with each actor reference, the list of in-flight messages 
between any two actors, as well as a trace of the execution up to that point, 
modelled as a list of \InlineS{Transition}s.

\begin{ShortCode}{PureScala}
case class ActorSystem(
  behaviors: CMap[ActorRef, Behavior],
  inboxes: CMap[(ActorRef, ActorRef), List[Msg]],
  trace: List[Transition]
)
\end{ShortCode}

The \InlineS{ActorSystem} class is equipped with a \InlineS{step} method, which takes 
a pair of \ActorRef as arguments, and is in charge of delivering the oldest message 
found in the corresponding inbox, and which returns the new state of the system after 
the aforementioned message has been processed.

\begin{ShortCode}{PureScala}
def step(from: ActorRef, to: ActorRef): ActorSystem
\end{ShortCode}

\subsection{Operational Semantics}
\label{semantics}

We formulate the small-step operational semantics of our Actor model in 
\RefFig{fig:opsem}, where $s: \stt{ActorSystem}$ is an Actor system,
$m: \stt{Msg}$ is a message,
$n, n_{to}, n_{from}: \stt{ActorRef}$ are references,
$b, b': \stt{Behavior}$ are behaviors,
$ps: \stt{List[Packet]}$ a list of packets to send,
$t: \stt{Transition}$ is a transition,
$c: \stt{ActorContext}$ is a context,
and $\emptyset_n: \stt{ActorContext}$ is the empty context for an actor whose
self-reference is $n$, defined as $\emptyset_n := \stt{ActorContext}(n, \stt{Nil})$.

\begin{figure}[!h]
\begin{framed}
 
\begin{equation}
\dfrac{
  \not\exists m \in \stt{$s$.inboxes}(n_{from}, n_{to})
}{
  \langle \stt{$s$.step}(n_{from}, n_{to}) \rangle \longrightarrow \stt{s}
}
\tag{STEP-NOMSG}
\end{equation}

\vspace{10pt}
\begin{equation}
\dfrac{
  \exists m \in \stt{$s$.inboxes}(n_{from}, n_{to}) \qquad
  \langle \stt{$s$.deliverMsg}(n_{to}, n_{from}, m) \rangle \Rightarrow (b, ps, t)
}{
  \langle \stt{$s$.step}(n_{from}, n_{to}) \rangle \longrightarrow s \uplus (n_{to} \mapsto b, \ldots, t)
}
\tag{STEP}
\end{equation}

\vspace{10pt}
\begin{equation}
\dfrac{
  \langle \stt{$s$.behaviors($n_{to}$).processMsg}(m, \emptyset_{n_{to}}) \rangle \longrightarrow (b, c) 
}{
   \langle \stt{$s$.deliverMsg}(n_{to}, n_{from}, m) \rangle \longrightarrow (b, \stt{$c$.toSend}, t)
}
\tag{DELIVER-MSG}
\end{equation}

\vspace{10pt}
\begin{equation}
\dfrac{
  \stt{$b$.processMsg}(m, \emptyset_{n_{to}}) = [i_1, \ldots, i_n, b'] \qquad
  \emptyset_{n_{to}} \vdash \langle [i_1, \ldots, i_n] \rangle \Rightarrow c
}{
   \langle \stt{$b$.processMsg}(m, \emptyset_{n_{to}}) \rangle \longrightarrow (b', c)
}
\tag{PROCESS-MSG}
\end{equation}

\vspace{10pt}
\begin{equation}
\dfrac{\empty}{
   \langle \stt{Nil}, c \rangle \Rightarrow c
}
\tag{I-NIL}
\end{equation}

\vspace{10pt}
\begin{equation}
\dfrac{
  \langle i, c \rangle \Rightarrow c'
}{
  \langle \stt{$i$ :: $is$}, c \rangle \Rightarrow \langle is, c' \rangle
}
\tag{I-CONS}
\end{equation}

\vspace{10pt}
\begin{equation}
\dfrac{\empty}{
   \langle n\ \stt{!}\ m, c \rangle \Rightarrow (b',\ \stt{$c$.copy(toSend $\mapsto$ ($n, m$) :: $c$.toSend)})
}
\tag{I-SEND}
\end{equation}

\end{framed}
\vspace{-10pt}
\caption{Operational semantics\label{fig:opsem}}
\end{figure}

\subsection{Proving Invariants}
\label{invariants}

After having defined an Actor system with our framework, one might want to verify that this 
system preserves some invariant between each step of its execution. That is to say, 
for an \InlineS{ActorSystem} $s$, any two \ActorRef $n, m$,
and an invariant \InlineS{inv: ActorSystem $\ \to\ $ Boolean}, if $\texttt{inv}(s)$ holds, 
then $\texttt{inv}(s\texttt{.step}(n, m))$ should hold as well. We express this 
property more formally in \RefFig{fig:stepinvariant}.

\begin{figure}[!h]
$$\forall s: \texttt{ActorSystem},\, n: \texttt{ActorRef},\, m: \texttt{ActorRef}.\ \texttt{inv($s$)} \implies \texttt{inv($s$.step($n, m$))}$$
\vspace{-20pt}
\caption{Invariant preservation property\label{fig:stepinvariant}}
\end{figure}

This property can be trivially expressed in PureScala as:

\begin{ShortCode}{PureScala}
def inv(s: ActorSystem): Boolean = {
  /* ... */
}

def preserveInv(s: ActorSystem, n: ActorRef, m: ActorRef): Boolean = {
  require(inv(s))
  inv(s.step(n, m))
} holds
\end{ShortCode}

When encoutering such a definition, Stainless will generate a verification condition 
equivalent to \RefFig{fig:stepinvariant}, which will then be discharged to Inox and the underlying SMT solver.

\subsection{Reasoning About Traces}
\label{traces}

\TODO{Traces}

\subsection{Case studies}
\label{casestudies}

\subsubsection*{Replicated Counter (increment)}

As a first and very simple case study, we will study an Actor system which models a
replicated counter, which can only be incremented by one unit. This system is 
composed of two actors, a primary counter whose reference is \texttt{Primary()},
and a backup counter whose reference is \texttt{Backup()}.
Each of these reference is associated with a behavior: the primary counter reference with
an instance of \texttt{PrimaryB}, and the backup counter reference with an instance 
of \texttt{BackupB}, both of which hold a positive integer, representing the value of the
counter. Whenever the primary actor receives a message \texttt{Inc()}, it forwards that
message to the backup actor, and returns a new instance of \texttt{PrimaryB} with the
counter incremented by one. When the backup actor receives an \texttt{Inc()} message,
it just returns a new instance of \texttt{BackupB} with the counter incremented by one. 
The corresponding PureScala implementation can be found
in \RefCode{lst:ReplicatedCounterInc}.

\begin{Code}{PureScala}{lst:ReplicatedCounterInc}{Replicated counter implementation (increment)}
case class Primary() extends ActorRef
case class Backup()  extends ActorRef

case class Inc() extends Msg

case class PrimaryB(counter: BigInt) extends Behavior {
  require(counter >= 0)
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case Inc() =>
      Backup() ! Inc()
      PrimaryB(counter + 1)
  }
}

case class BackupB(counter: BigInt) extends Behavior {
  require(counter >= 0)
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case Inc() => BackupB(counter + 1)
  }
}
\end{Code}

Given such a system, one might want to prove that the following invariant is 
preserved between each step of its execution:

\begin{Code}{PureScala}{lst:repcounterincinv}{Replicated counter invariant (increment)}
def invariant(s: ActorSystem): Boolean = {
  s.inboxes((Backup(), Backup())).isEmpty && {
    (s.behaviors(Primary()), s.behaviors(Backup())) match {
      case (PrimaryB(p), BackupB(b)) =>
        p.value == b.value + s.inboxes(Primary() -> Backup()).length
      case _ => false
    }
  }
}
\end{Code}

This invariant specifies that the \stt{Backup()} actor does not send itself any messages, that both actors have the proper corresponding behavior, and that, last but not least, the value of the primary counter is equal to the value of the backup counter added to the number of messages that are yet to be delivered to the backup actor.\\

We can now define the actual theorem we want Stainless to prove for us:

\begin{Code}{PureScala}{lst:repcounterincthm}{Replicated counter theorem (increment)}
def preserveInv(s: ActorSystem, n: ActorRef, m: ActorRef): Boolean = {
  require(invariant(s))
  invariant(s.step(n, m))
} holds
\end{Code}

\TODO{Rep Counter Inc Result}

\subsubsection*{Replicated Counter (deliver)}

\RefCode{lst:ReplicatedCounterDel} shows a variant of the previous case study, where instead of having the primary actor forward the \stt{Inc()} message to the backup actor, it instead delivers it with its new value.

\begin{Code}{PureScala}{lst:ReplicatedCounterDel}{Replicated counter implementation (deliver)}
case class Primary() extends ActorRef
case class Backup()  extends ActorRef

case class Inc() extends Msg
case class Deliver(c: BigInt) extends Msg

case class PrimaryB(counter: BigInt) extends Behavior {
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case Inc() =>
      Backup() ! Deliver(counter + 1)
      PrimaryB(counter + 1)

    case _ => Behavior.same
  }
}

case class BackupB(counter: BigInt) extends Behavior {
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case Deliver(c) => BackupB(c)
    case _          => Behavior.same
  }
}
\end{Code}

The invariant now reads slightly differently, as can be seen in \RefCode{lst:ReplicatedCounterDelInv}, and can no longer be proven automatically by Stainless on its own. \RefCode{lst:ReplicatedCounterDel} shows the full proof.

\begin{Code}{PureScala}{lst:ReplicatedCounterDelInv}{Replicated counter implementation (deliver)}
def invariant(s: ActorSystem): Boolean = {
  validBehaviors(s)                           &&
  noMsgsToSelf(Primary()).isEmpty             &&
  noMsgsToSelf(Backup()).isEmpty              &&
  noMsgsToSelf(Backup() -> Primary()).isEmpty && {
    val PrimBehav(p) = s.behaviors(Primary())
    val BackBehav(b) = s.behaviors(Backup())
    val bInbox       = s.inboxes(Primary() -> Backup())

    p.value >= b.value && isSorted(bInbox) && bInbox.forall {
      case Deliver(Counter(i)) => p.value >= i
      case _                   => true
    }
  }
}
\end{Code}

\TODO{Rep Counter Del Result}


\subsubsection*{Lock Service}

\RefCode{lst:LockService} shows the implementation of a lock service using our framework. In this case study, an actor acts as a server holding a lock on some resource, while a number of other actors (the "agents") act as clients of the lock service, each potentially trying to acquire the lock on the resource. To model a variable number of actors with the same implementation, we define their reference as a case class parametrized by a \TODO{unique} identifier.

\begin{Code}{PureScala}{lst:LockService}{Lock service implementation}
case class Server() extends ActorRef
object Server {
  case class Lock(agent: ActorRef) extends Msg
  case class Unlock(agent: ActorRef) extends Msg
}

case class Agent(id: BigInt) extends ActorRef
object Agent {
  case object Lock extends Msg
  case object Unlock extends Msg
  case object Grant extends Msg
}

// The head of `agents` holds the lock, the tail are waiting for the lock
case class ServerB(agents: List[ActorRef]) extends Behavior {
  def isLocked: Boolean = agents.nonEmpty

  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case Server.Lock(agent) if agents.isEmpty =>
      agent ! Agent.Grant
      ServerB(List(agent))

    case Server.Lock(agent) =>
      ServerB(agents :+ agent)

    case Server.Unlock(agent) if agents.nonEmpty =>
      val newAgents = agents.tail
      if (newAgents.nonEmpty) newAgents.head ! Agent.Grant
      ServerB(newAgents)

    case _ =>
      Behavior.same
  }
}

case class AgentB(holdsLock: Boolean) extends Behavior {
  def processMsg(msg: Msg)(implicit ctx: ActorContext): Behavior = msg match {
    case Agent.Lock =>
      Server() ! Server.Lock(ctx.self)
      Behavior.same

    case Agent.Unlock if holdsLock =>
      Server() ! Server.Unlock(ctx.self)
      AgentB(false)

    case Agent.Grant =>
      AgentB(true)

    case _ =>
      Behavior.same
  }
}
\end{Code}

An obvious property we might want to prove is that, at any time, at most one of those agents thinks that it holds the lock. Additionally, we'd like to ensure that such an agent is actually the same one that the server granted the lock too. We express this property in \RefCode{lst:LockServiceInv}.

\begin{Code}{PureScala}{lst:LockServiceInv}{Lock service invariant}
def validBehaviors(s: ActorSystem): Boolean = {
  s.behaviors(Server()).isInstanceOf[ServerB] &&
  forall { (a: Agent) =>
  	s.behaviors(a).isInstanceOf[AgentB]
  }
}

def noMsgstoSelf(s: ActorSystem): Boolean = forall { (ref: ActorRef) =>
  s.inboxes(ref -> ref).isEmpty
}

def hasLock(s: ActorSystem, a: ActorRef): Boolean = {
  s.behaviors(a) match {
    case AgentB(hasLock) => hasLock
    case _ => false
  }
}

def mutex(s: ActorSystem): Boolean = forall { (a: ActorRef, b: ActorRef) =>
  (a != b) ==> !(hasLock(s, a) && hasLock(s, b))
}

def hasLockThenHead(s: ActorSystem): Boolean = forall { (ref: ActorRef) =>
  hasLock(s, ref) ==> {
    s.behaviors(Server()) match {
      case ServerB(Cons(head, _)) => head == ref
      case _ => false
    }
  }
}

def invariant(s: ActorSystem): Boolean = {
  validBehaviors(s)  &&
  noMsgstoSelf(s)    &&
  mutex(s)           &&
  hasLockThenHead(s)
}
\end{Code}

\TODO{Lock service results}

\subsubsection*{Leader Election}

\TODO{Leader election}

\subsubsection*{Key-value store}

\TODO{KV store}

\subsection{Executing an Actor System with Akka}
\label{traces}

\section{Strong Eventual Consistency with CRDTs}
\label{crdt}

\TODO{CRDTs}

\section{Biparty Communication Protocols}
\label{biparty}

\TODO{Bipart}

\section{Conclusion}
\label{conclusion}

\TODO{Conclusion}

\section{Future Work}
\label{futurework}

\appendix

\TODO{Future Work}

\clearpage

\bibliographystyle{ieeetr}
\bibliography{report}

\end{document}
